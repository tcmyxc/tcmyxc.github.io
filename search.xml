<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Effective C++学习笔记</title>
    <url>/archives/8675909c.html</url>
    <content><![CDATA[<h1 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h1><p>1、优先使用 auto，而非显式类型声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;<span class="comment">// 存在未初始化的风险，但是编译不会报错</span></span><br><span class="line"><span class="keyword">auto</span> y;<span class="comment">// 如果不初始化，编译就会报错</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>2、如果 auto 推导的类型不符合要求，改用传统的</p>
<blockquote>
<p>详见 Effective Modern C++ 条款6</p>
</blockquote>
<p>3、使用 nullptr，不使用 NULL 或 0</p>
<p>4、用 using 不用 typedef</p>
<p>别名声明 <code>using</code>，起别名可以这样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Integer = <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个不算好的示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> Integer = <span class="keyword">int</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">	Integer x = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C++</category>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch</title>
    <url>/archives/d32d37e5.html</url>
    <content><![CDATA[<h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><blockquote>
<p>  百度百科：</p>
<p>  是一个基于<a href="https://baike.baidu.com/item/Lucene/6753302">Lucene</a>的搜索服务器。提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。</p>
<p>  是一种流行的企业级搜索引擎。用于<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353">云计算</a>，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p>
<p>  与名为Logstash的数据收集和日志解析引擎以及名为Kibana的分析和可视化平台一起开发。这三个产品被设计成一个集成解决方案，称为“Elastic Stack”</p>
<p>  支持实时GET请求，适合作为NoSQL数据存储，但缺少<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F/7316617">分布式</a>事务</p>
<p>  写入和查询对资源的消耗都很大，如何合理有效地控制资源，既能满足写入和查询的需求，又能满足资源充分利用，这个问题需要考虑</p>
<p>  官方介绍：</p>
<p>  Elasticsearch 是一个分布式的开源搜索和分析引擎，适用于所有类型的数据，包括文本、数字、地理空间、结构化和非结构化数据。Elasticsearch 在 Apache Lucene 的基础上开发而成，由 Elasticsearch N.V.（即现在的 Elastic）于 2010 年首次发布。Elasticsearch 以其简单的 REST 风格 API、分布式特性、速度和可扩展性而闻名，是 Elastic Stack 的核心组件；Elastic Stack 是适用于数据采集、充实、存储、分析和可视化的一组开源工具。人们通常将 Elastic Stack 称为 ELK Stack（代指 Elasticsearch、Logstash 和 Kibana），目前 Elastic Stack 包括一系列丰富的轻量型数据采集代理，这些代理统称为 Beats，可用来向 Elasticsearch 发送数据。</p>
</blockquote>
<span id="more"></span>

<p>分布式、高扩展、高实时的搜索与<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/6577123">数据分析</a>引擎</p>
<p><img src="../images/image-20210103202906338.png" alt="image-20210103202906338"></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>1、将数据提交到Elasticsearch 数据库中</p>
<p>2、通过分词控制器去将对应的语句分词，将其权重和分词结果一并存入数据</p>
<p>3、当用户搜索数据时候，再根据权重将结果排名，打分，再将返回结果呈现给用户</p>
<p>Solr是一个高性能，采用<a href="https://baike.baidu.com/item/Java/85979">Java</a>开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的<a href="https://baike.baidu.com/item/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">全文搜索引擎</a>。</p>
<p>主要特性包括：高效、灵活的缓存功能，垂直搜索功能，高亮显示搜索结果，通过索引复制来提高可用性，提供一套强大Data Schema来定义字段，类型和设置<a href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90">文本分析</a>，提供基于Web的管理界面等。</p>
<h2 id="ES和solr的差别"><a href="#ES和solr的差别" class="headerlink" title="ES和solr的差别"></a>ES和solr的差别</h2><p>1、当单纯对已有数据进行检索，solr更快；ES建索引快，可用于实时查询</p>
<p>2、当实时建立索引的时候，solr会IO阻塞，查询性能较差，ES这时候优势明显</p>
<p>3、随着数据量的增加，solr的搜索效率会变得更低，es基本无变化</p>
<p>4、solr利用zookeeper进行分布式管理，ES自带分布式协调功能</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="../images/image-20210104195316906.png" alt="image-20210104195316906"></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">bin  启动文件</span><br><span class="line">config  配置文件</span><br><span class="line">	log4j2  日志配置文件</span><br><span class="line">	jvm.options  jvm相关配置</span><br><span class="line">	elasticsearch.yml  es配置文件</span><br><span class="line">lib  相关jar包</span><br><span class="line">modules  功能模块</span><br><span class="line">plugins  插件</span><br></pre></td></tr></table></figure>

<p>localhost:9200</p>
<p><img src="../images/image-20210104211345453.png" alt="image-20210104211345453"></p>
<p>可视化插件：head（需要解决跨域问题）</p>
<h3 id="head安装"><a href="#head安装" class="headerlink" title="head安装"></a>head安装</h3><p>1、下载解压</p>
<p>2、</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure>

<p>3、解决跨域访问问题</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#es配置文件中修改</span></span><br><span class="line"><span class="comment">#开启跨域</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#允许所有人访问</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<p>4、127.0.0.1:9100</p>
<p>中文网址：<a href="http://127.0.0.1:9100/?lang=zh">http://127.0.0.1:9100/?lang=zh</a></p>
<p><img src="../images/image-20210104210851589.png" alt="image-20210104210851589"></p>
<blockquote>
<p>  head当做数据展示工具。查询用Kibana</p>
</blockquote>
<h3 id="Kibana（port-5601"><a href="#Kibana（port-5601" class="headerlink" title="Kibana（port: 5601)"></a>Kibana（port: 5601)</h3><p>Kibana 是一个为 <a href="http://www.oschina.net/p/logstash">Logstash</a> 和 <a href="http://www.oschina.net/p/elasticsearch">ElasticSearch</a> 提供的日志分析的 Web 接口。可使用它对日志进行高效的搜索、可视化、分析等各种操作。</p>
<p>版本要和ES一致</p>
<p>我们使用Kibana开发工具进行数据操作</p>
<p><img src="../images/image-20210104204746447.png" alt="image-20210104204746447"></p>
<h3 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h3><p>Kibana配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">i18n.locale:</span> <span class="string">&quot;zh-CN&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="1、Node-与-Cluster"><a href="#1、Node-与-Cluster" class="headerlink" title="1、Node 与 Cluster"></a>1、Node 与 Cluster</h3><p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。</p>
<p>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p>
<h3 id="2、-Index"><a href="#2、-Index" class="headerlink" title="2、 Index"></a>2、 Index</h3><p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</p>
<p>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</p>
<p>查看当前节点的所有 Index</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://localhost:9200/_cat/indices?v</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210104213128327.png" alt="image-20210104213128327"></p>
<h3 id="3、Document"><a href="#3、Document" class="headerlink" title="3、Document"></a>3、Document</h3><p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。</p>
<p>Document 使用 JSON 格式表示，下面是一个例子。</p>
   <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;user&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;数据库管理&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p>
<h3 id="4、Type（移除）"><a href="#4、Type（移除）" class="headerlink" title="4、Type（移除）"></a>4、Type（移除）</h3><p>Document 可以分组，比如<code>weather</code>这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。</p>
<p>不同的 Type 应该有相似的结构（schema），举例来说，<code>id</code>字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的<a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/mapping.html">一个区别</a>。性质完全不同的数据（比如<code>products</code>和<code>logs</code>）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p>
<p>列出每个 Index 所包含的 Type。</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">localhost:9200/_mapping?pretty=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>根据<a href="https://www.elastic.co/blog/index-type-parent-child-join-now-future-in-elasticsearch">规划</a>，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。</p>
<h1 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h1><p>两种分词策略：</p>
<ul>
<li>  ik_max_word：会将文本做最细粒度的拆分</li>
<li>  ik_smart：会将文本做最粗粒度的拆分</li>
</ul>
<p>直接放在ES的插件目录下即可，然后重启ES</p>
<p>使用Kibana查看分词结果：</p>
<p><img src="../images/image-20210104215913849.png" alt="image-20210104215913849"></p>
<p><img src="../images/image-20210104215940169.png" alt="image-20210104215940169"></p>
<blockquote>
<p>  有些词汇被过度拆分，需要我们手动加到词典里面，在配置文件中自己加</p>
</blockquote>
<h1 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a>REST风格</h1><p>REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/7485920">软件架构</a>风格。它是一种针对<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/2196523">网络应用</a>的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。</p>
<p>REST是设计风格而不是标准</p>
<p><img src="../images/image-20210104221641139.png" alt="image-20210104221641139"></p>
<p>1、创建一个索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /索引/类型名/id</span><br><span class="line">&#123;</span><br><span class="line">	请求体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>1、找官方文档</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p>
<p><img src="../images/image-20210104225442026.png" alt="image-20210104225442026"></p>
<p>2、找依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span>    <span class="tag">&lt;<span class="name">repository</span>&gt;</span>        <span class="tag">&lt;<span class="name">id</span>&gt;</span>es-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>        <span class="tag">&lt;<span class="name">name</span>&gt;</span>elasticsearch snapshot repo<span class="tag">&lt;/<span class="name">name</span>&gt;</span>        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://snapshots.elastic.co/maven/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、找对象</p>
<p><img src="../images/image-20210104225711505.png" alt="image-20210104225711505"></p>
<p>高级客户端调低级的，低级的维护线程池</p>
<p>！！！用完一定要关闭</p>
<p>4、分析类中的方法</p>
<blockquote>
<p>  创建项目</p>
</blockquote>
<p>1、创建一个空项目</p>
<p>2、新建一个模块，添加相应的依赖</p>
<p>3、配置JDK的版本</p>
<p><img src="../images/image-20210104230630801.png" alt="image-20210104230630801"></p>
<p><img src="../images/image-20210104230710933.png" alt="image-20210104230710933"></p>
<p><img src="../images/image-20210105071956199.png" alt="image-20210105071956199"></p>
<blockquote>
<p>  分析</p>
</blockquote>
<p><img src="../images/image-20210104231753274.png" alt="image-20210104231753274"></p>
<blockquote>
<p>  自定义版本依赖，保证和本地一致</p>
</blockquote>
<p><img src="../images/image-20210104232717397.png" alt="image-20210104232717397"></p>
<p><img src="../images/image-20210104232736307.png" alt="image-20210104232736307"></p>
<p><img src="../images/image-20210104232754643.png" alt="image-20210104232754643"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="comment">&lt;!--自定义版本依赖，和自己电脑上的一致--&gt;</span>    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.10.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="../images/image-20210105070050309.png" alt="image-20210105070050309"></p>
<p><img src="../images/image-20210105070350055.png" alt="image-20210105070350055"></p>
<blockquote>
<p>  具体API测试</p>
</blockquote>
<h1 id="官方说明"><a href="#官方说明" class="headerlink" title="官方说明"></a>官方说明</h1><h2 id="Elasticsearch-的用途是什么？"><a href="#Elasticsearch-的用途是什么？" class="headerlink" title="Elasticsearch 的用途是什么？"></a>Elasticsearch 的用途是什么？</h2><p>Elasticsearch 在速度和可扩展性方面都表现出色，而且还能够索引多种类型的内容，这意味着其可用于多种用例：</p>
<ul>
<li>  应用程序搜索</li>
<li>  网站搜索</li>
<li>  企业搜索</li>
<li>  日志处理和分析</li>
<li>  基础设施指标和容器监测</li>
<li>  应用程序性能监测</li>
<li>  地理空间数据分析和可视化</li>
<li>  安全分析</li>
<li>  业务分析</li>
</ul>
<h2 id="Elasticsearch-的工作原理是什么？"><a href="#Elasticsearch-的工作原理是什么？" class="headerlink" title="Elasticsearch 的工作原理是什么？"></a>Elasticsearch 的工作原理是什么？</h2><p>原始数据会从多个来源（包括日志、系统指标和网络应用程序）输入到 Elasticsearch 中。<em>数据采集</em>指在 Elasticsearch 中进行<em>索引</em>之前解析、标准化并充实这些原始数据的过程。这些数据在 Elasticsearch 中索引完成之后，用户便可针对他们的数据运行复杂的查询，并使用聚合来检索自身数据的复杂汇总。在 Kibana 中，用户可以基于自己的数据创建强大的可视化，分享仪表板，并对 Elastic Stack 进行管理。</p>
<h2 id="Elasticsearch-索引是什么？"><a href="#Elasticsearch-索引是什么？" class="headerlink" title="Elasticsearch 索引是什么？"></a>Elasticsearch 索引是什么？</h2><p>Elasticsearch <em>索引</em>指相互关联的文档集合。Elasticsearch 会以 <strong>JSON 文档的形式存储数据</strong>。每个文档都会在一组<em>键</em>（字段或属性的名称）和它们对应的值（字符串、数字、布尔值、日期、<em>数值</em>组、地理位置或其他类型的数据）之间建立联系。</p>
<p>Elasticsearch 使用的是一种名为<em>倒排索引</em>的数据结构，这一结构的设计可以允许十分快速地进行全文本搜索。倒排索引会列出在所有文档中出现的每个特有词汇，并且可以找到包含每个词汇的全部文档。</p>
<p>在索引过程中，Elasticsearch 会存储文档并构建倒排索引，这样用户便可以近实时地对文档数据进行搜索。索引过程是在索引 API 中启动的，通过此 API 您既可向特定索引中添加 JSON 文档，也可更改特定索引中的 JSON 文档。</p>
<h2 id="Logstash-的用途是什么？"><a href="#Logstash-的用途是什么？" class="headerlink" title="Logstash 的用途是什么？"></a>Logstash 的用途是什么？</h2><p>Logstash 是 Elastic Stack 的核心产品之一，可用来对数据进行聚合和处理，并将数据发送到 Elasticsearch。Logstash 是一个开源的服务器端<strong>数据处理管道</strong>，允许您在将数据索引到 Elasticsearch 之前同时从多个来源采集数据，并对数据进行充实和转换。</p>
<h2 id="Kibana-的用途是什么？"><a href="#Kibana-的用途是什么？" class="headerlink" title="Kibana 的用途是什么？"></a>Kibana 的用途是什么？</h2><p>Kibana 是一款适用于 Elasticsearch 的<strong>数据可视化和管理工具</strong>，可以提供实时的直方图、线形图、饼状图和地图。Kibana 同时还包括诸如 Canvas 和 Elastic Maps 等高级应用程序；Canvas 允许用户基于自身数据创建定制的动态信息图表，而 Elastic Maps 则可用来对地理空间数据进行可视化。</p>
<h2 id="为何使用-Elasticsearch？"><a href="#为何使用-Elasticsearch？" class="headerlink" title="为何使用 Elasticsearch？"></a>为何使用 Elasticsearch？</h2><p><strong>Elasticsearch 很快。</strong> 由于 Elasticsearch 是在 Lucene 基础上构建而成的，所以在全文本搜索方面表现十分出色。Elasticsearch 同时还是一个<strong>近实时的搜索平台</strong>，这意味着从文档索引操作到文档变为可搜索状态之间的延时很短，一般只有一秒。因此，Elasticsearch 非常适用于对时间有严苛要求的用例，例如安全分析和基础设施监测。</p>
<p><strong>Elasticsearch 具有分布式的本质特征。</strong> Elasticsearch 中存储的文档分布在不同的容器中，这些容器称为<em>分片</em>，可以进行复制以提供数据冗余副本，以防发生硬件故障。Elasticsearch 的分布式特性使得它可以扩展至数百台（甚至数千台）服务器，并处理 PB 量级的数据。</p>
<p><strong>Elasticsearch 包含一系列广泛的功能。</strong> 除了速度、可扩展性和弹性等优势以外，Elasticsearch 还有大量强大的内置功能（例如数据汇总和索引生命周期管理），可以方便用户更加高效地存储和搜索数据。</p>
<p><strong>Elastic Stack 简化了数据采集、可视化和报告过程。</strong> 通过与 Beats 和 Logstash 进行集成，用户能够在向 Elasticsearch 中索引数据之前轻松地处理数据。同时，Kibana 不仅可针对 Elasticsearch 数据提供实时可视化，同时还提供 UI 以便用户快速访问应用程序性能监测 (APM)、日志和基础设施指标等数据。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM和Java体系结构(尚硅谷版)</title>
    <url>/archives/d52a7e56.html</url>
    <content><![CDATA[<h1 id="JVM和Java体系结构"><a href="#JVM和Java体系结构" class="headerlink" title="JVM和Java体系结构"></a>JVM和Java体系结构</h1><p>练好内功</p>
<p><img src="../images/image-20210707223229867.png" alt="image-20210707223229867"></p>
<span id="more"></span>

<h2 id="Java生态圈"><a href="#Java生态圈" class="headerlink" title="Java生态圈"></a>Java生态圈</h2><p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p>
<ul>
<li>作为一个平台，Java虚拟机扮演着举足轻重的作用<ul>
<li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li>
</ul>
</li>
<li>作为灯种文化，Java几乎成为了“开源”的代名词。<ul>
<li>第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。</li>
<li>就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。</li>
</ul>
</li>
</ul>
<p>每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理</p>
<p><img src="../images/image-20200704152052489.png" alt="image-20200704152052489"></p>
<p>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。</p>
<p>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p>
<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。</p>
<p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p>
<p>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式—Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</p>
<h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><p>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</p>
<p>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p>
<p>Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</p>
<p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p>
<p>特点：</p>
<ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><ul>
<li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li>
<li>它采用解释器与即时编译器并存的架构。</li>
<li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。</li>
</ul>
<p><img src="../images/image-20200704183436495.png" alt="image-20200704183436495"></p>
<p>执行引擎包含三部分：解释器，及时编译器，垃圾回收器</p>
<h2 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h2><p><img src="../images/image-20200704210429535.png" alt="image-20200704210429535"></p>
<p>只是能生成被Java虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了</p>
<h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：</p>
<p>基于栈式架构的特点</p>
<ul>
<li>设计和实现更简单，适用于资源受限的系统；</li>
<li>避开了寄存器的分配难题：使用零地址指令方式分配。</li>
<li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台</li>
</ul>
<p>基于寄存器架构的特点</p>
<ul>
<li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li>
<li>指令集架构则完全依赖硬件，可移植性差</li>
<li>性能优秀和执行更高效</li>
<li>花费更少的指令去完成一项操作。</li>
<li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋</li>
</ul>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tcmyxc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackSturTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javap -v StackSturTest.class</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC<span class="built_in">_</span>PUBLIC, ACC<span class="built_in">_</span>STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=4, args<span class="built_in">_</span>size=1</span><br><span class="line">         0: iconst<span class="built_in">_</span>2</span><br><span class="line">         1: istore<span class="built_in">_</span>1</span><br><span class="line">         2: iconst<span class="built_in">_</span>3</span><br><span class="line">         3: istore<span class="built_in">_</span>2</span><br><span class="line">         4: iload<span class="built_in">_</span>1</span><br><span class="line">         5: iload<span class="built_in">_</span>2</span><br><span class="line">         6: iadd</span><br><span class="line">         7: istore<span class="built_in">_</span>3</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 2</span><br><span class="line">        line 8: 4</span><br><span class="line">        line 9: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">            2       7     1     i   I</span><br><span class="line">            4       5     2     j   I</span><br><span class="line">            8       1     3     k   I</span><br></pre></td></tr></table></figure>



<p>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p>
<h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li>
<li>程序开始执行时他才运行，程序结束时他就停止。</li>
<li>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。</li>
</ul>
<h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下的几种情况：</p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统用现错误而导致Java虚拟机进程终止</li>
<li>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li>
<li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</li>
</ul>
<h2 id="Hotspot"><a href="#Hotspot" class="headerlink" title="Hotspot"></a>Hotspot</h2><p>热点代码探测技术</p>
<ul>
<li>通过计数器找到最具编译价值的代码，从而触发即时编译或者栈上替换</li>
<li>通过编译器和解释器协同工作，在最优的程序响应时间和最佳的执行性能中取得平衡</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载子系统</title>
    <url>/archives/13cb3a0e.html</url>
    <content><![CDATA[<p>如果自己手写一个JVM，主要考虑那些结构？</p>
<p>类加载器和执行引擎</p>
<h2 id="类加载器与加载过程"><a href="#类加载器与加载过程" class="headerlink" title="类加载器与加载过程"></a>类加载器与加载过程</h2><p><img src="../images/image-20210708163350879.png" alt="image-20210708163350879"></p>
<span id="more"></span>

<h3 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h3><ul>
<li>加载 Class 文件（来源可以是文件系统或者网络），Class 文件开头有特定的文件标识</li>
<li>只负责加载，不负责执行（执行引擎负责执行）</li>
<li>加载的类信息放在方法区。<ul>
<li>方法区放：类信息，运行时常量池信息，字符串字面量和数字常量（这部分是 Class 文件中常量池部分的内存映射）</li>
</ul>
</li>
</ul>
<blockquote>
<p>运行时常量池：常量池加载到内存里面就是 运行时常量池</p>
</blockquote>
<p><img src="../images/image-20210708163646085.png" alt="image-20210708163646085"></p>
<h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><p><img src="../images/image-20210708164146742.png" alt="image-20210708164146742"></p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul>
<li>通过类的全限定名获取定义该类的二进制字节流</li>
<li>将字节流代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成这个类对应的 Class 对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<p>补充：加载 <code>.class</code> 文件的方式</p>
<ul>
<li>本地系统加载</li>
<li>通过网络获取（Web Applet）</li>
<li>从 zip 压缩包中获取（jar，war 格式的基础）</li>
<li>运行时计算生成，比如动态代理技术</li>
<li>从其他文件生成，如 JSP 应用</li>
<li>从专有的数据库提取</li>
<li>从加密文件中提取（防止被反编译）</li>
</ul>
<h3 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h3><p><strong>验证(Verify)</strong></p>
<ul>
<li>确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li>
<li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li>
</ul>
<p><strong>准备(Prepare)</strong> </p>
<p>为类变量分配内存并且设置该类变量的默认初始值，即零值。</p>
<p>这里不包含用final修饰的static变量，因为final在编译的时候就会分配了，准备阶段会显式初始化;</p>
<p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p>
<p><strong>解析(Resolve) :</strong></p>
<p>将常量池内的符号引用转换为直接引用的过程。</p>
<p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</p>
<p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT class info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>就是执行类构造器方法 <code>&lt;clinit&gt;()</code> 的过程</li>
<li>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行。</li>
<li><code>&lt;clinit&gt; ()</code>不同于类的构造器。(关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code> )</li>
<li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕。</li>
<li>虚拟机必须保证一个类的<code>&lt;clinit&gt; ()</code>方法在多线程下被同步加锁（一个类只能被加载一次）</li>
</ul>
<blockquote>
<p>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外</p>
</blockquote>
<p>注意：如果没有类变量和静态代码块，就不会生成 <code>&lt;clinit&gt;()</code> 方法</p>
<p>验证的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有静态变量和静态代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClinitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Class 文件截图（使用 <code>jclasslib bytecode viewer</code> 软件查看）</p>
<p><img src="../images/image-20210708181034123.png" alt="image-20210708181034123"></p>
<p>如果加上一个静态变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>再次查看：</p>
<p><img src="../images/image-20210708180924638.png" alt="image-20210708180924638"></p>
<h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p><img src="../images/image-20210708182410905.png" alt="image-20210708182410905"></p>
<p>四者是包含关系，不是上层下层，也不是父子类的继承关系</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>一共有两类：</p>
<ul>
<li>引导类加载器（使用 C 语言编写的）</li>
<li>自定义类加载器（所有派生于抽象类 <code>ClassLoader</code> 的类加载器都是自定义的）</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取其上层：拓展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">// sun.misc.Launcher$ExtClassLoader@1b6d3586</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 试图获取上层：获取不到</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户自定义类：默认使用系统类加载器进行加载</span></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);<span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// String 类：使用 引导类加载器 加载的  ---&gt; Java 核心类库都是 引导类加载器 加载的</span></span><br><span class="line">        ClassLoader stringClassLoader = String.class.getClassLoader();</span><br><span class="line">        System.out.println(stringClassLoader);<span class="comment">// null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h3><ul>
<li><p> C 语言实现，嵌套在JVM内部</p>
</li>
<li><p>用来加载Java的核心库（JAVA_HOME/jre/ lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</p>
</li>
<li><p>并不继承自<code>java.lang.ClassLoader</code>，没有父加载器。</p>
</li>
<li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p>
</li>
<li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun 开头的类</p>
</li>
</ul>
<h3 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h3><ul>
<li>Java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code> 实现（内部类）</li>
<li>派生于 ClassLoader 类</li>
<li>父加载器是引导类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
<h3 id="应用程序类（系统类）加载器"><a href="#应用程序类（系统类）加载器" class="headerlink" title="应用程序类（系统类）加载器"></a>应用程序类（系统类）加载器</h3><ul>
<li>Java编写，由<code>sun.misc.Launcher$AppClassLoader</code>实现</li>
<li>派生于 ClassLoader 类</li>
<li>父加载器是拓展类加载器</li>
<li>加载环境变量 <code>classpath</code>或系统属性<code>java.class.path</code>指定路径下的类库</li>
<li>程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li>
<li>通过<code>ClassLoader#getSystemClassLoader()</code>方法可以获取到该类加载器</li>
</ul>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>一般来说上面三个够用了</p>
<h4 id="什么时候自己定义呢？"><a href="#什么时候自己定义呢？" class="headerlink" title="什么时候自己定义呢？"></a>什么时候自己定义呢？</h4><ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>拓展加载源</li>
<li>防止源码泄露</li>
</ul>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>1、可以继承抽象类java.lang.classLoader，实现自己的类加载器</p>
<p>2、在JDK1.2之前，在自定义类加载器时，总会去继承classLoader类并重写loadClass ()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass ()方法，而是建议把自定义的类加载逻辑写在findclass ()方法中</p>
<p>3、在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findclass ()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<h3 id="ClassLoader抽象类"><a href="#ClassLoader抽象类" class="headerlink" title="ClassLoader抽象类"></a>ClassLoader抽象类</h3><p><img src="../images/image-20210711134112840.png" alt="image-20210711134112840"></p>
<h3 id="获取加载器的方式"><a href="#获取加载器的方式" class="headerlink" title="获取加载器的方式"></a>获取加载器的方式</h3><p><img src="../images/image-20210711134348092.png" alt="image-20210711134348092"></p>
<h2 id="双亲委派机制（面试常问）"><a href="#双亲委派机制（面试常问）" class="headerlink" title="双亲委派机制（面试常问）"></a>双亲委派机制（面试常问）</h2><p>class 字节码文件是按需加载的</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>（1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行;</p>
<p>（2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器;</p>
<p>（3）如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p>
<p><img src="../images/image-20210711134949125.png" alt="image-20210711134949125"></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心 API 被篡改<ul>
<li>比如你自己定义一个 <code>java.lang.String</code></li>
</ul>
</li>
</ul>
<h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p>自定义string类，但是在加载自定义string类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中<code>java\lang \String.class</code>)，报错信息说没有main方法就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p>
<h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="两个class对象是否为同一个类"><a href="#两个class对象是否为同一个类" class="headerlink" title="两个class对象是否为同一个类"></a>两个class对象是否为同一个类</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件:</p>
<ul>
<li>类的完整类名必须一致，包括包名。</li>
<li>加载这个类的classLoader(指classLoader实例对象)必须相同。</li>
</ul>
<p>换句话说，在JVM中，即使这两个类对象(class对象)来源同一个class文件，被同一个虚拟机所加载，但只要加载它们的classLoader实例对象不同，那么这两个类对象也是不相等的。</p>
<h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。</p>
<p>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解沂一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
<h3 id="类的主动和被动使用"><a href="#类的主动和被动使用" class="headerlink" title="类的主动和被动使用"></a>类的主动和被动使用</h3><p>主动使用，又分为七种情况:</p>
<p>（1）创建类的实例</p>
<p>（2）访问某个类或接口的静态变量，或者对该静态变量赋值</p>
<p>（3）调用类的静态方法</p>
<p>（4）反射（比如:Class.forName ( “com.atguigu . Test” ) )</p>
<p>（5）初始化一个类的子类</p>
<p>（6）Java虚拟机启动时被标明为启动类的类</p>
<p>（7）JDK 7 开始提供的动态语言支持</p>
<ul>
<li>java . lang. invoke.MethodHandle实例的解析结果</li>
<li>REF_getstatic、REF_putstatic、REF_invokestatic句柄对应的类没有初始化，则初始化</li>
</ul>
<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都<strong>不会</strong>导致类的初始化。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8的新特性</title>
    <url>/archives/38dc13e5.html</url>
    <content><![CDATA[<h1 id="JDK-8-中的新特性"><a href="#JDK-8-中的新特性" class="headerlink" title="JDK 8 中的新特性"></a>JDK 8 中的新特性</h1><span id="more"></span>

<ul>
<li><a href="https://www.oracle.com/technetwork/java/javase/jdk-relnotes-index-2162236.html?ssSourceSiteId=otncn">JDK 版本说明</a></li>
<li><a href="https://www.oracle.com/technetwork/java/javase/documentation/8u-relnotes-2225394.html?ssSourceSiteId=otncn">JDK 8 版本说明</a></li>
</ul>
<p>Java Platform, Standard Edition 8 是一个拥有丰富特性的主要版本。本文档总结了 Java SE 8、JDK 8 以及 Oracle 的 Java SE 8 实现中的特性和增强。单击组件名称可获取该组件增强功能更详细的描述。</p>
<ul>
<li><h4 id="Java-编程语言"><a href="#Java-编程语言" class="headerlink" title="Java 编程语言"></a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/enhancements.html#javase8">Java 编程语言</a></h4><ul>
<li>Lambda 表达式是一个新的语言特性，已经在此版本中引入。该特性让您可以将功能视为方法参数，或者将代码视为数据。使用 Lambda 表达式，您可以更简洁地表示单方法接口（称为功能接口）的实例。</li>
<li>方法引用为已经具有名称的方法提供了易于理解的 lambda 表达式。</li>
<li>默认方法允许将新功能添加到库的接口中，并确保与为这些接口的旧版本编写的代码的二进制兼容性。</li>
<li>重复批注支持对同一个声明或类型的使用多次应用相同的批注类型。</li>
<li>类型批注支持在使用类型的任何地方应用批注，而不仅限于声明。与可插拔类型系统结合使用时，此特性可改进代码的类型检查。</li>
<li>改进类型推断。</li>
<li>方法参数反射。</li>
</ul>
</li>
<li><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/changes8.html">集合</a></h4><ul>
<li>新的<code>java.util.stream</code>包中的类提供了一个 Stream API，支持对元素流进行函数式操作。Stream API 集成在 Collections API 中，可以对集合进行批量操作，例如顺序或并行的 map-reduce 转换。</li>
<li>针对存在键冲突的 HashMap 的性能改进</li>
</ul>
</li>
<li><p>**<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/compactprofiles/">紧凑 profile</a>**包含 Java SE 平台的预定义子集，并且支持不需要在小型设备上部署和运行整个平台的应用。</p>
</li>
<li><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/enhancements-8.html">安全性</a></h4><ul>
<li>默认启用客户端 TLS 1.2</li>
<li><code>AccessController.doPrivileged</code> 的新变体支持代码断言其权限的子集，而不会阻止完全遍历堆栈来检查其他权限</li>
<li>更强大的基于密码的加密算法</li>
<li>JSSE 服务器端支持 SSL/TLS 服务器名称指示 (SNI) 扩展</li>
<li>支持 AEAD 算法：SunJCE 提供程序得到了增强，支持 AES/GCM/NoPadding 密码实现以及 GCM 算法参数。而且 SunJSSE 提供程序也得到了增强，支持基于 AEAD 模式的密码套件。请参阅 Oracle 提供程序文档，JEP 115。</li>
<li>密钥库增强，包括新的域密钥库类型 <code>java.security.DomainLoadStoreParameter</code>, 和为 keytool 实用程序新增的命令选项<code>-importpassword</code></li>
<li>SHA-224 消息摘要</li>
<li>增强了对 NSA Suite B 加密的支持</li>
<li>更好地支持高熵随机数生成</li>
<li>新增了 <code>java.security.cert.PKIXRevocationChecker</code> 类，用于配置 X.509 证书的撤销检查</li>
<li>适用于 Windows 的 64 位 PKCS11</li>
<li>Kerberos 5 重放缓存中新增了 rcache 类型</li>
<li>支持 Kerberos 5 协议转换和受限委派</li>
<li>默认禁用 Kerberos 5 弱加密类型</li>
<li>适用于 GSS-API/Kerberos 5 机制的未绑定 SASL</li>
<li>针对多个主机名称的 SASL 服务</li>
<li>JNI 桥接至 Mac OS X 上的原生 JGSS</li>
<li>SunJSSE 提供程序中支持更强大的临时 DH 密钥</li>
<li>JSSE 中支持服务器端加密套件首选项自定义</li>
</ul>
</li>
<li><h4 id="JavaFX"><a href="#JavaFX" class="headerlink" title="JavaFX"></a><a href="https://docs.oracle.com/javase/8/javase-clienttechnologies.htm">JavaFX</a></h4><ul>
<li><p>本版本中实施了新的 Modena 主题。有关更多信息，请参阅 <a href="https://fxexperience.com/2013/03/modena-theme-update/">xexperience.com</a>.</p>
</li>
<li><p>新的 <code>SwingNode</code> 类允许开发人员将 Swing 内容嵌入到 JavaFX 应用中。请参阅<a href="https://docs.oracle.com/javase/8/javafx/api/javafx/embed/swing/SwingNode.html">SwingNode</a> javadoc 和 <a href="http://docs.oracle.com/javase/8/javafx/interoperability-tutorial/embed-swing.htm">将 Swing 内容嵌入 JavaFX 应用中。</a>.</p>
</li>
<li><p>新的 UI 控件包括 <a href="http://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/DatePicker.html"><code>DatePicker</code></a> 和 <a href="http://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/TreeTableView.html"><code>TreeTableView</code></a> 控件。</p>
</li>
<li><p><code>javafx.print</code> 程序包为 JavaFX Printing API 提供了公共类。有关更多信息，请参阅 <a href="http://docs.oracle.com/javase/8/javafx/api/javafx/print/package-summary.html">javadoc</a></p>
</li>
<li><p>3D 图形特性现在包括 3D 形状、摄像头、灯光、子场景、材料、挑选和抗锯齿。JavaFX 3D 图形库中新增了 <code>Shape3D</code> (<code>Box</code>, <code>Cylinder</code>, <code>MeshView</code>和 <code>Sphere</code>子类 ), <code>SubScene</code>, <code>Material</code>, <code>PickResult</code>, <code>LightBase</code> (<code>AmbientLight</code> 和 <code>PointLight</code> 子类) , 和 <code>SceneAntialiasing</code> API 类。此版本中的<code>Camera</code> API 类也已更新。请参阅 <code>javafx.scene.shape.Shape3D</code>, <code>javafx.scene.SubScene</code>, <code>javafx.scene.paint.Material</code>, <code>javafx.scene.input.PickResult</code>和, <code>javafx.scene.SceneAntialiasing</code>, 类的相关 javadoc 以及 <a href="http://docs.oracle.com/javase/8/javafx/graphics-tutorial/javafx-3d-graphics.htm">JavaFX 3D 图形入门 </a>文档。</p>
</li>
<li><p><code>WebView</code> WebView 类包含新特性和改进。有关其他 HTML5 特性（包括 Web 套接字、Web 辅助进程和 Web 字体）的更多信息，请参阅</p>
</li>
<li><p>增强了文本支持，包括双向文本、复杂文本脚本（如泰语和印地语控件）以及文本节点中的多行多样式文本。此版本添加了对 Hi-DPI 显示的支持。</p>
</li>
<li><p><a href="http://docs.oracle.com/javase/8/javafx/embedded-browser-tutorial/index.html">CSS Styleable* 类已成为公共 API。有关更多信息，请参阅 </a><a href="http://docs.oracle.com/javase/8/javafx/api/javafx/css/package-frame.html">javafx.css</a> javadoc。</p>
</li>
<li><p>新的 <a href="http://docs.oracle.com/javase/8/javafx/api/javafx/concurrent/ScheduledService.html">ScheduledService</a> 类允许自动重新启动服务。</p>
</li>
<li><p>JavaFX 现在可用于 ARM 平台。适用于 ARM 的 JDK 包含 JavaFX 的基础组件、图形组件和控制组件。</p>
</li>
</ul>
</li>
<li><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a><a href="http://docs.oracle.com/javase/8/docs/technotes/tools/enhancements-8.html">工具</a></h4><ul>
<li>可通过 <code>jjs</code> 命令来调用 Nashorn 引擎。</li>
<li><code>java</code> 命令用于启动 JavaFX 应用。</li>
<li>重新编写了 <code>java</code> 手册页。</li>
<li>可通过 <code>jdeps</code> 命令行工具来分析类文件。</li>
<li>Java Management Extensions (JMX) 支持远程访问诊断命令。</li>
<li>The <code>jarsigner</code>工具提供了一个选项用于请求获取时间戳机构 (TSA) 的签名时间戳。</li>
<li>Javac 工具<ul>
<li><code>javac</code> 命令的 <code>-parameters</code> 选项可用于存储正式参数名称，并启用反射 API 来检索正式参数名称。</li>
<li>命令现已正确实施了 Java 语言规范 (JLS) 第 15.21 节中的相等运算符的类型规则。 <code>javac</code></li>
<li>The <code>javac</code>工具现在支持检查 <code>javadoc</code> 注释的内容，从而避免在运行<code>javadoc</code> 时生成的文件中产生各种问题，例如无效的 HTML 或可访问性问题。可通过新的<code>-Xdoclint</code> 选项来启用此特性。有关更多详细信息，请参阅运行“javac-X”时的输出。此特性也可以在<code>javac -X</code>“. This feature is also available in the <code>javadoc</code>工具中使用，并且默认启用。</li>
<li><code>javac</code> 工具现在支持根据需要生成原生标头。这样便无需在构建管道中单独运行 <code>javah</code> 工具。可以使用新的 <code>-h</code> 选项在 <code>javac</code> 中启用此特性，该选项用于指定写入头文件的目录。将为任何具有原生方法或者使用 <code>java.lang.annotation.Native</code>类型的新批注的类进行批注的常量字段生成头文件。</li>
</ul>
</li>
<li>Javadoc 工具<ul>
<li><code>javadoc</code> 工具支持新的 <code>DocTree</code> API，让您可以将 Javadoc 注释作为抽象语法树来进行遍历。</li>
<li><code>javadoc</code> 工具支持新的 Javadoc Access API，让您可以直接从 Java 应用中调用 Javadoc 工具，而无需执行新的进程。有关更多信息，请参阅<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/whatsnew-8.html"> javadoc 新特性</a> 页面。</li>
<li><code>javadoc</code>工具现在支持检查<code>javadoc</code> 注释的内容，从而避免在运行 <code>javadoc</code> 时生成的文件中产生各种问题，例如无效的 HTML 或可访问性问题。此特性默认为启用状态，可以通过新的<code>-Xdoclint</code> 选项加以控制。有关更多详细信息，请参阅运行 “<code>javadoc -X</code>“ 时的输出。. <code>javac</code> 工具也支持此特性，但默认情况下并未启用它。</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/intl/enhancements.8.html">国际化</a></h4><ul>
<li>Unicode 增强，包括对 Unicode 6.2.0 的支持</li>
<li>采用 Unicode CLDR 数据和 java.locale.providers 系统属性</li>
<li>新增日历和区域设置 API</li>
<li>支持将自定义资源包作为扩展进行安装</li>
</ul>
</li>
<li><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jweb/enhancements-8.html">部署</a></h4><ul>
<li>现在可以使用 <code>URLPermission</code> 允许沙盒小程序和 Java Web Start 应用连接回启动它们的服务器。不再授予 <code>SocketPermission</code> 。</li>
<li>在所有安全级别，主 JAR 文件的 JAR 文件清单中都需要 Permissions 属性。</li>
</ul>
</li>
<li><p>**<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/datetime/index.html">Date-Time 程序包 </a>**— 一组新程序包，提供全面的日期-时间模型。</p>
</li>
<li><h4 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/scripting/enhancements.html#jdk8">脚本编写</a></h4><ul>
<li>Rhino Javascript 引擎已被替换为 <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/">Nashorn</a> JavaScript 引擎</li>
</ul>
</li>
<li><h4 id="Pack200"><a href="#Pack200" class="headerlink" title="Pack200"></a><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/pack200/enhancements.html">Pack200</a></h4><ul>
<li>Pack200 支持 JSR 292 引入的常量池条目和新字节码</li>
<li>JDK8 支持 JSR-292、JSR-308 和 JSR-335 指定的类文件更改</li>
</ul>
</li>
<li><h4 id="IO-和-NIO"><a href="#IO-和-NIO" class="headerlink" title="IO 和 NIO"></a><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/io/enhancements.html#jdk8">IO 和 NIO</a></h4><ul>
<li>全新的基于 Solaris 事件端口机制的面向 Solaris 的 <code>SelectorProvider</code> 实现。要使用它，请将系统属性<code>java.nio.channels.spi.Selector</code> 的值设置为 <code>sun.nio.ch.EventPortSelectorProvider</code>.</li>
<li>减小 <code>/jre/lib/charsets.jar</code> 文件的大小</li>
<li>提高了 <code>java.lang.String(byte[], *)</code> 构造函数和 <code>java.lang.String.getBytes()</code> 方法的性能。</li>
</ul>
</li>
<li><h4 id="java-lang-和-java-util-程序包"><a href="#java-lang-和-java-util-程序包" class="headerlink" title="java.lang 和 java.util 程序包"></a><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/lang/enhancements.html#jdk8">java.lang 和 java.util 程序包</a></h4><ul>
<li>并行数组排序</li>
<li>标准编码和解码 Base64</li>
<li>无符号算术支持</li>
</ul>
</li>
<li><h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/">JDBC</a></h4><ul>
<li>删除了 JDBC-ODBC Bridge。</li>
<li>JDBC 4.2 引入了新特性。</li>
</ul>
</li>
<li><h4 id="Java-DB"><a href="#Java-DB" class="headerlink" title="Java DB"></a>Java DB</h4><ul>
<li>JDK 8 包含 Java DB 10.10。</li>
</ul>
</li>
<li><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/net/enhancements-8.0.html">网络</a></h4><ul>
<li>已添加 <code>java.net.URLPermission</code> 类。</li>
<li>在 <code>java.net.HttpURLConnection</code>类中，如果安装了安全管理器，那么请求打开连接的调用需要权限。</li>
</ul>
</li>
<li><h4 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/changes8.html">并发性</a></h4><ul>
<li><code>java.util.concurrent</code> 程序包中新增了一些类和接口。</li>
<li>Methods have been added to the <code>java.util.concurrent.ConcurrentHashMap</code> 类中新增了一些方法，支持基于新增流工具和 lambda 表达式的聚合操作。</li>
<li><code>java.util.concurrent.atomic</code> 程序包中新增了一些类来支持可扩展、可更新的变量。</li>
<li><code>java.util.concurrent.ForkJoinPool</code> 类中新增了一些方法来支持通用池。</li>
<li>新增的 <code>java.util.concurrent.locks.StampedLock</code> 类提供了一个基于能力的锁，可通过三种模式来控制读/写访问。</li>
</ul>
</li>
<li><h4 id="Java-XML-JAXP"><a href="#Java-XML-JAXP" class="headerlink" title="Java XML - JAXP"></a><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/xml/enhancements.html">Java XML</a> - <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/xml/jaxp/enhancements-8.html">JAXP</a></h4></li>
<li><h4 id="HotSpot"><a href="#HotSpot" class="headerlink" title="HotSpot"></a><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/">HotSpot</a></h4><ul>
<li><p>新增的硬件内部函数以便使用高级加密标准 (AES)。<code>UseAES</code>和<code>UseAESIntrinsics</code>标志用于为 硬件启用基于硬件的 AES 内部函数。硬件必须是 2010 年或更新的 Westmere 硬件。例如，要启用硬件 AES，请使用以下标志：<code>-XX:+UseAES -XX:+UseAESIntrinsics</code></p>
<p>要禁用硬件 AES，请使用以下标志： <code>-XX:-UseAES -XX:-UseAESIntrinsics</code></p>
</li>
<li><p>删除了 PermGen。</p>
</li>
<li><p>方法调用的字节码指令支持 Java 编程语言中的默认方法。</p>
</li>
</ul>
</li>
<li><h4 id="Java-Mission-Control-5-3-版本说明"><a href="#Java-Mission-Control-5-3-版本说明" class="headerlink" title="Java Mission Control 5.3 版本说明"></a><a href="http://www.oracle.com/technetwork/java/javase/jmc53-release-notes-2157171.html">Java Mission Control 5.3 版本说明</a></h4><ul>
<li>JDK 8 包含 Java Mission Control 5.3。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb-Servlet</title>
    <url>/archives/3dd30874.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射</title>
    <url>/archives/adc18de0.html</url>
    <content><![CDATA[<h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><h2 id="反射定义"><a href="#反射定义" class="headerlink" title="反射定义"></a>反射定义</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>
<span id="more"></span>

<h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><ul>
<li>  运行时分析类</li>
<li>  运行时查看对象</li>
<li>  编写泛型数组代码</li>
<li>利用<code>Method</code>对象的<code>invoke</code>方法调用任意方法<ul>
<li>  <code>Method</code>对象是你想要的调用的方法的对象</li>
<li>  <code>invoke</code>方法调用包装在当前<code>Method</code>对象中的方法</li>
</ul>
</li>
</ul>
<h2 id="反射相关类"><a href="#反射相关类" class="headerlink" title="反射相关类"></a>反射相关类</h2><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a><code>Class</code>类</h3><ul>
<li><p>  <strong>所有反射 API 的入口点</strong></p>
</li>
<li><p>  保存类的所有信息</p>
</li>
<li><p>  没有 public 类型的构造器。</p>
</li>
<li><p>  每个类都有一个 Class 类型的对象，当类被加载时，由 Java 虚拟机调用类加载器的 defineClass 方法构造</p>
</li>
<li><p>  一个 Class 对象实际上表示的是一个类型，而这个类型不一定是类，比如 int 等基本类型不是类，但是 int.class 是一个 Class 类型的对象</p>
</li>
</ul>
<h4 id="获取-Class类对象的三种方法"><a href="#获取-Class类对象的三种方法" class="headerlink" title="获取 Class类对象的三种方法"></a>获取 Class类对象的三种方法</h4><p>1、 <code>对象名.getClass()</code></p>
<p>2、<code>Class.forName(className)</code>：调用 Class 类的 forName 静态方法</p>
<p>3、<code>T.class</code>：T 是任意的 Java 类型或 void 关键字</p>
<p>Class类常用方法</p>
<ul>
<li><p>  <code>getName()</code>：返回类的全限定名</p>
</li>
<li><p>静态方法 <code>forName(className)</code>：获取类名对应的 Class 对象</p>
<ul>
<li>  className 必须是类名或者接口名，而且必须是全限定名</li>
</ul>
</li>
<li><p>  <code>newInstance()</code>：创建一个类的实例，调用的是无参构造函数，如果没有无参构造，会抛异常</p>
</li>
<li><p>  <code>getFields</code>、<code>getMethods</code>、<code>getConstructors</code>：返回类的 publis 域，方法和构造器数组，包括父类的</p>
</li>
<li><p>  <code>getDeclareFields</code>、<code>getDeclareMethods</code>、<code>getDeclareConstructors</code>：返回类的全部域，方法和构造器数组，但是不包括父类的</p>
</li>
</ul>
<h3 id="Field、Method、Constructor类"><a href="#Field、Method、Constructor类" class="headerlink" title="Field、Method、Constructor类"></a><code>Field</code>、<code>Method</code>、<code>Constructor</code>类</h3><p>查看对象域的关键方法是 <code>Field</code>类的各种 get 方法</p>
<p>设置域的值是<code>Field</code>类各种 set 方法，最常用的是<code>set(obj, value)</code></p>
<p><strong>几个共有的方法：</strong></p>
<p><code>getName()</code> 方法：返回项目的名称</p>
<p><code>getModifier()</code>：返回一个整数值，代表不同的修饰符，结合<code>Modifier</code>类的静态方法<code>isPublic</code>等可以判断修饰符类型</p>
<p><code>setAccessible()</code>：只需在括号里给个 true，就可以为所以为，想拿到哪个属性就拿哪个 </p>
<h3 id="Modifier类"><a href="#Modifier类" class="headerlink" title="Modifier类"></a><code>Modifier</code>类</h3><p>有检测各种修饰符的方法，如<code>isPublic</code>等</p>
<h2 id="使用反射编写泛型数组代码（扩展任意类型的数组）"><a href="#使用反射编写泛型数组代码（扩展任意类型的数组）" class="headerlink" title="使用反射编写泛型数组代码（扩展任意类型的数组）"></a>使用反射编写泛型数组代码（扩展任意类型的数组）</h2><p>1、获取数组的类对象</p>
<p>2、确认它是个数组</p>
<p>3、确定数组类型和长度</p>
<p>4、复制数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodArrayCopyOf</span><span class="params">(Object a, <span class="keyword">int</span> newLength)</span></span>&#123;</span><br><span class="line">    Class cl = a.getClass();</span><br><span class="line">    <span class="keyword">if</span>(!cl.isArray())  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Class componentType = cl.getComponentType();</span><br><span class="line">    <span class="keyword">int</span> length = Array.getLength(a);</span><br><span class="line">    Object newArray = Array.newInstance(componentType, newLength);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>Java反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代理断言和日志</title>
    <url>/archives/51911571.html</url>
    <content><![CDATA[<h1 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h1><p>作用：运行时创建一个实现了一个给定接口的新类</p>
<span id="more"></span>

<h2 id="1、何时使用代理"><a href="#1、何时使用代理" class="headerlink" title="1、何时使用代理"></a>1、何时使用代理</h2><p>编译时无法确定需要实现哪个接口时</p>
<p>代理类可以在运行时创建全新的类，代理类能够实现指定的接口，并且具有下列方法：</p>
<ul>
<li>  指定接口所需要的全部方法。</li>
<li>  Object 类中的全部方法，例如，toString、equals等。</li>
</ul>
<p>然而，不能在运行时定义这些方法的新代码。而是要提供一个调用处理器（invocation handler）。调用处理器是实现了 InvocationHandler 接口的类对象。在这个接口中只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, </span></span></span><br><span class="line"><span class="params"><span class="function">                     	Method method, </span></span></span><br><span class="line"><span class="params"><span class="function">                     	Object[] args)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure>

<p>无论何时调用代理对象的方法，调用处理器的 invoke 方法都会被调用，并向其传递 Method 对象和原始的调用参数。调用处理器必须给出处理调用的方式。</p>
<h2 id="2、如何创建代理对象"><a href="#2、如何创建代理对象" class="headerlink" title="2、如何创建代理对象"></a>2、如何创建代理对象</h2><p>要想创建一个代理对象，需要使用 Proxy 类的 newProxyInstance 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,//类加载器，用<span class="keyword">null</span>表示使用默认的类加载器。</span></span></span><br><span class="line"><span class="params"><span class="function">                                          Class&lt;?&gt;[] interfaces,//Class对象数组，每个元素都是需要实现的接口</span></span></span><br><span class="line"><span class="params"><span class="function">                                          InvocationHandler h)</span><span class="comment">//调用处理器</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>



<h2 id="3、使用代理的原因："><a href="#3、使用代理的原因：" class="headerlink" title="3、使用代理的原因："></a>3、使用代理的原因：</h2><ol>
<li> 路由对远程服务器的方法调用。</li>
<li> 在程序运行期间，将用户接口事件与动作关联起来。</li>
<li> 为调试，跟踪方法调用。</li>
</ol>
<h2 id="4、代理类的特性"><a href="#4、代理类的特性" class="headerlink" title="4、代理类的特性"></a>4、代理类的特性</h2><p><strong>代理类是在程序运行过程中创建出来的，一旦被创建，就变成了常规类</strong></p>
<ul>
<li><p>  <strong>所有的代理类都扩展于 Proxy 类</strong>。</p>
</li>
<li><p>  一<strong>个代理类只有一个实例域——调用处理器</strong>，它定义在 Proxy 类中。为了履行代理对象的职责，所需要的任何附加数据都必须存储在调用处理器中。</p>
</li>
<li><p>  <strong>对于特定的类加载器和预设的一组接口来说，只能有一个代理类</strong>。也就是说，如果使用同一个类加载器和接口数组调用两次<code>newProxyInstance</code>方法的话，那么只能够得到同一个类的两个对象，也可以利用<code>getProxyClass</code>方法获得这个类</p>
</li>
<li><p><strong>代理类一定是 public 和 final</strong>。如果代理类实现的所有接口都是 public，代理类就不属于某个特定的包；否则，所有非公有的接口都必须属于同一个包，同时，代理类也属于这个包。<br>  可以通过调用Proxy类中的<code>isProxyClass</code>方法检测一个特定的Class对象是否代表一个代理类。</p>
</li>
<li><p>  所有的代理类都覆盖了Object类中的方法<code>toString</code>、<code>equals</code>和<code>hashCode</code>。如同所有的代理方法一样，这些方法仅仅调用了调用处理器的invoke。Object类中的其他方法（如<code>clone</code>和<code>getClass</code>）没有被重新定义。</p>
</li>
<li><p>  没有定义代理类的名字，Sun虚拟机中的Proxy类将生成一个以字符串$Proxy开头的类名。</p>
</li>
</ul>
<h1 id="断言（assert）"><a href="#断言（assert）" class="headerlink" title="断言（assert）"></a>断言（assert）</h1><h2 id="1、什么是断言？"><a href="#1、什么是断言？" class="headerlink" title="1、什么是断言？"></a>1、什么是断言？</h2><p>在测试期间向代码中插入一些检查语句。当代码发布时，这些插入的检测语句将会被<strong>自动移除</strong></p>
<h2 id="2、如何使用"><a href="#2、如何使用" class="headerlink" title="2、如何使用"></a>2、如何使用</h2><p>1）<code>assert 条件;</code></p>
<p>2）<code>assert 条件 : 表达式;</code>//表达式将被传入AssertionError的构造器，并转换成一个消息字符串</p>
<p>当条件不对时，抛出一个 AssertionError 异常</p>
<p>在默认情况下，断言被禁用。</p>
<ul>
<li>  可以在运行程序时用<code>-enableassertions</code>或<code>-ea</code>选项启用，可以在某个类或整个包中使用断言</li>
<li>  可以用选项<code>-disableassertions</code>或<code>-da</code>禁用某个特定类和包的断言</li>
</ul>
<p>在启用或禁用断言时不必重新编译程序。启用或禁用断言是类加载器（class loader）的功能。当断言被禁用时，类加载器将跳过断言代码，因此，不会降低程序运行的速度。</p>
<p>有些类不是由类加载器加载，而是直接由虚拟机加载。可以使用这些开关有选择地启用或禁用那些类中的断言。</p>
<p>启用和禁用所有断言的<code>-ea</code>和<code>-da</code>开关不能应用到那些没有类加载器的“系统类”上。对于这些系统类来说，需要使用<code>-enablesystemassertions</code> / <code>-esa</code>开关启用断言。</p>
<p><strong>3种处理系统错误的机制：</strong></p>
<ul>
<li>  抛异常</li>
<li>  日志</li>
<li>  使用断言</li>
</ul>
<p><strong>断言是一种测试和调试阶段所使用的战术性工具；而日志记录是一种在程序的整个生命周期都可以使用的策略性工具</strong></p>
<h2 id="3、什么时候应该选择使用断言呢"><a href="#3、什么时候应该选择使用断言呢" class="headerlink" title="3、什么时候应该选择使用断言呢?"></a>3、什么时候应该选择使用断言呢?</h2><ul>
<li>  断言失败是致命的、不可恢复的错误，不应该使用断言向程序的其他部分通告发生了可恢复性的错误</li>
<li>  断言检查只用于开发和测阶段，应该用于在测试阶段确定程序内部的错误位置</li>
</ul>
<p>由于可以使用断言，当方法被非法调用时，将会出现难以预料的结果</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="1、场景再现："><a href="#1、场景再现：" class="headerlink" title="1、场景再现："></a>1、场景再现：</h2><p>每个Java程序员都很熟悉在有问题的代码中插入一些<code>System.out.println</code>方法调用来帮助观察程序运行的操作过程。当然，一旦发现问题的根源，就要将这些语句从代码中删去。如果接下来又出现了问题，就需要再插入几个调用<code>System.out.println</code>方法的语句。</p>
<p><strong>记录日志API就是为了解决这个问题而设计的。</strong></p>
<p>记录日志的常见用途是记录那些不可预料的异常</p>
<p>日志记录并不将消息发送到控制台上，如果想在控制台显示，则需要设置配置文件（位于 jre/lib 目录下）</p>
<p>所有级别为<code>INFO、WARNING和SEVERE</code>的消息都将显示到控制台上。因此，最好只将对程序用户有意义的消息设置为这几个级别。<strong>将程序员想要的日志记录，设定为<code>FINE</code>是一个很好的选择。</strong></p>
<h2 id="2、记录日志-API-的优点"><a href="#2、记录日志-API-的优点" class="headerlink" title="2、记录日志 API 的优点"></a>2、记录日志 API 的优点</h2><ul>
<li>  可以很容易地取消全部日志记录，或者仅仅取消某个级别的日志，而且打开和关闭这个操作也很容易。</li>
<li>  可以很简单地禁止日志记录的输出，因此，将这些日志代码留在程序中的开销很小。</li>
<li>  日志记录可以被定向到不同的处理器，用于在控制台中显示，用于存储在文件中等。</li>
<li>  日志记录器和处理器都可以对记录进行过滤。过滤器可以根据过滤实现器制定的标准丢弃那些无用的记录项</li>
<li>  日志记录可以采用不同的方式格式化，例如，纯文本或XML。</li>
<li>  应用程序可以使用多个日志记录器，它们使用类似包名的这种具有层次结构的名字，例如，com.mycompany.myapp。</li>
<li>  在默认情况下，日志系统的配置由配置文件控制。如果需要的话，应用程序可以替换这个配置。</li>
</ul>
<h2 id="3、简单使用"><a href="#3、简单使用" class="headerlink" title="3、简单使用"></a>3、简单使用</h2><p>要生成简单的日志记录，可以使用全局日志记录器（global logger）并调用其info方法</p>
<p>不要将所有的日志都记录到一个全局日志记录器中，而是自定义日志记录器。可以调用getLogger方法创建或获取记录器，未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况发生，一个静态变量存储日志记录器的一个引用</p>
<h2 id="4、过滤器"><a href="#4、过滤器" class="headerlink" title="4、过滤器"></a>4、过滤器</h2><p>在默认情况下，过滤器根据日志记录的级别进行过滤。每个日志记录器和处理器都可以有一个可选的过滤器来完成附加的过滤。另外，可以通过实现Filter接口并定义<code>isLoggable</code>方法来自定义过滤器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLoggable</span><span class="params">(LogRecord record)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，可以利用自己喜欢的标准，对日志记录进行分析，返回true表示这些记录应该包含在日志中。</p>
<p>要想将一个过滤器安装到一个日志记录器或处理器中，只需要调用setFilter方法就可以了。注意，同一时刻最多只能有一个过滤器。</p>
<h2 id="5、格式化器"><a href="#5、格式化器" class="headerlink" title="5、格式化器"></a>5、格式化器</h2><p>ConsoleHandler类和FileHandler类可以生成文本和XML格式的日志记录。也可以自定义格式，只需要扩展Formatter类并覆盖下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">format</span><span class="params">(LogRecord record)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用setFormatter方法将格式化器安装到处理器中</p>
<h1 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h1><p>1、打印或记录任意变量的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">print一下;</span><br><span class="line">或者</span><br><span class="line">Logger.getGlobai().info(<span class="string">&quot;x=&quot;</span> + x);</span><br><span class="line">Logger.getGlobai().info(<span class="string">&quot;this=&quot;</span> + <span class="keyword">this</span>);<span class="comment">//查看隐式参数对象的状态</span></span><br></pre></td></tr></table></figure>

<p>2、在每一个类中放置一个单独的main方法，这样可以对每一个类进行单元测试。</p>
<p>3、使用JUnit</p>
<p>4、日志代理（logging proxy），截获方法调用，并进行日志记录，然后调用超类中的方法</p>
<p>5、利用Throwable类提供的printStackTrace方法</p>
<p>6、将一个程序中的错误信息保存在一个文件中</p>
<p>7、要想观察类的加载过程，可以用-verbose标志启动Java虚拟机</p>
<p>8、-Xlint选项告诉编译器对一些普遍容易出现的代码问题进行检查</p>
<p>9、jmap实用工具</p>
<p>参考文献：</p>
<blockquote>
<p>  《Java核心技术》</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>代理、断言和日志</category>
      </categories>
      <tags>
        <tag>Java代理、断言和日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua 编译</title>
    <url>/archives/41ff62c0.html</url>
    <content><![CDATA[<h1 id="一、环境以及安装包"><a href="#一、环境以及安装包" class="headerlink" title="一、环境以及安装包"></a>一、环境以及安装包</h1><h2 id="1-1-环境以及安装包"><a href="#1-1-环境以及安装包" class="headerlink" title="1.1 环境以及安装包"></a>1.1 环境以及安装包</h2><ul>
<li>gcc 编译环境（本人选择TDM-GCC9.2.0，<a href="https://jmeubank.github.io/tdm-gcc/">下载链接</a>）</li>
<li>Lua 源代码（本人选择 <a href="http://www.lua.org/ftp/">lua-5.3.6</a>）</li>
</ul>
<span id="more"></span>

<h2 id="1-2-安装前的准备工作"><a href="#1-2-安装前的准备工作" class="headerlink" title="1.2 安装前的准备工作"></a>1.2 安装前的准备工作</h2><ul>
<li>将 TDM-GCC 的 bin 目录添加到环境变量</li>
<li>进入 TDM-GCC 的 bin 目录，将 <code>把 mingw32-make.exe</code> 复制一份并修改为改为 <code>make.exe</code>，如下图：<br><img src="../images/20210219211832365.png" alt="在这里插入图片描述"></li>
<li>验证 GCC 环境，输出如下<br><img src="../images/20210219212048248.png" alt="在这里插入图片描述"></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=C:/TDM-GCC-64/bin/../libexec/gcc/x86_64-w64-mingw32/9.2.0/lto-wrapper.exe</span><br><span class="line">Target: x86_64-w64-mingw32</span><br><span class="line">Configured with: ../../../src/gcc-git-9.2.0/configure --build=x86_64-w64-mingw32 --enable-targets=all --enable-languages=ada,c,c++,fortran,lto,objc,obj-c++ --enable-libgomp --enable-lto --enable-graphite --enable-cxx-flags=-DWINPTHREAD_STATIC --disable-build-with-cxx --disable-build-poststage1-with-cxx --enable-libstdcxx-debug --enable-threads=posix --enable-version-specific-runtime-libs --enable-fully-dynamic-string --enable-libstdcxx-threads --enable-libstdcxx-time --with-gnu-ld --disable-werror --disable-nls --disable-win32-registry --enable-large-address-aware --disable-rpath --disable-symvers --prefix=/mingw64tdm --with-local-prefix=/mingw64tdm --with-pkgversion=tdm64-1 --with-bugurl=http://tdm-gcc.tdragon.net/bugs</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 9.2.0 (tdm64-1)</span><br><span class="line"></span><br><span class="line">&gt;g++ -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=g++</span><br><span class="line">COLLECT_LTO_WRAPPER=C:/TDM-GCC-64/bin/../libexec/gcc/x86_64-w64-mingw32/9.2.0/lto-wrapper.exe</span><br><span class="line">Target: x86_64-w64-mingw32</span><br><span class="line">Configured with: ../../../src/gcc-git-9.2.0/configure --build=x86_64-w64-mingw32 --enable-targets=all --enable-languages=ada,c,c++,fortran,lto,objc,obj-c++ --enable-libgomp --enable-lto --enable-graphite --enable-cxx-flags=-DWINPTHREAD_STATIC --disable-build-with-cxx --disable-build-poststage1-with-cxx --enable-libstdcxx-debug --enable-threads=posix --enable-version-specific-runtime-libs --enable-fully-dynamic-string --enable-libstdcxx-threads --enable-libstdcxx-time --with-gnu-ld --disable-werror --disable-nls --disable-win32-registry --enable-large-address-aware --disable-rpath --disable-symvers --prefix=/mingw64tdm --with-local-prefix=/mingw64tdm --with-pkgversion=tdm64-1 --with-bugurl=http://tdm-gcc.tdragon.net/bugs</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 9.2.0 (tdm64-1)</span><br><span class="line"></span><br><span class="line">&gt;make -v</span><br><span class="line">GNU Make 3.82.90</span><br><span class="line">Built <span class="keyword">for</span> i686-pc-mingw32</span><br><span class="line">Copyright (C) 1988-2012 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br></pre></td></tr></table></figure>

<h1 id="二、编译"><a href="#二、编译" class="headerlink" title="二、编译"></a>二、编译</h1><ul>
<li><p>将下载的源代码解压</p>
</li>
<li><p>进入源代码根目录，也就是 <code>lua-5.3.6</code> 目录下</p>
</li>
<li><p>按住 <code>shift</code> 键的同时点击鼠标右键，选择 <code>在此处打开 PowerShell 窗口</code></p>
</li>
<li><p>输入 <code>make mingw</code><br><img src="../images/2021021921314179.png" alt="在这里插入图片描述"><br><img src="../images/20210219213212429.png" alt="在这里插入图片描述"></p>
</li>
<li><p>编译完成，生成的目标文件共有三个 <code>lua.exe</code>，<code>luac.exe</code>，<code>lua53.dll</code>，在 <code>src</code> 目录下<br><img src="../images/20210219213307215.png" alt="在这里插入图片描述"></p>
</li>
<li><p>可以直接将 <code>src</code> 添加到环境变量，或者将上述三个文件保存在某个目录，然后将这个目录添加到环境变量</p>
</li>
<li><p>验证，在命令行窗口输入 <code>lua</code>，或者输入 <code>lua -v</code><br><img src="../images/20210219213357495.png" alt="在这里插入图片描述"><br><img src="../images/20210219213454730.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h1><p>我们通过有关的环境变量配置即可自己手动编译一个自己的 Lua 环境，但是这里也有一个注意点，本人在 <code>TDM-GCC</code> 以及 <code>Mingw</code> 的 GCC 编译环境下编译出来的不需要再依赖其他的库，但是在 <code>cygwin64</code> 平台下编译的 Lua 解释器还需要依赖 <code>cygwin64</code> 的有关库（也就是说编译好的文件不能共享给其他人使用）</p>
<h1 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h1><ul>
<li>[1] Lua 官方文档</li>
<li>[2] <a href="https://github.com/joedf/LuaBuilds">https://github.com/joedf/LuaBuilds</a> </li>
</ul>
]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucene学习笔记</title>
    <url>/archives/132e2ea8.html</url>
    <content><![CDATA[<h2 id="什么是Lucene？"><a href="#什么是Lucene？" class="headerlink" title="什么是Lucene？"></a>什么是Lucene？</h2><p>是全文检索引擎工具，是一个工具包，让程序员可以自己构建搜索引擎或者是在自己的程序中加上全文搜索功能。</p>
<span id="more"></span>

<p><img src="../images/image-20201229233840353.png" alt="image-20201229233840353"></p>
<h2 id="什么是全文检索？"><a href="#什么是全文检索？" class="headerlink" title="什么是全文检索？"></a>什么是全文检索？</h2><p>扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式</p>
<h2 id="1、索引"><a href="#1、索引" class="headerlink" title="1、索引"></a>1、索引</h2><h3 id="1-1-倒排索引"><a href="#1-1-倒排索引" class="headerlink" title="1.1 倒排索引"></a>1.1 倒排索引</h3><p><strong>倒排索引，顾名思义，它相反于一篇文章包含了哪些词，它从词出发，记载了这个词在哪些文档中出现过，由两部分组成——词典和倒排表。</strong></p>
<ul>
<li>倒排表（很像使用拉链法的hash表）<ul>
<li>表头是单词(term)，后面是文档编号，出现的位置，出现的次数</li>
<li>存储的时候可以对编号进行压缩（第一个不用修改，第二个改为第二个减第一个的值，依次类推）</li>
</ul>
</li>
<li>构建索引的时候较为耗时且维护成本较高，但是搜索耗时短</li>
</ul>
<p><img src="../images/image-20201229232706950.png" alt="image-20201229232706950"></p>
<h3 id="1-2-正排索引"><a href="#1-2-正排索引" class="headerlink" title="1.2 正排索引"></a>1.2 正排索引</h3><p>基本结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“文档1”的ID &gt; 单词1：出现次数，出现位置列表；单词2：出现次数，出现位置列表；…………。</span><br><span class="line">“文档2”的ID &gt; 此文档出现的关键词列表。</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20201229232633286.png" alt="image-20201229232633286"></p>
<h3 id="1-3-分块索引"><a href="#1-3-分块索引" class="headerlink" title="1.3 分块索引"></a>1.3 分块索引</h3><ul>
<li>块内无序，块间有序（后面一块关键字的最小值大于前面一块的最大值）</li>
</ul>
<h2 id="2、底层数据结构"><a href="#2、底层数据结构" class="headerlink" title="2、底层数据结构"></a>2、底层数据结构</h2><p>Lucene3.0之前使用的也是跳跃表结构（结构简单、跳跃间隔、级数可控，模糊查询不好），后换成了FST（Finite State Transducer，有限状态转移机）。</p>
<p>FST有两个优点：</p>
<ul>
<li>空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；</li>
<li>查询速度快。</li>
</ul>
<p><img src="../images/image-20201229234128205.png" alt="image-20201229234128205"></p>
<h2 id="3、为什么Elasticsearch-Lucene检索可以比mysql快？"><a href="#3、为什么Elasticsearch-Lucene检索可以比mysql快？" class="headerlink" title="3、为什么Elasticsearch/Lucene检索可以比mysql快？"></a>3、为什么Elasticsearch/Lucene检索可以比mysql快？</h2><p>Mysql只有term dictionary这一层，是以b-tree排序的方式存储在磁盘上的。检索一个term需要若干次的random access的磁盘操作。</p>
<p>而Lucene在term dictionary的基础上添加了term index来加速检索，term index以树的形式缓存在内存中。从term index查到对应的term dictionary的block位置之后，再去磁盘上找term，大大减少了磁盘的random access次数。</p>
<h2 id="4、那么什么是term-dictionary-和-term-index？"><a href="#4、那么什么是term-dictionary-和-term-index？" class="headerlink" title="4、那么什么是term dictionary 和 term index？"></a>4、那么什么是term dictionary 和 term index？</h2><p>假设我们有很多个term，比如：</p>
<p>Carla,Sara,Elin,Ada,Patty,Kate,Selena</p>
<p>如果按照这样的顺序排列，找出某个特定的term一定很慢，因为term没有排序，需要全部过滤一遍才能找出特定的term。排序之后就变成了：</p>
<p>Ada,Carla,Elin,Kate,Patty,Sara,Selena</p>
<p>这样我们可以用二分查找的方式，比全遍历更快地找出目标的term。这个就是 term dictionary。有了term dictionary之后，可以用 logN 次磁盘查找得到目标。但是磁盘的随机读操作仍然是非常昂贵的（一次random access大概需要10ms的时间）。所以尽量少的读磁盘，有必要把一些数据缓存到内存里。但是整个term dictionary本身又太大了，无法完整地放到内存里。于是就有了term index。term index有点像一本字典的大的章节表。比如：</p>
<p>A开头的term ……………. Xxx页</p>
<p>C开头的term ……………. Xxx页</p>
<p>E开头的term ……………. Xxx页</p>
<h2 id="5、为什么大数据量搜索快？"><a href="#5、为什么大数据量搜索快？" class="headerlink" title="5、为什么大数据量搜索快？"></a>5、为什么大数据量搜索快？</h2><ul>
<li>使用了索引</li>
<li>索引结构（倒排索引）比较优秀</li>
</ul>
<h2 id="6、优化"><a href="#6、优化" class="headerlink" title="6、优化"></a>6、优化</h2><h3 id="6-1-解决大量磁盘IO"><a href="#6-1-解决大量磁盘IO" class="headerlink" title="6.1. 解决大量磁盘IO"></a>6.1. 解决大量磁盘IO</h3><ul>
<li><p>config.setMaxBufferedDocs(100000); 控制写入一个新的segment前内存中保存的document的数目，设置较大的数目可以加快建索引速度。</p>
<p><strong>数值越大索引速度越快, 但是会消耗更多的内存</strong></p>
</li>
<li><p>indexWriter.forceMerge(文档数量); 设置N个文档合并为一个段<br><strong>数值越大索引速度越快, 搜索速度越慢; 值越小索引速度越慢, 搜索速度越快</strong><br>更高的值意味着索引期间更低的段合并开销，但同时也意味着更慢的搜索速度，因为此时的索引通常会包含更多的段。如果该值设置的过高，能获得更高的索引性能。但若在最后进行索引优化，那么较低的值会带来更快的搜索速度，因为在索引操作期间程序会利用并发机制完成段合并操作。故建议对程序分别进行高低多种值的测试，利用计算机的实际性能来告诉你最优值。</p>
</li>
</ul>
<h3 id="6-2-选择合适的分词器"><a href="#6-2-选择合适的分词器" class="headerlink" title="6.2. 选择合适的分词器"></a>6.2. 选择合适的分词器</h3><p>不同的分词器分词效果不同, 所用时间也不同</p>
<p>虽然StandardAnalyzer切分词速度快过IKAnalyzer, 但是由于StandardAnalyzer对中文支持不好, 所以为了追求好的分词效果, 为了追求查询时的准确率, 也只能用IKAnalyzer分词器, IKAnalyzer支持停用词典和扩展词典, 可以通过调整两个词典中的内容, 来提升查询匹配的精度</p>
<h3 id="6-3-选择合适的位置存放索引库"><a href="#6-3-选择合适的位置存放索引库" class="headerlink" title="6.3.选择合适的位置存放索引库"></a>6.3.选择合适的位置存放索引库</h3><table>
<thead>
<tr>
<th>类</th>
<th>写操作</th>
<th>读操作</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>SimpleFSDirectory</td>
<td>java.io.RandomAccessFile</td>
<td>java.io.RandomAccessFile</td>
<td>简单实现，并发能力差</td>
</tr>
<tr>
<td>NIOFSDirectory</td>
<td>java.nio.FileChannel</td>
<td>FSDirectory.FSIndexOutput</td>
<td>并发能力强,windows平台下有重大bug</td>
</tr>
<tr>
<td>MMapDirectory</td>
<td>内存映射</td>
<td>FSDirectory.FSIndexOutput</td>
<td>读取操作基于内存</td>
</tr>
</tbody></table>
<h2 id="7、人为影响相关度"><a href="#7、人为影响相关度" class="headerlink" title="7、人为影响相关度"></a>7、人为影响相关度</h2><p>Lucene对查询关键字和索引文档的相关度进行打分，得分高的就排在前边。</p>
<p>Lucene是在用户进行检索时实时根据搜索的关键字计算出来的，分两步：</p>
<ul>
<li><p>计算出词（Term）的权重</p>
</li>
<li><p>根据词的权重值，计算文档相关度得分。</p>
</li>
</ul>
<p>明确索引的最小单位是一个Term(索引词典中的一个词)，搜索也是要从Term中搜索，再根据Term找到文档，Term对文档的重要性称为权重，影响Term权重有两个因素：</p>
<ul>
<li>Term Frequency (tf)： 指此Term在此文档中出现了多少次。tf 越大说明越重要。 词(Term)在文档中出现的次数越多，说明此词(Term)对该文档越重要，如“Lucene”这个词，在文档中出现的次数很多，说明该文档主要就是讲Lucene技术的。</li>
<li>Document Frequency (df)： 指有多少文档包含次Term。df 越大说明越不重要。 比如，在一篇英语文档中，this出现的次数更多，就说明越重要吗？不是的，有越多的文档包含此词(Term), 说明此词(Term)太普通，不足以区分这些文档，因而重要性越低。</li>
</ul>
<p><strong>boost</strong>是一个加权值（默认加权值为1.0f），它可以影响权重的计算。</p>
<ul>
<li>在索引时对某个文档中的field设置加权值高，在搜索时匹配到这个文档就可能排在前边。</li>
<li>在搜索时对某个域进行加权，在进行组合域查询时，匹配到加权值高的域最后计算的相关度得分就高。</li>
</ul>
<p>设置boost是给域（field）或者Document设置的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Lucene</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL on和where的区别</title>
    <url>/archives/13ea1464.html</url>
    <content><![CDATA[<p>在多表查询时，ON和where都表示筛选条件，on先执行，where后执行。<br>区别：<br>外连接时，on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。而where条件是在临时表生成好后，再对临时表进行过滤的条件。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/archives/7273cdc.html</url>
    <content><![CDATA[<h1 id="Maven学习笔记"><a href="#Maven学习笔记" class="headerlink" title="Maven学习笔记"></a>Maven学习笔记</h1><h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p>服务于Java平台的自动化构建工具</p>
<span id="more"></span>

<h2 id="何为构建？"><a href="#何为构建？" class="headerlink" title="何为构建？"></a>何为构建？</h2><ul>
<li>编译</li>
<li>部署</li>
<li>搭建</li>
</ul>
<p>BS项目最终运行的是动态 Web 工程编译的结果，不是这个工程本身</p>
<p>构建过程的各个环节：</p>
<ol>
<li>清理：清理旧的字节码文件</li>
<li>编译：编译成字节码文件</li>
<li>测试：自动测试</li>
<li>报告：测试程序执行的结果</li>
<li>打包</li>
<li>安装：Maven的特定概念——将打包得到的文件复制到仓库中的指定位置</li>
<li>部署：部署工程到服务器</li>
</ol>
<h2 id="如何安装？"><a href="#如何安装？" class="headerlink" title="如何安装？"></a>如何安装？</h2><p>1、检测<code>JAVA_HOME</code>环境变量</p>
<p><img src="../images/image-20210604190837057.png" alt="image-20210604190837057"></p>
<p>2、解压Maven压缩包</p>
<ul>
<li>路径需要非中文、无空格</li>
</ul>
<p>3、配置Maven环境变量</p>
<ul>
<li>MAVNE_HOME或者M2_HOME</li>
</ul>
<p>4、查看</p>
<p><img src="../images/image-20210604191237178.png" alt="image-20210604191237178"></p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><ol>
<li>约定的目录结构</li>
<li>POM</li>
<li>坐标</li>
<li>依赖（最重要）</li>
<li>仓库</li>
<li>生命周期/插件/目标</li>
<li>继承</li>
<li>聚合</li>
</ol>
<h2 id="1、目录结构"><a href="#1、目录结构" class="headerlink" title="1、目录结构"></a>1、目录结构</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">|---src</span><br><span class="line">|	|---main 存放主程序</span><br><span class="line">|	|	|---java 存放Java源文件</span><br><span class="line">|	|	|---resources 存放框架或者其他工具的配置文件</span><br><span class="line">|	|---test 存放测试程序</span><br><span class="line">|   	|---java</span><br><span class="line">|		|---resources</span><br><span class="line">|---pom.xml 核心配置文件</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210604191940635.png" alt="image-20210604191940635"></p>
<p><strong>为什么要约定目录结构？</strong></p>
<p>约定大于配置</p>
<p>配置大于编码</p>
<blockquote>
<p>静态导入声明从类中导入静态成员，并允许它们在没有类引用的情况下使用。</p>
</blockquote>
<h2 id="2、常用命令"><a href="#2、常用命令" class="headerlink" title="2、常用命令"></a>2、常用命令</h2><p>必须进入 <code>pom.xml</code> 的所在目录执行命令</p>
<ul>
<li><p>mvn clean</p>
</li>
<li><p>mvn compile</p>
</li>
<li><p>mvn test-compile</p>
</li>
<li><p>mvn test</p>
</li>
<li><p>mvn package</p>
</li>
<li><p>mvn install：安装编译好的工程到Maven仓库</p>
</li>
<li><p>mvn site：生成站点</p>
</li>
</ul>
<p>编译结果在 <code>target</code> 目录</p>
<h2 id="3、POM"><a href="#3、POM" class="headerlink" title="3、POM"></a>3、POM</h2><p>Project Object Model：项目对象模型</p>
<blockquote>
<p>核心配置文件</p>
</blockquote>
<h2 id="4、坐标"><a href="#4、坐标" class="headerlink" title="4、坐标"></a>4、坐标</h2><p>可以使用三个坐标在仓库中唯一定位一个项目</p>
<ol>
<li>groupid：公司或组织域名倒叙+项目名</li>
<li>artifactid：模块名</li>
<li>version：版本</li>
</ol>
<h2 id="5、仓库"><a href="#5、仓库" class="headerlink" title="5、仓库"></a>5、仓库</h2><p><strong>分类：</strong></p>
<p>本地仓库</p>
<p>远程仓库</p>
<ul>
<li>私服：搭建在局域网里的，为局域网范围内的所有Maven工程服务</li>
<li>中央仓库</li>
<li>中央仓库的镜像</li>
</ul>
<p><strong>仓库的内容：</strong></p>
<ol>
<li>Maven自身需要的插件</li>
<li>第三方框架或者工具的jar包</li>
<li>我们自己开发的Maven工程（mvn install）</li>
</ol>
<blockquote>
<p>第一方：JDK</p>
<p>第二方：我们自己</p>
</blockquote>
<h2 id="6、依赖"><a href="#6、依赖" class="headerlink" title="6、依赖"></a>6、依赖</h2><p>Maven解析依赖的时候会到本地仓库找那些项目依赖的包</p>
<h3 id="依赖的范围："><a href="#依赖的范围：" class="headerlink" title="依赖的范围："></a><strong>依赖的范围</strong>：</h3><ul>
<li>compile：对主程序、测试程序都有效，参与打包</li>
<li>test：只对测试环境有效，不参与打包</li>
<li>provided：对主程序、测试程序都有效，不参与打包</li>
</ul>
<p><img src="../images/image-20210604200023747.png" alt="image-20210604200023747"></p>
<h3 id="依赖的传递性："><a href="#依赖的传递性：" class="headerlink" title="依赖的传递性："></a><strong>依赖的传递性：</strong></h3><p>直接依赖的依赖也会被传到本项目（也不一定都能进来，test 和 provided 不能进来）</p>
<p>好处：不需要在每个模块都声明依赖，可以从别的导入</p>
<h3 id="依赖的排除："><a href="#依赖的排除：" class="headerlink" title="依赖的排除："></a><strong>依赖的排除：</strong></h3><p>不想要的可以排除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="依赖的原则："><a href="#依赖的原则：" class="headerlink" title="依赖的原则："></a><strong>依赖的原则：</strong></h3><p>作用：解决模块工程之间依赖冲突问题</p>
<p><img src="../images/image-20210604211303681.png" alt="image-20210604211303681"></p>
<p>路径最短优先（选1.2.14）</p>
<p><img src="../images/image-20210604211457031.png" alt="image-20210604211457031"></p>
<p>如果路径相同（先声明的优先）</p>
<h3 id="统一管理依赖的版本："><a href="#统一管理依赖的版本：" class="headerlink" title="统一管理依赖的版本："></a><strong>统一管理依赖的版本：</strong></h3><p>手动一个个改太麻烦</p>
<p>建议方式：</p>
<ul>
<li>使用 <code>properties</code> 标签，标签内使用自定义标签统一声明版本号</li>
<li>在需要依赖版本的地方，使用 <code>$&#123;自定义标签名&#125;</code> 对版本号进行引用</li>
</ul>
<blockquote>
<p><code>properties</code> 标签，只要需要统一声明的场合，都可以自定义</p>
</blockquote>
<h3 id="依赖的继承"><a href="#依赖的继承" class="headerlink" title="依赖的继承"></a>依赖的继承</h3><p>在父工程中声明依赖，子工程就会继承父工程的依赖</p>
<p>1、创建一个Maven工程，打包的方式为 pom</p>
<p>2、在子工程中声明对父工程的引用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--父工程 坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>...<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>从当前目录到父项目的 pom.xml 文件的相对路径<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、在子工程中删除重复内容</p>
<p>4、只需在父工程中声明依赖版本</p>
<p>将父项目中的 dependencies 标签，用 dependencyManagement 标签括起来</p>
<blockquote>
<p>其实用IDEA，添加子模块也行</p>
</blockquote>
<h3 id="依赖的聚合"><a href="#依赖的聚合" class="headerlink" title="依赖的聚合"></a>依赖的聚合</h3><p>作用：一键安装各个模块工程</p>
<p>配置：把某个工程作为聚合工程，在总的聚合工程中 使用 modules /module 标签组合，指定模块工程的相对路径即可</p>
<p><img src="../images/image-20210606130230024.png" alt="image-20210606130230024"></p>
<p>使用：在聚合工程上使用 <code>mvn install</code></p>
<h2 id="7、生命周期"><a href="#7、生命周期" class="headerlink" title="7、生命周期"></a>7、生命周期</h2><ol>
<li>构建环节的顺序不能打乱</li>
<li>每一个生命周期都会从最初的阶段执行</li>
</ol>
<p><img src="../images/image-20210604200930229.png" alt="image-20210604200930229"></p>
<h1 id="Web工程的自动部署"><a href="#Web工程的自动部署" class="headerlink" title="Web工程的自动部署"></a>Web工程的自动部署</h1><p>使用 <code>build</code> 标签，里面进行配置，可以使用 cargo</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote>
<p>[1]<a href="https://www.bilibili.com/video/BV1TW411g7hP">https://www.bilibili.com/video/BV1TW411g7hP</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx学习笔记(狂神版)</title>
    <url>/archives/5d9e5ec8.html</url>
    <content><![CDATA[<h1 id="Nginx是什么？"><a href="#Nginx是什么？" class="headerlink" title="Nginx是什么？"></a>Nginx是什么？</h1><p>Nginx (engine x) 是一个轻量级的、高性能的HTTP和反向代理web服务器，第一个公开版本0.1.0发布于2004年10月4日。</p>
<p>因它的稳定性、丰富的功能集、简单的配置文件和低系统资源的消耗而闻名。</p>
<p>其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>
<p>对于新建站点，建议使用最新稳定版作为生产版本</p>
<p>Nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务，也可以支持作为 HTTP代理服务对外进行服务。Nginx采用C进行编写</p>
<p>能够不间断服务的情况下进行软件版本的升级</p>
<blockquote>
<p>以上来自百度百科</p>
</blockquote>
<span id="more"></span>

<p>没有什么是加一层是解决不了的</p>
<h1 id="Nginx作用"><a href="#Nginx作用" class="headerlink" title="Nginx作用"></a>Nginx作用</h1><blockquote>
<p>Http代理，反向代理，负载均衡（轮训和加权轮训）</p>
</blockquote>
<p>正向代理：代理客户端</p>
<p>反向代理：代理服务器</p>
<p>iphash 对客户端请求的 ip 进行 hash 操作，然后根据 hash 结果将同一个客户端的 ip 请求发给同一台服务器进行处理</p>
<p>动静分离：样式那些静态文件可以单独提出来，将其做缓存操作，提高资源的响应速度</p>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="Windows下安装"><a href="#Windows下安装" class="headerlink" title="Windows下安装"></a>Windows下安装</h2><p>1、下载解压</p>
<p><img src="../images/image-20210704143948957.png" alt="image-20210704143948957"></p>
<p>2、直接运行</p>
<p><img src="../images/image-20210704144201667.png" alt="image-20210704144201667"></p>
<p>3、浏览器直接输：127.0.0.1:80（或者你改的其他端口）</p>
<p><img src="../images/image-20210704144243668.png" alt="image-20210704144243668"></p>
<h2 id="Linux-下安装"><a href="#Linux-下安装" class="headerlink" title="Linux 下安装"></a>Linux 下安装</h2><p>1、下载解压</p>
<p><img src="../images/image-20210704144703838.png" alt="image-20210704144703838"></p>
<p>2、手动编译安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210704150317847.png" alt="image-20210704150317847"></p>
<p><img src="../images/image-20210704150432259.png" alt="image-20210704150432259"></p>
<p><img src="../images/image-20210704150450068.png" alt="image-20210704150450068"></p>
<p>提示缺少 库</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">./configure: error: the HTTP rewrite module requires the PCRE library.</span><br><span class="line">You can either disable the module by using --without-http<span class="built_in">_</span>rewrite<span class="built_in">_</span>module</span><br><span class="line">option, or install the PCRE library into the system, or build the PCRE library</span><br><span class="line">statically from the source with nginx by using --with-pcre=&lt;path&gt; option.</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libpcre3 libpcre3-dev -y</span><br></pre></td></tr></table></figure>

<p>其他错误</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">./configure: error: the HTTP gzip module requires the zlib library.</span><br><span class="line">You can either disable the module by using --without-http<span class="built_in">_</span>gzip<span class="built_in">_</span>module</span><br><span class="line">option, or install the zlib library into the system, or build the zlib library</span><br><span class="line">statically from the source with nginx by using --with-zlib=&lt;path&gt; option.</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ruby</span><br><span class="line">sudo apt-get install zlib1g</span><br><span class="line">sudo apt-get install zlib1g-dev</span><br></pre></td></tr></table></figure>



<p>3、查看是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210704150602335.png" alt="image-20210704150602335"></p>
<p>4、进入 <code>bin</code> 目录启动</p>
<p><img src="../images/image-20210704150751028.png" alt="image-20210704150751028"></p>
<p>这里说明 80 端口被占用</p>
<p>看了一下确实被占用了</p>
<p><img src="../images/image-20210704150928920.png" alt="image-20210704150928920"></p>
<p>解决方法：</p>
<p>修改端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8499;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>再次执行</p>
<p><img src="../images/image-20210704151625656.png" alt="image-20210704151625656"></p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/sbin</span><br><span class="line"></span><br><span class="line">./nginx <span class="comment"># 启动</span></span><br><span class="line">./nginx -s stop <span class="comment"># 停止</span></span><br><span class="line">./nginx -s reload <span class="comment"># 自动重新加载新的配置文件</span></span><br><span class="line">./nginx -s quit <span class="comment"># 安全退出</span></span><br></pre></td></tr></table></figure>

<h1 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h1><p>以 <code>dropwizard</code> 项目为例</p>
<h2 id="1、开启两个服务"><a href="#1、开启两个服务" class="headerlink" title="1、开启两个服务"></a>1、开启两个服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar Nginx-Dropwizard-1.0-SNAPSHOT.jar serve hello.yml</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210704163124416.png" alt="image-20210704163124416"></p>
<p>修改配置文件的端口号之后开启第二个服务</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  applicationConnectors:</span><br><span class="line">    - type: http</span><br><span class="line">      port: 8500 # 在同一台服务器开启多个服务需要修改端口号</span><br><span class="line">  adminConnectors:</span><br><span class="line">  - type: http</span><br><span class="line">    port: 8082 # 在同一台服务器开启多个服务需要修改端口号</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210704163217518.png" alt="image-20210704163217518"></p>
<p>测试：</p>
<p><img src="../images/image-20210704163333785.png" alt="image-20210704163333785"></p>
<p><img src="../images/image-20210704163343135.png" alt="image-20210704163343135"></p>
<h2 id="2、使用-Nginx"><a href="#2、使用-Nginx" class="headerlink" title="2、使用 Nginx"></a>2、使用 Nginx</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span> 增加下面两行</span><br><span class="line">upstream 127.0.0.1 &#123;</span><br><span class="line">    server 127.0.0.1:8499 weight=1;<span class="params">#</span> 配置权重</span><br><span class="line">    server 127.0.0.1:8500 weight=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server<span class="built_in">_</span>name  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="params">#</span>charset koi8-r;</span><br><span class="line"></span><br><span class="line">    <span class="params">#</span>access<span class="built_in">_</span>log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">    proxy<span class="built_in">_</span>pass   http://127.0.0.1; <span class="params">#</span> 添加这一行</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>出现的问题：</p>
<p>1、无法重新加载配置文件</p>
<p>解决方法：找到对应的进程，杀掉重开服务</p>
<p>2、upstream 位置写错了</p>
<h2 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h2><p><img src="../images/image-20210704170303963.png" alt="image-20210704170303963"></p>
<h1 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">########### 每个指令必须有分号结束。#################</span></span><br><span class="line"><span class="comment">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span></span><br><span class="line"><span class="comment">#worker_processes 2;  #允许生成的进程数，默认为1</span></span><br><span class="line"><span class="comment">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span></span><br><span class="line">error_log <span class="built_in">log</span>/error.log debug;  <span class="comment">#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span></span><br><span class="line">events &#123;</span><br><span class="line">    accept_mutex on;   <span class="comment">#设置网路连接序列化，防止惊群现象发生，默认为on</span></span><br><span class="line">    multi_accept on;  <span class="comment">#设置一个进程是否同时接受多个网络连接，默认为off</span></span><br><span class="line">    <span class="comment">#use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span></span><br><span class="line">    worker_connections  1024;    <span class="comment">#最大连接数，默认为512</span></span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;   <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    default_type  application/octet-stream; <span class="comment">#默认文件类型，默认为text/plain</span></span><br><span class="line">    <span class="comment">#access_log off; #取消服务日志    </span></span><br><span class="line">    log_format myFormat <span class="string">&#x27;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#x27;</span>; <span class="comment">#自定义格式</span></span><br><span class="line">    access_log <span class="built_in">log</span>/access.log myFormat;  <span class="comment">#combined为日志格式的默认值</span></span><br><span class="line">    sendfile on;   <span class="comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span></span><br><span class="line">    sendfile_max_chunk 100k;  <span class="comment">#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span></span><br><span class="line">    keepalive_timeout 65;  <span class="comment">#连接超时时间，默认为75s，可以在http，server，location块。</span></span><br><span class="line"></span><br><span class="line">    upstream mysvr &#123;   </span><br><span class="line">      server 127.0.0.1:7878;</span><br><span class="line">      server 192.168.10.121:3333 backup;  <span class="comment">#热备</span></span><br><span class="line">    &#125;</span><br><span class="line">    error_page 404 https://www.baidu.com; <span class="comment">#错误页</span></span><br><span class="line">    server &#123;</span><br><span class="line">        keepalive_requests 120; <span class="comment">#单连接请求上限次数。</span></span><br><span class="line">        listen       4545;   <span class="comment">#监听端口</span></span><br><span class="line">        server_name  127.0.0.1;   <span class="comment">#监听地址       </span></span><br><span class="line">        location  ~*^.+$ &#123;       <span class="comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span></span><br><span class="line">           <span class="comment">#root path;  #根目录</span></span><br><span class="line">           <span class="comment">#index vv.txt;  #设置默认页</span></span><br><span class="line">           proxy_pass  http://mysvr;  <span class="comment">#请求转向mysvr 定义的服务器列表</span></span><br><span class="line">           deny 127.0.0.1;  <span class="comment">#拒绝的ip</span></span><br><span class="line">           allow 172.18.5.54; <span class="comment">#允许的ip           </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote>
<ol>
<li>百度百科</li>
<li><a href="https://www.bilibili.com/video/BV1F5411J7vK">https://www.bilibili.com/video/BV1F5411J7vK</a></li>
<li><a href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">https://www.runoob.com/w3cnote/nginx-setup-intro.html</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx学习笔记(尚硅谷版)</title>
    <url>/archives/14f945e.html</url>
    <content><![CDATA[<h1 id="1、-nginx-简介"><a href="#1、-nginx-简介" class="headerlink" title="1、 nginx 简介"></a>1、 nginx 简介</h1><h2 id="（1）什么是-nginx"><a href="#（1）什么是-nginx" class="headerlink" title="（1）什么是 nginx"></a>（1）什么是 nginx</h2><p>Nginx (engine x) 是一个轻量级的、高性能的HTTP和反向代理web服务器</p>
<p>专为性能优化而开发，性能是其最重要的考量，实现上非常注重效率 ，能经受高负载的考验 有报告表明能支持高达 50,000 个并发连接数。</p>
<span id="more"></span>

<h2 id="（2）可以做什么"><a href="#（2）可以做什么" class="headerlink" title="（2）可以做什么"></a>（2）可以做什么</h2><p>反向代理、负载均衡、动静分离</p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>Nginx不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。</p>
<p>正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet ，则需要通过代理服务器来访问，这种代理服务就称为正向代理。</p>
<p><img src="../images/image-20210705093339524.png" alt="image-20210705093339524"></p>
<p>反向代理，将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端。此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。</p>
<p>客户端不需要任何配置</p>
<p><img src="../images/image-20210705093835089.png" alt="image-20210705093835089"></p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡</p>
<p><img src="../images/image-20210705094103385.png" alt="image-20210705094103385"></p>
<h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。</p>
<p><img src="../images/image-20210705094142506.png" alt="image-20210705094142506"></p>
<p>简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx 处理静态页面，Tomcat处理动态页面。</p>
<p>动静分离从目前实现角度来讲大致分为两种：</p>
<p> 一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案； </p>
<p>另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。 </p>
<p>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。</p>
<p>具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p>
<h1 id="2、-Nginx-的安装"><a href="#2、-Nginx-的安装" class="headerlink" title="2、 Nginx 的安装"></a>2、 Nginx 的安装</h1><img src="../images/image-20210705095050510.png" alt="image-20210705095050510" style="zoom:50%;" />

<p>安装省略，可以参考另外一篇笔记</p>
<h1 id="3、-Nginx-的常用命令和配置文件"><a href="#3、-Nginx-的常用命令和配置文件" class="headerlink" title="3、 Nginx 的常用命令和配置文件"></a>3、 Nginx 的常用命令和配置文件</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>在/usr/local/nginx/sbin 目录下执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">./nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本号</span></span><br><span class="line">./nginx -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">./nginx -s stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载</span></span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">worker_processes  1;<span class="comment"># nginx 处理并发的数量</span></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;<span class="comment"># 最大连接数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on; </span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第一部分：全局块"><a href="#第一部分：全局块" class="headerlink" title="第一部分：全局块"></a>第一部分：全局块</h3><p> 从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。</p>
<h3 id="第二部分：events块"><a href="#第二部分：events块" class="headerlink" title="第二部分：events块"></a>第二部分：events块</h3><p>events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。 上述例子就表示每个 work process 支持的最大连接数为 1024. </p>
<p>这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。</p>
<h3 id="第三部分：http块"><a href="#第三部分：http块" class="headerlink" title="第三部分：http块"></a>第三部分：http块</h3><p>代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 http全局块、server 块。 </p>
<h4 id="（1）-http-全局块"><a href="#（1）-http-全局块" class="headerlink" title="（1） http 全局块"></a>（1） http 全局块</h4><p>http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p>
<h4 id="（2）server-块"><a href="#（2）server-块" class="headerlink" title="（2）server 块"></a>（2）server 块</h4><p>和虚拟主机有密切关系。</p>
<p>虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。</p>
<p> 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 </p>
<p>而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</p>
<p> 1、全局 server 块 </p>
<p>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。 </p>
<p>2、location 块 </p>
<p>一个 server 块可以配置多个 location 块。 </p>
<p>这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p>
<h1 id="4、反向代理实例"><a href="#4、反向代理实例" class="headerlink" title="4、反向代理实例"></a>4、反向代理实例</h1><h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2><p><img src="../images/image-20210705121614861.png" alt="image-20210705121614861"></p>
<p>本机 host 文件添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.17.129 www.123.com</span><br></pre></td></tr></table></figure>

<p>Nginx 配置文件</p>
<p><img src="../images/image-20210705121808169.png" alt="image-20210705121808169"></p>
<p>测试</p>
<p><img src="../images/image-20210705121819438.png" alt="image-20210705121819438"></p>
<h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p>使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中<br>nginx 监听端口为 9001</p>
<p>访问 http:// 192.168.17.129 :9001/edu/ 直接跳转到 127.0.0.1:808 0<br>访问 http:// 192.168.17.129 :9001/vod/ 直接跳转到 127.0.0.1:808 1</p>
<h3 id="Nginx-配置修改"><a href="#Nginx-配置修改" class="headerlink" title="Nginx 配置修改"></a>Nginx 配置修改</h3><p>再添加一个 server 块，添加配置</p>
<p><img src="../images/image-20210705122138325.png" alt="image-20210705122138325"></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="../images/image-20210705122206917.png" alt="image-20210705122206917"></p>
<p><img src="../images/image-20210705122215874.png" alt="image-20210705122215874"></p>
<h1 id="5、负载均衡实例"><a href="#5、负载均衡实例" class="headerlink" title="5、负载均衡实例"></a>5、负载均衡实例</h1><h2 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h2><p><img src="../images/image-20210705122847958.png" alt="image-20210705122847958"></p>
<p><img src="../images/image-20210705122855692.png" alt="image-20210705122855692"></p>
<h2 id="负载均衡的策略"><a href="#负载均衡的策略" class="headerlink" title="负载均衡的策略"></a>负载均衡的策略</h2><p>轮询、加权、iphash、fair</p>
<h3 id="轮询（默认）"><a href="#轮询（默认）" class="headerlink" title="轮询（默认）"></a>轮询（默认）</h3><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。</p>
<h3 id="weight"><a href="#weight" class="headerlink" title="weight"></a>weight</h3><p>weigh t 代表权重默认为 1, 权重越高被分配的客户端越多</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream server_pool&#123; </span><br><span class="line">	server 192.168.5.21 weight=5; </span><br><span class="line">	server 192.168.5.22 weight=10; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h3><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream server_pool&#123; </span><br><span class="line">    ip_hash; </span><br><span class="line">    server 192.168.5.21:80; </span><br><span class="line">    server 192.168.5.22:80; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="fair-（第三方）"><a href="#fair-（第三方）" class="headerlink" title="fair （第三方）"></a>fair （第三方）</h3><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<h1 id="6、-动静分离实例"><a href="#6、-动静分离实例" class="headerlink" title="6、 动静分离实例"></a>6、 动静分离实例</h1><p>这里 <code>www</code> 和 <code>image</code> 是静态目录</p>
<p><img src="../images/image-20210705125230306.png" alt="image-20210705125230306"></p>
<h1 id="7、配置高可用集群"><a href="#7、配置高可用集群" class="headerlink" title="7、配置高可用集群"></a>7、配置高可用集群</h1><h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><p><img src="../images/image-20210705125754935.png" alt="image-20210705125754935"></p>
<ol>
<li>需要两台 <strong>nginx</strong> 服务器</li>
<li>需要 安装<strong>keepalived</strong></li>
<li>需要虚拟 <strong>ip</strong></li>
</ol>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1zJ411w7SV?p=14&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1zJ411w7SV?p=14&amp;spm_id_from=pageDriver</a></p>
</blockquote>
<h1 id="8、Nginx-原理"><a href="#8、Nginx-原理" class="headerlink" title="8、Nginx 原理"></a>8、Nginx 原理</h1><p><img src="../images/image-20210705130858064.png" alt="image-20210705130858064"></p>
<h2 id="work-是如何工作的"><a href="#work-是如何工作的" class="headerlink" title="work 是如何工作的"></a>work 是如何工作的</h2><p><img src="../images/image-20210705130928555.png" alt="image-20210705130928555"></p>
<h2 id="一个-master-和多个-woker-有什么好处"><a href="#一个-master-和多个-woker-有什么好处" class="headerlink" title="一个 master 和多个 woker 有什么好处"></a>一个 master 和多个 woker 有什么好处</h2><p>1 ）可以使用 <code>nginx -s reload</code> 热部署</p>
<p>2 ）每个 woker 是独立的进程，如果有其中的一个 woker 出现问题，其他 woker 因为是独立的，继续进行争抢，实现请求过程，不会造成服务中断</p>
<h2 id="设置多少个-woker-合适"><a href="#设置多少个-woker-合适" class="headerlink" title="设置多少个 woker 合适"></a>设置多少个 woker 合适</h2><p>worker 数和服务器的 cpu 数相等是最为适宜的</p>
<h2 id="连接数-worker-connection"><a href="#连接数-worker-connection" class="headerlink" title="连接数 worker_connection"></a>连接数 worker_connection</h2><p>第一个：发送请求，占用了 woker 的几个连接数？</p>
<p>答案： 2 或者 4 个</p>
<p>一来一回是两个，如果只是静态资源，2个；如果访问了动态资源（比如访问了数据库），4个</p>
<p>第二个： nginx 有一 个 master ，有四个 woker ，每个 woker 支持最大的连接数 1024 ，支持的最大并发数是多少？</p>
<ul>
<li>普通的静态访问最大并发数是： <code>worker_connections * worker_processes / 2</code></li>
<li>而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 <code>worker_connections * worker_processes / 4</code></li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="session-丢失如何解决？"><a href="#session-丢失如何解决？" class="headerlink" title="session 丢失如何解决？"></a>session 丢失如何解决？</h2><p>（1）使用容器扩展插件来实现</p>
<p>（2）使用Nginx负载均衡的ip_hash策略</p>
<p>（3）使用框架的会话管理工具——比如Spring session</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote>
<ol>
<li><a href="https://www.bilibili.com/video/BV1zJ411w7SV">https://www.bilibili.com/video/BV1zJ411w7SV</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10环境下编译openjdk15</title>
    <url>/archives/66c016fb.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章写于2021年1月份。</p>
<p>我在Windows 和 Linux 平台上都试着编译过 openjdk，Linux 平台上的一般按照周大大的步骤来，不会有什么问题，不过还是给个建议：<strong>使用 Ubuntu18 最佳</strong>，因为这样你不需要手动更改 GCC 的版本（Ubuntu18 的 GCC 版本是 7.x，刚好和官方的要求符合），给自己省了点麻烦。当然，如果你是 Linux 使用高手，可以忽略我这一点建议。</p>
<span id="more"></span>

<p>在 Windows 平台的建议是：直接编译 openjdk15，原因如下：</p>
<ol>
<li>自身实践。我尝试编译了 openjdk8 到 openjdk15，只有 openjdk15 的编译不需要修改官方的脚本，openjdk13 ，12 都需要修改 <code>make\autoconf\toolchain_windows.m4</code>这个文件，具体可参考<a href="https://blog.csdn.net/weixin_45040801/article/details/102612042">这篇文章</a></li>
<li>不需要安装过多的依赖或者软件。只需要 vs2017 英文版（注意是英文版）和 cygwin64，具体原因看<a href="https://blog.csdn.net/weixin_45040801/article/details/102542213?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control">这篇文章</a>。很多博客会说需要 <code>freetype</code> 这个依赖，但是我在编译的时候并没有用过，在这里供大家参考。</li>
</ol>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="软件以及源代码"><a href="#软件以及源代码" class="headerlink" title="软件以及源代码"></a>软件以及源代码</h2><ul>
<li>openjdk14（下载解压即可，不需要配置环境变量）</li>
<li>openjdk15 源代码</li>
<li>vs2017 英文版</li>
<li>cygwin64</li>
</ul>
<p>具体下载地址我不再给出，请自行下载</p>
<h2 id="依赖包安装"><a href="#依赖包安装" class="headerlink" title="依赖包安装"></a>依赖包安装</h2><p>cygwin64 安装的时候选择即可，至少需要安装：</p>
<ul>
<li>autoconf</li>
<li>zip</li>
<li>unzip</li>
<li>make</li>
<li>tar</li>
</ul>
<p>其他的依赖可以参考源码下的 <code>doc/building.html</code> 文档</p>
<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><ol>
<li>可以把 cygwin64 加入环境变量，这样可以在 Windows 的 CMD 窗口直接使用 Linux 命令，不过要放在 <code>C:\WINDOWS\system32</code> 之前。如下图：<br><img src="../images/20210112110038781.png" alt="cygwin64 环境配置"></li>
<li>把自己电脑的语言设置成英文，这样你会少看到一些 warning，有强迫症的同志甚至可以把国家和地区改一下</li>
</ol>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>如果你在上文和我一下配置了 cygwin64 的环境变量，那你可以直接在源代码目录下这么干<br><img src="../images/20210112110722405.png" alt="在这里插入图片描述"><br>这样你就直接进入了命令行窗口</p>
<h2 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash ./configure --enable-debug --disable-warnings-as-errors --with-ucrt-dll-dir=<span class="string">&quot;/cygdrive/c/Program Files (x86)/Windows Kits/10/Redist/10.0.17763.0/ucrt/DLLs/x64&quot;</span> --with-boot-jdk=/cygdrive/d/Environment/Java/openjdk-14</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>–enable-debug 等价于 –with-debug-level=fastdebug，此外还有 release、slowdebug 两个参数，他们是编译级别，默认是 release（发布版）</li>
<li>–with-ucrt-dll-dir 是指定 DLL 目录，具体为：<code>&quot;/cygdrive/c/Program Files (x86)/Windows Kits/10/Redist/10.0.17763.0/ucrt/DLLs/x64&quot;</code>，这里是一个映射，<code>/cygdrive/c/Program Files (x86)</code> 就是 Windows 的 <code>C:\Program Files (x86)</code>目录，具体的目录是我们安装好 VS2017 之后产生的目录，版本号<code> 10.0.17763.0</code> 可能会有不同，大家自行修改成自己的</li>
<li>–with-boot-jdk 指定引导 jdk 的安装目录，改成自己的目录即可</li>
</ul>
<p>截图如下：<br><img src="../images/2021011211160042.png" alt="在这里插入图片描述"><br>如果一切良好，会看到类似于这样的：<br><img src="../images/20210112112147474.png" alt="在这里插入图片描述"><br>如果出现了其他问题，可以参考错误信息，结合官方文档以及合理度娘来解决问题。</p>
<h2 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h2><p>按需编译，或者 <code>make all</code>，编译时间在半个小时到一个小时之间</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>等于学习了《深入理解 Java 虚拟机》第一章，希望不要努力了两天的成果在硬盘里面吃灰。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li>  [1] <a href="https://blog.csdn.net/weixin_45040801/article/details/102542213?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control">https://blog.csdn.net/weixin_45040801/article/details/102542213?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control</a></li>
<li>  [2] <a href="https://blog.csdn.net/weixin_45040801/article/details/102612042">https://blog.csdn.net/weixin_45040801/article/details/102612042</a></li>
<li>  [3] <a href="https://www.cnblogs.com/zhoujun007/archive/2004/01/13/13406716.html">https://www.cnblogs.com/zhoujun007/archive/2004/01/13/13406716.html</a></li>
<li>  [4] 深入理解 Java 虚拟机（第三版）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
        <category>编译OpenJDK15</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记</title>
    <url>/archives/afea1789.html</url>
    <content><![CDATA[<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>实力：聊天+举止+谈吐+见解</p>
<span id="more"></span>

<p><img src="../images/image-20201231221012426.png" alt="image-20201231221012426"></p>
<p>网站结构演进：</p>
<p><img src="../images/dubbo-architecture-roadmap.jpg" alt="image"></p>
<h4 id="单一应用架构"><a href="#单一应用架构" class="headerlink" title="单一应用架构"></a>单一应用架构</h4><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM，Object Relational Mapping，对象关系映射)是关键。</p>
<h4 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h4><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<h4 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h4><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<h4 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a>流动计算架构</h4><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA，Service-Oriented Architecture，面向服务的架构)是关键。</p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>特点：</p>
<p>1、组件化</p>
<p>2、根据业务构建服务，组织团队</p>
<p>3、去中心化</p>
<p>4、容错设计</p>
<p>5、演进式设计</p>
<p>几个专业术语：“面向服务的架构”(Service Oriented Architecture, SOA)</p>
<p>（1）“微服务”原文链接：<a href="http://martinfowler.com/articles/microservices.html">http://martinfowler.com/articles/microservices.html</a></p>
<p>（2）“微服务”译文链接：<a href="http://mp.weixin.qq.com/s?__biz=MjM5MjEwNTEzOQ==&amp;mid=401500724&amp;idx=1&amp;sn=4e42fa2ffcd5732ae044fe6a387a1cc3#rd">http://mp.weixin.qq.com/s?__biz=MjM5MjEwNTEzOQ==&amp;mid=401500724&amp;idx=1&amp;sn=4e42fa2ffcd5732ae044fe6a387a1cc3#rd</a></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>1、以开发一组小型服务的方式来构建一个应用。</p>
<p>2、每个服务运行在自己的进程中，并经常采用HTTP资源API这样轻量的机制来相互通信。</p>
<p>3、服务围绕业务功能进行构建，并能通过全自动的部署机制来独立部署。</p>
<p>4、服务可以使用不同的语言来编写，可以使用不同的数据存储技术。</p>
<p>5、对这些微服务我们仅做最低限度的集中管理。</p>
</blockquote>
<p>简单点说：以若干组可独立部署的服务的方式进行软件应用系统的设计，服务能被独立地部署和扩展，每一个服务还能提供一个稳固的模块边界，甚至能允许使用不同的编程语言来编写不同的服务</p>
<p>对比：</p>
<p>单块（monolithic）风格：一个单块应用系统是以一个单个单元的方式来构建的。企业应用系统经常包含三个主要部分：客户端用户界面、数据库和服务端应用系统。客户端用户界面包括HTML页面和运行在用户机器的浏览器中的JavaScript。数据库中包括许多表，这些表被插入一个公共的且通常为关系型的数据库管理系统中。这个服务端的应用系统就是一个单块应用——一个单个可执行的逻辑程序。对于该系统的任何改变，都会涉及构建和部署上述服务端应用系统的一个新版本。</p>
<p>限制：</p>
<ul>
<li>应用系统的一个很小的部分的一处变更，也需要将整个单块应用系统进行重新构建和部署。</li>
<li>随着时间的推移，单块应用开始变得经常难以保持一个良好的模块化结构，这使得它变得越来越难以将一个模块的变更的影响控制在该模块内。</li>
<li>当对系统进行扩展时，不得不扩展整个应用系统，而不能仅扩展该系统中需要更多资源的那些部分。</li>
</ul>
<p><img src="../images/image-20200620162003973.png" alt="image-20200620162003973"></p>
<h3 id="微服务架构的九大特性"><a href="#微服务架构的九大特性" class="headerlink" title="微服务架构的九大特性"></a>微服务架构的九大特性</h3><ol>
<li><p>特性一：“组件化”与“多服务”</p>
</li>
<li><p>特性二：围绕“业务功能”组织团队</p>
</li>
</ol>
<ul>
<li>即，根据<strong>业务功能</strong>（business capability）来将系统分解为若干服务</li>
</ul>
<ol start="3">
<li>特性三：“做产品”而不是“做项目”</li>
</ol>
<ul>
<li>一个开发团队对一个在生产环境下运行的软件负全责，就是说，开发之后不能不管了，运维也得你来</li>
</ul>
<ol start="4">
<li><p>特性四：“智能端点”与“傻瓜管道”</p>
<ul>
<li><p>使用微服务所构建的各个应用的目标，都是尽可能地实现“高内聚和低耦合”——他们拥有自己的领域逻辑，并且更多地是像经典Unix的“过滤器”(filter)那样来工作——即接收一个请求，酌情对其应用业务逻辑，并产生一个响应。这些应用通过使用一些简单的REST风格的协议来进行编制</p>
</li>
<li><p>微服务最常用的两种协议是：带有资源API的HTTP“请求－响应”协议，和轻量级的消息发送协议（提供可靠的异步机制即可）</p>
</li>
<li><blockquote>
<p>在一个单块系统中，各个组件在同一个进程中运行。它们相互之间的通信，要么通过方法调用，要么通过函数调用来进行。将一个单块系统改造为若干微服务的最大问题，在于对通信模式的改变。仅仅将内存中的方法调用转换为RPC调用这样天真的做法，会导致微服务之间产生繁琐的通信，使得系统表现变糟。取而代之的是，需要用更粗粒度的协议来替代细粒度的服务间通信。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>特性五：“去中心化”地治理技术</p>
</li>
</ol>
<ul>
<li>构建每个服务可以使用不同的技术栈，<strong>多种编程语言，多种选择可能</strong>，不像单块系统定死了</li>
</ul>
<ol start="6">
<li><p>特性六：“去中心化”地管理数据</p>
<ul>
<li><p>让每一个服务来管理其自有数据库。可以采用相同数据库技术的不同数据库实例，也可以采用完全不同的数据库系统</p>
<p><img src="../images/image-20200620164010742.png" alt="image-20200620164010742"></p>
</li>
<li><p>将数据的职责进行“去中心化”的管理，会影响软件更新的管理。常用方法，是当更新多个资源的时候，使用事务来保证一致性。</p>
</li>
<li><p>微服务架构更强调在各个服务之间进行“无事务”的协调。即数据一致性可能只要求数据在最终达到一致，并且一致性问题能够通过补偿操作来进行处理。</p>
</li>
<li><blockquote>
<p>符合在商业上的实践做法。通常情况下，为了快速响应需求，商家们都会处理一定程度上的数据“非一致性”，来通过做某种反向过程进行错误处理。只要修复错误的成本，与在保持更大的数据一致性却导致丢了生意所产生的成本相比，前者更低，那么这种“非一致性”地管理数据的权衡就是值得的。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>特性七：“基础设施”自动化</p>
<ul>
<li><img src="../images/640" alt="img"></li>
</ul>
</li>
<li><p>特性八：“容错”设计</p>
<ul>
<li>某个服务不可用时，调用者需要有容错机制</li>
<li>用各个微服务来替代组件，其结果是各个应用程序需要设计成能够容忍这些服务所出现的故障。</li>
</ul>
</li>
<li><p>特性九：“演进式”设计</p>
<ul>
<li>组件可更换，可废弃，可再次使用（比如，碧蓝航线的活动复刻）</li>
</ul>
</li>
</ol>
<h2 id="静态资源导入"><a href="#静态资源导入" class="headerlink" title="静态资源导入"></a>静态资源导入</h2><p>总结：</p>
<ol>
<li>可以使用以下方式处理静态资源<ul>
<li>webjars  <code>localhost:8080/webjars/...</code></li>
<li>public，resources，static   <code>localhost:8080/...</code></li>
</ul>
</li>
<li>优先级<ul>
<li>resources&gt;static（默认）&gt;public</li>
</ul>
</li>
</ol>
<p>创建工程后删除的文件</p>
<p><img src="../images/image-20200712223653205.png" alt="image-20200712223653205"></p>
<h2 id="springboot原理初探"><a href="#springboot原理初探" class="headerlink" title="springboot原理初探"></a>springboot原理初探</h2><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><ul>
<li><p>核心依赖在父工程中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>引入依赖时不需要指定版本，因为有这些版本的仓库</p>
</li>
</ul>
<p><strong>启动器</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  如果需要使用什么功能，只需要找到对应的启动器<code>starter</code></li>
</ul>
<p><strong>注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span>	:spring配置</span><br><span class="line">	<span class="meta">@Configuration</span>	:配置</span><br><span class="line">		<span class="meta">@Component</span>	:组件</span><br><span class="line">			<span class="meta">@Indexed</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>	:自动配置</span><br><span class="line">		<span class="meta">@AutoConfigurationPackage</span>	:自动配置包</span><br><span class="line">    		<span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class="line">		<span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br></pre></td></tr></table></figure>



<p><strong>结论</strong>：springboot的所有的自动配置都是在启动的时候配置并加载，都在<code>spring.factories</code>，但是不一定生效，要判断条件是否成立：只有导入了相应的<code>starter</code>，有个启动器，我们的自动装配就会生效</p>
<p><img src="../images/image-20201231235126668.png" alt="image-20201231235126668"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate学习笔记</title>
    <url>/archives/9ec6fc96.html</url>
    <content><![CDATA[<h2 id="一、是什么？"><a href="#一、是什么？" class="headerlink" title="一、是什么？"></a>一、是什么？</h2><p>hibernate框架应用在javaee三层结构中 dao层框架</p>
<p>hibernate底层代码就是jdbc，hibernate对jdbc进行封装，使用hibernate好处，不需要写复杂jdbc代码了，<br>不需要写sql语句实现</p>
<p>开源的轻量级的框架</p>
<span id="more"></span>



<h2 id="ORM思想"><a href="#ORM思想" class="headerlink" title="ORM思想"></a>ORM思想</h2><p>orm：object relational mapping，对象关系映射<br>文字描述：<br>（1）让实体类和数据库表进行一一对应关系<br>让实体类首先和数据库表对应<br>让实体类属性 和 表里面字段对应<br>（2）不需要直接操作数据库表，而操作表对应实体类对象</p>
<p><img src="../images/clip_image002.jpg" alt="img"></p>
<p><img src="../images/clip_image002-1623322622876.jpg" alt="img"></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="搭建一个demo"><a href="#搭建一个demo" class="headerlink" title="搭建一个demo"></a>搭建一个demo</h3><h4 id="1、使用IDEA创建一个Maven工程"><a href="#1、使用IDEA创建一个Maven工程" class="headerlink" title="1、使用IDEA创建一个Maven工程"></a>1、使用IDEA创建一个Maven工程</h4><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>解决编译时资源文件不生效的问题：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认打包资源文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、写个实体类"><a href="#2、写个实体类" class="headerlink" title="2、写个实体类"></a>2、写个实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> uid;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> uid, String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、写实体类对应的配置文件"><a href="#3、写实体类对应的配置文件" class="headerlink" title="3、写实体类对应的配置文件"></a>3、写实体类对应的配置文件</h4><p>建议：在实体类所在包里面创建，<code>实体类名称.hbm.xml</code></p>
<p><img src="../images/image-20210610190546796.png" alt="image-20210610190546796"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  ~ Hibernate, Relational Persistence for Idiomatic Java</span></span><br><span class="line"><span class="comment">  ~</span></span><br><span class="line"><span class="comment">  ~ License: GNU Lesser General Public License (LGPL), version 2.1 or later.</span></span><br><span class="line"><span class="comment">  ~ See the lgpl.txt file in the root directory or &lt;http://www.gnu.org/licenses/lgpl-2.1.html&gt;.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;com.tcmyxc.dao&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置类名和表名的映射关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;User&quot;</span> <span class="attr">table</span>=<span class="string">&quot;t_user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置主键自增长--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置类属性和表结构中列名的对应关系，不填就一模一样--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4、创建hibernate的核心配置文件"><a href="#4、创建hibernate的核心配置文件" class="headerlink" title="4、创建hibernate的核心配置文件"></a>4、创建hibernate的核心配置文件</h4><p>名字是固定的：<code>hibernate.cfg.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  ~ Hibernate, Relational Persistence for Idiomatic Java</span></span><br><span class="line"><span class="comment">  ~</span></span><br><span class="line"><span class="comment">  ~ License: GNU Lesser General Public License (LGPL), version 2.1 or later.</span></span><br><span class="line"><span class="comment">  ~ See the lgpl.txt file in the root directory or &lt;http://www.gnu.org/licenses/lgpl-2.1.html&gt;.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-configuration</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Database connection settings --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.driver_class&quot;</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.url&quot;</span>&gt;</span>jdbc:mysql:///mytest?serverTimezone=UTC<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--可选配置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- JDBC connection pool (use the built-in) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.pool_size&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- SQL dialect --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL8Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 输出 sql 语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--sql 语句格式化--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;format_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自动创建表</span></span><br><span class="line"><span class="comment">            update: 没有则创建，有则更新</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hbm2ddl.auto&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;com/tcmyxc/dao/User.hbm.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h4><p>第一步 加载hibernate核心配置文件</p>
<p>第二步 创建SessionFactory对象</p>
<p>第三步 使用SessionFactory创建session对象</p>
<p>第四步 开启事务</p>
<p>第五步 写具体逻辑 crud操作</p>
<p>第六步 提交事务</p>
<p>第七步 关闭资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Configuration cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">    cfg.configure();</span><br><span class="line"></span><br><span class="line">    SessionFactory sessionFactory = cfg.buildSessionFactory();</span><br><span class="line">    Session session = sessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    Transaction transaction = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">&quot;xwx&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    session.save(user);</span><br><span class="line"></span><br><span class="line">    transaction.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hibernate核心api"><a href="#Hibernate核心api" class="headerlink" title="Hibernate核心api"></a>Hibernate核心api</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><p>找到名称hibernate.cfg.xml配置文件，创建对象，把配置文件放到对象里面（加载核心配置文件）</p>
<h4 id="SessionFactory"><a href="#SessionFactory" class="headerlink" title="SessionFactory"></a>SessionFactory</h4><p>1 使用configuration对象创建sessionFactory对象<br>（1）创建sessionfactory过程中做事情：</p>
<ul>
<li>根据核心配置文件中，有数据库配置，有映射文件部分，到数据库里面根据映射关系把表创建</li>
</ul>
<p>2 创建sessionFactory过程中，这个过程特别耗资源的<br>（1）在hibernate操作中，建议一个项目一般创建一个sessionFactory对象</p>
<p>3 具体实现<br>（1）写工具类，写静态代码块实现</p>
<ul>
<li>静态代码块在类加载时候执行，执行一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionFactoryUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Configuration cfg = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sessionFactory = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态代码块保证只被加载一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">        cfg.configure();</span><br><span class="line">        sessionFactory = cfg.buildSessionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SessionFactory <span class="title">getSessionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>1 session类似于jdbc中connection</p>
<p>2 调用session里面不同的方法实现crud操作<br>（1）添加 save方法<br>（2）修改 update方法<br>（3）删除 delete方法<br>（4）根据id查询 get方法</p>
<p>3 session对象单线程对象<br>（1）session对象不能共用，只能自己使用</p>
<h3 id="增删改查那些事"><a href="#增删改查那些事" class="headerlink" title="增删改查那些事"></a>增删改查那些事</h3><h4 id="Hibernate实体类编写规则"><a href="#Hibernate实体类编写规则" class="headerlink" title="Hibernate实体类编写规则"></a>Hibernate实体类编写规则</h4><p>1 实体类里面属性私有的</p>
<p>2 私有属性使用公开的set和get方法操作</p>
<p>3 要求实体类有属性作为唯一值（一般使用id值）</p>
<p>4 实体类属性建议不使用基本数据类型，使用基本数据类型对应的包装类<br>（1）八个基本数据类型对应的包装类</p>
<ul>
<li>int – Integer</li>
<li>char—Character、</li>
<li>其他的都是首字母大写 比如 double – Double<br>（2）比如 表示学生的分数，假如 int score;</li>
<li>比如学生得了0分 ，int score = 0;</li>
<li>如果表示学生没有参加考试，int score = 0;不能准确表示学生是否参加考试<ul>
<li>解决：使用包装类可以了， Integer score = 0，表示学生得了0分，表示学生没有参加考试，Integer score = null;</li>
</ul>
</li>
</ul>
<h4 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h4><p><img src="../images/clip_image002-1623324391800.jpg" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置主键自增长--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><p>根据 id 查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210610193221935.png" alt="image-20210610193221935"></p>
<h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line">user.setPassword(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">session.update(user);</span><br><span class="line">User user2 = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user2);</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210610193536590.png" alt="image-20210610193536590"></p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line"><span class="comment">// 测试删除操作</span></span><br><span class="line">session.delete(user);</span><br><span class="line">User user2 = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user2);</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210610193824545.png" alt="image-20210610193824545"></p>
<h2 id="其他的概念"><a href="#其他的概念" class="headerlink" title="其他的概念"></a>其他的概念</h2><h3 id="实体类对象状态"><a href="#实体类对象状态" class="headerlink" title="实体类对象状态"></a>实体类对象状态</h3><p>实体类状态有三种</p>
<p>（1）瞬时态：对象里面没有id值，对象与session没有关联</p>
<p><img src="../images/clip_image002-1623325203474.jpg" alt="img"></p>
<p>（2）持久态：对象里面有id值，对象与session关联</p>
<p><img src="../images/clip_image004.jpg" alt="img"></p>
<p>（3）托管态：对象有id值，对象与session没有关联</p>
<p><img src="../images/clip_image006.jpg" alt="img"></p>
<p>saveOrUpdate方法：实现添加、实现修改</p>
<p><img src="../images/clip_image002-1623325258642.jpg" alt="img"></p>
<p><img src="../images/clip_image004-1623325258643.jpg" alt="img"></p>
<p><img src="../images/clip_image006-1623325258643.jpg" alt="img"></p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>hibernate缓存特点：</p>
<p>第一类 hibernate的一级缓存</p>
<p>（1）hibernate的一级缓存默认打开的</p>
<p>（2）hibernate的一级缓存使用范围，是session范围，从session创建到session关闭范围</p>
<p>（3）hibernate的一级缓存中，存储数据必须 持久态数据</p>
<p>第二类 hibernate的二级缓存</p>
<p>（1）目前已经不使用了，替代技术 redis</p>
<p>（2）二级缓存默认不是打开的，需要配置</p>
<p>（3）二级缓存使用范围，是sessionFactory范围</p>
<p><img src="../images/clip_image002-1623325371492.jpg" alt="img"></p>
<h3 id="事务代码规范写法"><a href="#事务代码规范写法" class="headerlink" title="事务代码规范写法"></a>事务代码规范写法</h3><p>代码结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; 开启事务 提交事务&#125;</span><br><span class="line"><span class="keyword">catch</span>() &#123; 回滚事务&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123; 关闭&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTx</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    SessionFactory sessionFactory = <span class="keyword">null</span>;    </span><br><span class="line">    Session session = <span class="keyword">null</span>;    </span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;    </span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">        sessionFactory = HibernateUtils.getSessionFactory();        </span><br><span class="line">        session = sessionFactory.openSession();        </span><br><span class="line">        <span class="comment">//开启事务        </span></span><br><span class="line">        tx = session.beginTransaction();        </span><br><span class="line">        <span class="comment">//添加        </span></span><br><span class="line">        User user = <span class="keyword">new</span> User();        </span><br><span class="line">        user.setUsername(<span class="string">&quot;小马&quot;</span>);        </span><br><span class="line">        user.setPassword(<span class="string">&quot;250&quot;</span>);        </span><br><span class="line">        user.setAddress(<span class="string">&quot;美国&quot;</span>);        </span><br><span class="line">        session.save(user);        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;        </span><br><span class="line">        <span class="comment">//提交事务        </span></span><br><span class="line">        tx.commit();    </span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e) &#123;        </span><br><span class="line">    	e.printStackTrace();        </span><br><span class="line">        <span class="comment">//回滚事务        </span></span><br><span class="line">        tx.rollback();    </span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;        </span><br><span class="line">        <span class="comment">//关闭操作        </span></span><br><span class="line">        session.close();        </span><br><span class="line">        sessionFactory.close();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210610194600591.png" alt="image-20210610194600591"></p>
<h2 id="回顾表和表之间的关系"><a href="#回顾表和表之间的关系" class="headerlink" title="回顾表和表之间的关系"></a>回顾表和表之间的关系</h2><p>一对多：分类和商品关系，一个分类里面有多个商品，一个商品只能属于一个分类</p>
<p>多对多：订单和商品关系，一个订单里面有多个商品，一个商品属于多个订单</p>
<p>多对多建表：创建第三张表维护关系</p>
<p><img src="../images/clip_image002-1623910791593.jpg" alt="img"></p>
<h2 id="查询方式介绍"><a href="#查询方式介绍" class="headerlink" title="查询方式介绍"></a>查询方式介绍</h2><h3 id="对象导航查询"><a href="#对象导航查询" class="headerlink" title="对象导航查询"></a>对象导航查询</h3><p>（1）根据id查询某个客户，再查询这个客户里面所有的联系人</p>
<p><img src="../images/clip_image002-1623913387871.jpg" alt="img"></p>
<h3 id="OID查询"><a href="#OID查询" class="headerlink" title="OID查询"></a>OID查询</h3><p>（1）根据id查询某一条记录，返回对象</p>
<p><img src="../images/clip_image002-1623913455625.jpg" alt="img"></p>
<h3 id="HQL查询"><a href="#HQL查询" class="headerlink" title="HQL查询"></a>HQL查询</h3><p>HQL，即hibernate query language，hibernate提供一种查询语言，hql语言和普通sql很相似</p>
<p>区别：普通sql操作数据库表和字段，hql操作实体类和属性</p>
<p>常用的hql语句</p>
<p>（1）查询所有： from 实体类名称</p>
<p>（2）条件查询： from 实体类名称 where 属性名称=? </p>
<p>（3）排序查询： from 实体类名称 order by 实体类属性名称 asc/desc</p>
<p>使用hql查询操作时候，使用Query对象</p>
<p>（1）创建Query对象，写hql语句</p>
<p>（2）调用query对象里面的方法得到结果</p>
<h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><p><img src="../images/clip_image002-1623913606053.jpg" alt="img"></p>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p><img src="../images/clip_image002-1623913667053.jpg" alt="img"></p>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>在hql操作中，在语句里面不能写limit，hibernate的Query对象封装两个方法实现分页操作</p>
<p><img src="../images/clip_image002-1623913727409.jpg" alt="img"></p>
<h4 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h4><p> 投影查询：查询不是所有字段值，而是部分字段的值</p>
<p>投影查询hql语句写法：</p>
<p>（1）select 实体类属性名称1, 实体类属性名称2  from 实体类名称</p>
<p>（2）select 后面不能写 <code>* </code>，不支持的</p>
<p>具体实现：</p>
<p><img src="../images/clip_image002-1623914156308.jpg" alt="img"></p>
<h3 id="QBC查询"><a href="#QBC查询" class="headerlink" title="QBC查询"></a>QBC查询</h3><p>1、使用hql查询需要写hql语句实现，但是使用qbc时候，不需要写语句了，使用方法实现</p>
<p>2、使用qbc时候，操作实体类和属性</p>
<p>3、使用qbc，使用Criteria对象实现</p>
<h4 id="查询所有-1"><a href="#查询所有-1" class="headerlink" title="查询所有"></a>查询所有</h4><p><img src="../images/clip_image002-1623914241737.jpg" alt="img"></p>
<h4 id="条件查询-1"><a href="#条件查询-1" class="headerlink" title="条件查询"></a>条件查询</h4><p><img src="../images/clip_image002-1623914264974.jpg" alt="img"></p>
<h4 id="分页查询-1"><a href="#分页查询-1" class="headerlink" title="分页查询"></a>分页查询</h4><p><img src="../images/clip_image002-1623914337716.jpg" alt="img"></p>
<h4 id="统计查询"><a href="#统计查询" class="headerlink" title="统计查询"></a>统计查询</h4><p><img src="../images/clip_image002-1623914367144.jpg" alt="img"></p>
<h4 id="本地sql查询"><a href="#本地sql查询" class="headerlink" title="本地sql查询"></a>本地sql查询</h4><p>SQLQuery对象，使用普通sql实现查询</p>
<p>servlet调用service，service调用dao</p>
<p>（1）在dao里面对数据库crud操作<br>（2）在dao里面使用hibernate框架，使用hibernate框架时候，调用session里面的方法实现功能</p>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>迫切内连接</p>
<p>（1）迫切内连接和内连接底层实现一样的</p>
<p>（2）区别：使用内连接返回list中每部分是数组，迫切内连接返回list每部分是对象</p>
<p>（3）hql语句写法：from  Customer  c  inner  join  fetch  c.setLinkMan</p>
<h2 id="检索策略"><a href="#检索策略" class="headerlink" title="检索策略"></a>检索策略</h2><p>检索策略分为两类：</p>
<p>（1）立即查询：根据id查询，调用get方法，一调用get方法马上发送语句查询数据库</p>
<p>（2）延迟查询：根据id查询，还有load方法，调用load方法不会马上发送语句查询数据，只有得到对象里面的值时候才会发送语句查询数据库</p>
<p>延迟查询分成两类：</p>
<p>（1）类级别延迟：根据id查询返回实体类对象，调用load方法不会马上发送语句</p>
<p>（2）关联级别延迟：查询某个客户，再查询这个客户的所有联系人，查询客户的所有联系人的过程是否需要延迟，这个过程称为关联级别延迟</p>
<p>批量抓取</p>
<p>查询所有的客户，返回list集合，遍历list集合，得到每个客户，得到每个客户的所有联系人</p>
<p><img src="../images/clip_image002-1623914745666.jpg" alt="img"></p>
<p>在客户的映射文件中，set标签配置 batch-size值，值越大发送语句越少</p>
<p><img src="../images/clip_image002-1623914783979.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>版本号命名规范</title>
    <url>/archives/c1de7360.html</url>
    <content><![CDATA[<h1 id="版本号命名规范"><a href="#版本号命名规范" class="headerlink" title="版本号命名规范"></a>版本号命名规范</h1><blockquote>
<p>文章来源忘记了，如果作者看到可以联系我</p>
</blockquote>
<p>版本号是版本的标识号，每一个软件都有一个版本号。版本号能使用户了解所使用的操作系统是否为最新的版本以及它所提供的功能与设施。 一个好的软件产品一定要有个规范的版本号，而在命名版本号时有一些约定俗成的规则，下面本篇文章就来简单介绍一下，希望对你们有所帮助。</p>
<span id="more"></span>

<p><strong>1、版本命名规范</strong></p>
<p>软件版本号由四部分组成：</p>
<p>●　第一部分为主版本号</p>
<p>●　第二部分为子版本号</p>
<p>●　第三部分为阶段版本号</p>
<p>●　第四部分为日期版本号加希腊字母版本号。</p>
<p>希腊字母版本号共有5种，分别为：base、alpha、beta、RC、release。例如：1.1.1.051021_beta</p>
<p>常规：完全的版本号定义，分三项：：&lt;主版本号&gt;.&lt;次版本号&gt;.&lt;修订版本号&gt;，如 1.0.0</p>
<p><strong>2、 版本号修改规则</strong></p>
<p>●　主版本号：当功能模块有较大的变动，比如增加多个模块或者整体架构发生变化。此版本号由项目决定是否修改。这个一般不修改。</p>
<p>●　子版本号：当功能有一定的增加或变化，比如增加了对权限控制、增加自定义视图等功能。此版本号由项目决定是否修改。这个一般不修改。</p>
<p>●　阶段版本号：一般是Bug修复或是一些小的变动，要经常发布修订版，时间间隔不限，修复一个严重的bug即可发布一个修订版。根据打包的情况，修订版本号逐渐增加。</p>
<p>●　日期版本号：用于记录修改项目的当前日期，每天对项目的修改都需要更改日期版本号。根据当天打包的日期进行修改。</p>
<p><strong>3、软件版本阶段说明</strong></p>
<p>●　Alpha版: 此版本表示该软件在此阶段主要是以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的Bug较多，需要继续修改。</p>
<p>●　Beta版: 该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对像是软件的UI。</p>
<p>●　RC版: 该版本已经相当成熟了，基本上不存在导致错误的BUG，与即将发行的正式版相差无几。</p>
<p>●　Release版: 该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(R)。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/archives/e255a10a.html</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><blockquote>
<p>  参考文献：</p>
<ul>
<li>  [1]王道计算机网络复习书</li>
<li>  [2]计算机网络（第五版）- 潘爱民等译</li>
</ul>
</blockquote>
<span id="more"></span>



<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h3 id="对称秘钥算法"><a href="#对称秘钥算法" class="headerlink" title="对称秘钥算法"></a>对称秘钥算法</h3><p><strong>使用相同的秘钥加解密</strong></p>
<p><img src="../images/image-20210112143721721.png" alt="image-20210112143721721"></p>
<h4 id="DES-数据加密标准"><a href="#DES-数据加密标准" class="headerlink" title="DES 数据加密标准"></a>DES 数据加密标准</h4><p>三重 DES</p>
<p>1、使用秘钥 1 执行 DES 加密</p>
<p>2、使用秘钥 2 解密</p>
<p>3、使用秘钥 1 加密</p>
<h4 id="AES-高级加密标准"><a href="#AES-高级加密标准" class="headerlink" title="AES 高级加密标准"></a>AES 高级加密标准</h4><h3 id="公开秘钥算法"><a href="#公开秘钥算法" class="headerlink" title="公开秘钥算法"></a>公开秘钥算法</h3><p>加密算法 E，解密算法 D</p>
<p>1、$\ D(E(P))=P$</p>
<p>2、从 E 很难推出 D</p>
<p>3、加密算法不可能被选择明文攻击破解</p>
<p>使用公钥加密信息，私钥解密信息 </p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>1、接收方可以验证发送方的身份</p>
<p>2、发送方不能说我没发过</p>
<p>3、接收方不可能伪造发送的信息</p>
<h4 id="对称秘钥签名"><a href="#对称秘钥签名" class="headerlink" title="对称秘钥签名"></a>对称秘钥签名</h4><p><strong>使用同一秘钥</strong></p>
<p>找一个权威机构，自己的私钥自己知道，机构也知道</p>
<p>发送消息：</p>
<p>1、Alice 使用私钥加密，并标识要发送给 Bob</p>
<p>2、机构看到消息，解密该消息，然后发给 Bob</p>
<p>3、Bob 接收消息</p>
<h4 id="公开秘钥签名"><a href="#公开秘钥签名" class="headerlink" title="公开秘钥签名"></a>公开秘钥签名</h4><p><img src="../images/image-20210112150440539.png" alt="image-20210112150440539"></p>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>认证中心 CA</p>
<p>证书：将一个公钥和一个实体绑定</p>
<h3 id="SSL-安全套接字层"><a href="#SSL-安全套接字层" class="headerlink" title="SSL 安全套接字层"></a>SSL 安全套接字层</h3><p>HTTPS 443端口</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><h4 id="C-S-模型"><a href="#C-S-模型" class="headerlink" title="C/S 模型"></a>C/S 模型</h4><p>服务器总是打开，总是处于接收请求的状态，如果收到请求，则解析请求，进行必要的处理，并将处理结果发送给客户端</p>
<p>特点：</p>
<ul>
<li>  客户机地位不均等，服务器可以通过用户权限控制管理客户机</li>
<li>  客户机不直接通信</li>
<li>  单个服务器支持的客户机有限</li>
</ul>
<h4 id="P2P-模型"><a href="#P2P-模型" class="headerlink" title="P2P 模型"></a>P2P 模型</h4><p>各节点既是客户端又是服务器，都可以上传下载，相互之间直接通信</p>
<p>优点：</p>
<ul>
<li>  减轻了服务器的压力</li>
<li>  消除对某个服务器的完全依赖，可以把任务放到多个节点上</li>
<li>  可直接共享文档</li>
<li>  拓展性好</li>
<li>  网络健壮性强</li>
</ul>
<p>缺点：</p>
<ul>
<li>  由于既获取服务也提供服务，内存占用较大，会影响整机速度</li>
</ul>
<h3 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h3><p>C/S 模型，协议运行在 UDP 之上，53 号端口</p>
<p>域名是层次结构，级别高的在右边</p>
<p>域名系统：联机分布式的数据库系统</p>
<p>四种 DNS 服务器：根（13个）、顶级、授权、本地</p>
<p>每台主机都必须在授权域名服务器登记</p>
<h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><p>两种方式：</p>
<ul>
<li>  递归查询（根 DNS 服务器是中继节点，压力大）</li>
<li>  递归和迭代相结合</li>
</ul>
<p>递归查询示意图：</p>
<p><img src="../images/image-20210112131956527.png" alt="image-20210112131956527"></p>
<p>递归和迭代结合：</p>
<p><img src="../images/image-20210112132617854.png" alt="image-20210112132617854"></p>
<p>主机向本地 DNS 服务器查询是递归，本地 DNS 向其他 DNS 查询是迭代</p>
<p>域名解析过程如下：</p>
<p>1、客户机发送 DNS 请求报文，以 UDP 数据报的形式发送到本地 DNS 服务器</p>
<p>2、本地 DNS 收到后，先查缓存，如果没有，自己扮演 DNS 客户，向根域名服务器发送解析请求</p>
<p>3、根 DNS 服务器收到后，判断一下属于哪个顶级域名服务器，将对应的 IP 地址发来，说，你去找他，他知道</p>
<p>4、本地 DNS 服务器向顶级域名服务器发送解析请求</p>
<p>5、顶级收到后，判断一下属于哪个授权域名服务器，将对应的 IP 地址发来，说，你去找他，他知道</p>
<p>6、本地向授权发送请解析请求</p>
<p>7、授权收到之后会将解析结果发回本地域名服务器</p>
<p>8、本地把查询结果存到缓存，并发给客户端</p>
<h3 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议 FTP"></a>文件传输协议 FTP</h3><p>21 端口，C/S 模型，使用 TCP，有两个并行的 TCP 连接，一个控制连接进程（21），一个数据连接进程（20）</p>
<p>客户端有传输请求的时候才会创建数据连接进程 </p>
<p>功能：</p>
<p>1、在不同种类操作系统之家传输文件（屏蔽了操作系统的细节）</p>
<p>2、通过用户权限控制管理用户行为</p>
<p>3、可以用匿名 FTP 方式提供公用文件的共享能力</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>80 端口、无状态</p>
<p>使用 TCP进行可靠的传输</p>
<p>输入 URL 之后发生的事情：</p>
<p>1、浏览器分析 URL ，然后请求域名解析获得 IP 地址</p>
<p>2、与服务器建立 TCP 连接，然后发送 HTTP 请求</p>
<p>3、服务器对浏览请求进行处理，通过 HTTP 响应返回信息给浏览器</p>
<p>4、关闭连接</p>
<p>5、浏览器渲染页面</p>
<p>HTTP/1.1 支持长连接，分两种：</p>
<p>1、非流水线。收到前一个的响应之后才能发请求</p>
<p>2、流水线。发现对象引用就发请求</p>
<h4 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h4><ul>
<li>  请求报文</li>
<li>  响应报文</li>
</ul>
<p>组成：开始行、首部行、实体主体</p>
<p>请求报文和响应报文仅开始行不同</p>
<ul>
<li>  开始行：有三个字段，请求行是请求的方法、URL 以及 HTTP 版本号；响应行是版本、状态码、短语</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>为运行在不同主机上的进程之间提供逻辑通信，屏蔽了低层网络核心的细节，让两个进程认为咱们两个是直接在通信</p>
<h3 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h3><p>让各种应用层的进程把要传输的数据通过端口号向下交付给传输层，以及让传输层（一般指另外一个主机）知道把要传输的数据通过端口号向上交付给应用层的有关进程。</p>
<p>其实就是一个标识作用，让应用层知道该把数据通过哪个端口给传输层，传输层根据这个端口号把数据给应用层的相关进程。</p>
<p>端口号有 16 位，所以最大是 65536 - 1 = 65535</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>实际上是一个通信端点，即 套接字 = (主机 IP 地址, 端口号)，它可以唯一标识一台主机的一个应用（进程）</p>
<p>通常用C/S架构</p>
<p>只允许交换无结构的字节流</p>
<h4 id="面向连接和无连接"><a href="#面向连接和无连接" class="headerlink" title="面向连接和无连接"></a>面向连接和无连接</h4><p>面向连接：就是要求通信双方在通信之前必须要建立连接，也就是 <code>建立连接 -&gt; 开始通信 -&gt; 通信结束，关闭连接</code></p>
<p>无连接：通信双方不需要事先建立连接，如果需要通信，直接将信息发送到网络，让该信息的传递在网上尽力而为地往目的地传送。</p>
<p>TCP</p>
<ul>
<li>  面向连接（传送数据前需要建立连接）</li>
<li>  全双工</li>
<li>  没有广播和组播</li>
<li>  用于可靠性更重要的场合，如 FTP，HTTP，Telnet远程登录</li>
</ul>
<p>UDP</p>
<ul>
<li>  无连接，不可靠</li>
<li>  收到 UDP 数据报之后不需要给出确认报文</li>
<li>  执行速度快，实时性好，如 DNS，RTP（实时传输协议）</li>
</ul>
<h3 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h3><h4 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h4><p><strong>优点：</strong></p>
<p>1、无需建立连接，不会引入建立连接的时延</p>
<p>2、无连接。不需要维护连接状态，一般可以支持更多的活动客户机</p>
<p>3、分组首部开销小。仅有 8B 的开销（TCP 有 20B）</p>
<p>4、可以更好地控制发送的数据和发送时间。没有拥塞控制，网络中的拥塞不会影响主机的发送效率。</p>
<p><strong>常用场景</strong></p>
<ul>
<li>  一次性传输较少数据的网络应用，如 DNS，SNMP</li>
<li>  多媒体应用（IP 电话，实时视频会议，流媒体等）</li>
</ul>
<p>不保证可靠交换，所以维护传输可靠性的工作需要用户在<strong>应用层</strong>完成</p>
<p>面向报文。发送方 UDP 对应用层传下来的报文，仅仅是添加一个首部就交给 IP 层，别的啥也不干</p>
<p><strong>首部格式</strong></p>
<p>UDP 数据报包括：UDP 首部和用户数据</p>
<p>首部有四个字段：源端口、目的端口、数据报长度（包含首部和数据）、校验和</p>
<h4 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h4><p>在不可靠的 IP 层之上实现的可靠的数据传输协议</p>
<p>解决的问题：传输的可靠、有序、无重复和不丢失问题</p>
<p><strong>特点</strong></p>
<p>1、面向连接的</p>
<p>2、一个 TCP 连接只能有两个端点，每条 TCP 连接只能是点对点的</p>
<p>3、提供可靠的交付，保证数据无差错、不丢失、不重复、有序</p>
<p>4、全双工通信。TCP 两端都有缓存，用来临时存放通信数据</p>
<ul>
<li>  发送缓存：发送应用程序传送给发送放 TCP要发送的数据、TCP 已发送但是未收到确认的数据</li>
<li>  接收缓存：按序到达但未被接收方应用程序读取的数据、不按序到达的数据</li>
</ul>
<p>5、面向字节的。</p>
<p><strong>首部格式</strong></p>
<p>一个 TCP 报文段分为 TCP 首部和 TCP 数据两部分，整个报文段被封装在 IP 数据报的数据部分</p>
<p>TCP 报文段用途：</p>
<ul>
<li>  运载数据</li>
<li>  建立连接</li>
<li>  释放连接</li>
<li>  应答</li>
</ul>
<p><strong>结构示意图</strong></p>
<p><img src="../images/6-19110Q62344I5.gif" alt="img"></p>
<p><img src="../images/image-20210128212948575.png" alt="image-20210128212948575"></p>
<blockquote>
<p>  图片来源：<a href="http://c.biancheng.net/view/6441.html">http://c.biancheng.net/view/6441.html</a></p>
<p>  <a href="https://blog.csdn.net/lqglqglqg/article/details/48850029">https://blog.csdn.net/lqglqglqg/article/details/48850029</a></p>
</blockquote>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>每个 TCP 连接都有三个阶段：建立连接、数据传送、连接释放</p>
<p>TCP 连接需要解决三个问题：</p>
<p>1、要使发送双方都知道对方的存在</p>
<p>2、要允许双方协议一些参数（如最大窗口值，是否使用窗口扩大选项，时间戳服务及服务质量）</p>
<p>3、能够对运输实体资源进行分配</p>
<p>TCP 连接的端口是套接字（IP 地址 + 端口）</p>
<p>每条 TCP 连接可以由通信两端的两个端点确定。</p>
<p>TCP 连接的建立采用 C/S 模式</p>
<p><img src="../images/d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpeg" alt="img"></p>
<p>服务端的资源是在第二次握手时分配的（容易遭到 SYN 泛红攻击）</p>
<p>客户端的资源是在第三次握手的时候建立的</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>当 FIN 段被另 一方确认后，这个方向上的连接就被关闭，不再发送任何数据。然而，另一个方向上或许还在继续着无限的数据流。当两个方向都关闭后，连接才算被彻底释放</p>
<p>为了避免两军对垒问题，需要使用计时器。如果在两倍于最大数据包生存期内，针对 FIN 的响应没有出现，那么 FIN 的发送端直接释放连接</p>
<p><img src="../images/48540923dd54564e5260495ce0006487d0584fb6.jpeg" alt="img"></p>
<p>TCP 有限状态机的状态：</p>
<p><img src="../images/image-20210128212137505.png" alt="image-20210128212137505"></p>
<h4 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h4><p>保证接收方进程从缓存区读出的字节流与发送方发出的字节流完全一致</p>
<p>使用的机制：校验、序号、确认、重传</p>
<p>1、序号</p>
<p>TCP 首部的序号字段保证数据能有序提交给应用层，序号值是本报文要发送的第一个字节的序号</p>
<p>2、确认</p>
<p>确认号是希望收到对方的下一个报文段的数据的第一个字节的序号。</p>
<p>3、重传</p>
<p>重传条件：超时和冗余 ACK</p>
<p>（1）超时</p>
<p>每发送一个报文段，就对这个报文设置一次计时器。如果计时器设置的重传时间到期但还没有收到确认，就必须重传。（RTT：报文往返一趟的时间）</p>
<p>（2）冗余确认</p>
<p>当收到三个 ACK 的时候，必须重传该报文。</p>
<p>比如，1、2、3、4、5，五个报文发出去，但是2号丢了。<strong>TCP 规定每当比期望序号大的失序报文到达时，就要发送一个冗余 ACK，指明期待收到的下一个报文序号。</strong>所以会发送3个1号报文的冗余ACK，必须重传。</p>
<h4 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h4><p>避免发送方发送的数据大于接收方缓存，从而导致数据丢失。</p>
<p>滑动窗口协议</p>
<p><img src="../images/image-20210128214226394.png" alt="image-20210128214226394"></p>
<blockquote>
<p>例如，假设接收端有一个 4096 字节的缓冲区，如图 6-40 所示。如果发送端传送了一个2048字节的数据段，并且该数据段已被正确地接收，那么接收方将确认该数据段；然而，由于接收端现在只剩下2048字节的缓冲区空间（在应用程序从缓存区取走数据之前），所以它将宣告下一个期望字节开始窗口为 2048。</p>
</blockquote>
<p>接收方根据自己接收缓存的大小，动态调整发送方的发送窗口大小，这是接收窗口 rwnd</p>
<p>发送方根据自己对当前网络拥塞程度估计而确定的窗口值，这是拥塞窗口 cwnd。</p>
<h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h4><p>防止过多的数据注入网络，保证网络中的路由器或者链路不至于过载。</p>
<p>4种算法：慢开始、拥塞避免、快重传、快恢复</p>
<p>1、慢开始算法</p>
<p>拥塞窗口指数级别增长，最开始是1，然后是2、4、8……</p>
<p>达到规定的慢开始阈值之后，改用拥塞避免算法</p>
<p>2、拥塞避免算法</p>
<p>每次增加1，线性增长</p>
<p>如果出现拥塞，把慢开始的阈值设置为发生拥塞时的发送方的 cwnd 的一半，然后把拥塞窗口设置成1，重新慢开始（这样做是为了迅速减少主机发送到网络中的分组数，使发生拥塞的路由器把积压的分组处理完）</p>
<p><img src="../images/image-20210128220140738.png" alt="image-20210128220140738"></p>
<p>3、快重传</p>
<p>收到三个冗余 ACK 就必须重传</p>
<p>4、快恢复（因为跳过了慢开始阶段）</p>
<p>收到三个冗余 ACK，把慢开始的阈值设置为发生拥塞时的发送方的 cwnd 的一半，然后把拥塞窗口设置成这个阈值，然后执行拥塞避免算法</p>
<p><img src="../images/image-20210128220441976.png" alt="image-20210128220441976"></p>
<p>在流量控制中，发送方发送数据的量由接收方决定，而在拥塞控制中，则由发送方自己通过检测网络状况来决定。</p>
<p>实际上，慢开始、拥塞避免、快重传和快恢复几种算法应是同时应用在拥塞控制机制之中的，当发送方检测到超时的时候，就采用慢开始和拥塞避免，当发送方按收到冗余 ACK 时,就采用快重传和快恢复。</p>
<p>发送方发送窗口的实际大小由流量控制和拥塞控制共同决定。因此，当同时出现接收端窗口（rwnd）和拥塞窗口(cwnd）时，发送方实际的发送窗口大小是由 rwnd 和 cwnd 中较小的那一个确定的。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/archives/364ea8cc.html</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h2><ul>
<li>  <strong>开闭原则</strong>：对修改封闭，对扩展开放。</li>
<li>  <strong>单一职责原则</strong>：一个类只做一件事，一个类应该只有一个引起它修改的原因。</li>
<li>  <strong>里氏替换原则</strong>：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。</li>
<li><strong>依赖倒置原则</strong>：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。<ul>
<li>  变量不可以持有具体类的引用</li>
<li>  不要让类派生自具体类</li>
<li>  不要覆盖基类中已实现的方法</li>
</ul>
</li>
<li>  <strong>迪米特法则</strong>：又名“最少知道原则”，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。</li>
<li>  <strong>接口隔离原则</strong>：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。</li>
</ul>
<span id="more"></span>

<p>接口：接口是一个概念，是超类型，比如抽象类和接口。这样我们声明的时候不需要管以后执行时的真实对象类型。</p>
<h2 id="Head-First-设计原则"><a href="#Head-First-设计原则" class="headerlink" title="Head First 设计原则"></a>Head First 设计原则</h2><ul>
<li>  找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起</li>
<li>  针对接口编程，而不是针对实现编程</li>
<li>  多用组合，少用继承</li>
<li>  l类应该对修改封闭，对扩展开放</li>
<li>  要依赖抽象，不要依赖具体类</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>创建型、结构型、行为型</p>
<h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a><strong>饿汉式</strong></h4><p>变量在声明时便初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a><strong>懒汉式</strong></h4><p>先声明一个空变量，需要用时才初始化。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单锁"><a href="#单锁" class="headerlink" title="单锁"></a><strong>单锁</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双锁"><a href="#双锁" class="headerlink" title="双锁"></a><strong>双锁</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM 底层为了优化程序运行效率，可能会对我们的代码进行指令重排序，在一些特殊情况下会导致出现空指针，为了防止这个问题，更进一步的优化是给 instance 变量加上 <strong>volatile</strong> 关键字。</p>
<p>问：双检锁单例模式中，volatile 主要用来防止哪几条指令重排序？如果发生了重排序，会导致什么样的错误？</p>
<p>答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure>

<p>这一行代码中，执行了三条重要的指令：</p>
<ul>
<li>  分配对象的内存空间</li>
<li>  初始化对象</li>
<li>  将变量 instance 指向刚分配的内存空间</li>
</ul>
<p>在这个过程中，如果第二条指令和第三条指令发生了重排序，可能导致 instance 还未初始化时，其他线程提前通过双检锁外层的 null 检查，获取到“不为 null，但还没有执行初始化”的 instance 对象，发生空指针异常。</p>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a><strong>内部类</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h3><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p>定义一个类，类里面有个 <code>create</code> 静态方法，根据传递的参数不同来创建不同的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">create</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;苹果&quot;</span>: <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;梨子&quot;</span>: <span class="keyword">return</span> <span class="keyword">new</span> Pear();</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;暂时没有这种水果&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><blockquote>
<p>  <strong>定义</strong>：工厂方法定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p>
<p>  让子类决定该创建什么样的对象，以此达到将对象的创建过程封装的目的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Fruit <span class="title">create</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Fruit <span class="title">create</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实，水果本身也是抽象的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="comment">// 一些代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用继承</p>
<p>工厂方法声明为抽象的，让子类去实现</p>
<h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><blockquote>
<p>  抽象工厂提供一个接口，用于创建相关或依赖对象的家族，而不需要指明具体的类</p>
</blockquote>
<p>抽象工厂的方法经常以工厂方法的方式实现。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><blockquote>
<p>  原型模式：<strong>复制现有的实例来创建新的实例</strong></p>
</blockquote>
<p>Java 里重写 clone 方法即可，或者反序列化</p>
<p>Java 自带的 clone 方法是浅拷贝的。就是说只有基本类型的参数会被拷贝一份，非基本类型的对象不会被拷贝一份，而是继续使用传递引用的方式。如果需要实现深拷贝，必须要自己手动修改 clone 方法才行。</p>
<p>优点：</p>
<ul>
<li>  客户不需要知道对象内部的复杂性</li>
<li>  部分时候，复制比创建一个新对象更优秀（但有时也很复杂）</li>
</ul>
<h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><blockquote>
<p>  适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
</blockquote>
<h3 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 Proxy"></a>代理模式 Proxy</h3><blockquote>
<p>  代理模式：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p>
</blockquote>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><blockquote>
<p>  不修改底层代码，赋予对象新的职责。</p>
</blockquote>
<p>特点：</p>
<ul>
<li>  装饰者和被装饰者有相同的超类型</li>
<li>  可以有多个装饰者</li>
<li>  装饰者可以有自己的行为</li>
<li>  对象可以在任何时候被装饰</li>
<li>  把被装饰的对象作为参数传递给装饰者</li>
</ul>
<p>实现：一般使用抽象类继承的方式，但是也可以用 Java 的接口</p>
<p>新建颜值接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBeauty</span> </span>&#123;    <span class="function"><span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<p>新建 Me 类，实现颜值接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Me</span> <span class="keyword">implements</span> <span class="title">IBeauty</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="number">100</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>戒指装饰类，将 Me 包装起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RingDecorator</span> <span class="keyword">implements</span> <span class="title">IBeauty</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">final</span> IBeauty me;    <span class="function"><span class="keyword">public</span> <span class="title">RingDecorator</span><span class="params">(IBeauty me)</span> </span>&#123;        <span class="keyword">this</span>.me = me;    &#125;        <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> me.getBeautyValue() + <span class="number">20</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>客户端测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;        IBeauty me = <span class="keyword">new</span> Me();        System.out.println(<span class="string">&quot;我原本的颜值：&quot;</span> + me.getBeautyValue());        IBeauty meWithRing = <span class="keyword">new</span> RingDecorator(me);        System.out.println(<span class="string">&quot;戴上了戒指后，我的颜值：&quot;</span> + meWithRing.getBeautyValue());    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，输出如下：</p>
<p>我原本的颜值：100<br>戴上了戒指后，我的颜值：120<br>这就是最简单的增强功能的装饰模式。以后我们可以添加更多的装饰类，比如：</p>
<p>耳环装饰类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EarringDecorator</span> <span class="keyword">implements</span> <span class="title">IBeauty</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">final</span> IBeauty me;    <span class="function"><span class="keyword">public</span> <span class="title">EarringDecorator</span><span class="params">(IBeauty me)</span> </span>&#123;        <span class="keyword">this</span>.me = me;    &#125;        <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> me.getBeautyValue() + <span class="number">50</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>项链装饰类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NecklaceDecorator</span> <span class="keyword">implements</span> <span class="title">IBeauty</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">final</span> IBeauty me;    <span class="function"><span class="keyword">public</span> <span class="title">NecklaceDecorator</span><span class="params">(IBeauty me)</span> </span>&#123;        <span class="keyword">this</span>.me = me;    &#125;        <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> me.getBeautyValue() + <span class="number">80</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>客户端测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;        IBeauty me = <span class="keyword">new</span> Me();        System.out.println(<span class="string">&quot;我原本的颜值：&quot;</span> + me.getBeautyValue());    <span class="comment">// 随意挑选装饰    IBeauty meWithNecklace = new NecklaceDecorator(me);    System.out.println(&quot;戴上了项链后，我的颜值：&quot; + meWithNecklace.getBeautyValue());    // 多次装饰    IBeauty meWithManyDecorators = new NecklaceDecorator(new RingDecorator(new EarringDecorator(me)));    System.out.println(&quot;戴上耳环、戒指、项链后，我的颜值：&quot; + meWithManyDecorators.getBeautyValue());    // 任意搭配装饰    IBeauty meWithNecklaceAndRing = new NecklaceDecorator(new RingDecorator(me));    System.out.println(&quot;戴上戒指、项链后，我的颜值：&quot; + meWithNecklaceAndRing.getBeautyValue());&#125;</span></span><br></pre></td></tr></table></figure>

<p>}<br>运行程序，输出如下：</p>
<p>我原本的颜值：100<br>戴上了项链后，我的颜值：180<br>戴上耳环、戒指、项链后，我的颜值：250<br>戴上戒指、项链后，我的颜值：200</p>
<blockquote>
<p>  作者：力扣 (LeetCode)<br>  链接：<a href="https://leetcode-cn.com/leetbook/read/design-patterns/99j7re/">https://leetcode-cn.com/leetbook/read/design-patterns/99j7re/</a><br>  来源：力扣（LeetCode）</p>
</blockquote>
<h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote>
<p>  策略模式（Strategy Pattern）：定义了一系列算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p>
</blockquote>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><blockquote>
<p>  模板方法模式（Template Method Pattern）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Dropwizard学习笔记</title>
    <url>/archives/8125fdfd.html</url>
    <content><![CDATA[<h1 id="Dropwizard是什么？"><a href="#Dropwizard是什么？" class="headerlink" title="Dropwizard是什么？"></a>Dropwizard是什么？</h1><p>一个用于开发操作友好、高性能、RESTful Web 服务的 <strong>Java 框架</strong></p>
<blockquote>
<p>Dropwizard 将Java 生态系统中稳定、成熟的库整合到一个 简单、轻量级的包中，让您可以专注于完成工作。</p>
<p>Dropwizard对复杂的配置、 应用程序指标、日志记录、操作工具等提供开箱即用的支持，使您和您的团队能够在尽可能短的时间内提供生产质量的Web 服务。</p>
</blockquote>
<p>官网：<a href="https://www.dropwizard.io/en/latest/">https://www.dropwizard.io/en/latest/</a></p>
<span id="more"></span>



<h2 id="几个重要的组件"><a href="#几个重要的组件" class="headerlink" title="几个重要的组件"></a>几个重要的组件</h2><h3 id="Jetty-for-HTTP"><a href="#Jetty-for-HTTP" class="headerlink" title="Jetty for HTTP"></a>Jetty for HTTP</h3><p>使用Jetty HTTP 库将一个经过优化的 HTTP 服务器直接嵌入到项目中</p>
<h3 id="Jersey-for-REST"><a href="#Jersey-for-REST" class="headerlink" title="Jersey for REST"></a>Jersey for REST</h3><p>将 HTTP 请求映射到简单的 Java 对象。</p>
<p>支持流输出、矩阵 URI 参数、条件GET请求等等</p>
<h3 id="Jackson-for-JSON"><a href="#Jackson-for-JSON" class="headerlink" title="Jackson for JSON"></a>Jackson for JSON</h3><h3 id="Metrics-for-metrics"><a href="#Metrics-for-metrics" class="headerlink" title="Metrics for metrics"></a>Metrics for metrics</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>日志：<a href="https://logback.qos.ch/">Logback</a>和<a href="https://www.slf4j.org/">slf4j</a></p>
<p><a href="http://hibernate.org/validator/">Hibernate Validator</a></p>
<p>等等</p>
<h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><h2 id="1、使用Maven生成项目"><a href="#1、使用Maven生成项目" class="headerlink" title="1、使用Maven生成项目"></a>1、使用Maven生成项目</h2><h2 id="2、基本的依赖"><a href="#2、基本的依赖" class="headerlink" title="2、基本的依赖"></a>2、基本的依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dropwizard.version</span>&gt;</span>2.0.22<span class="tag">&lt;/<span class="name">dropwizard.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql-connector.version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">mysql-connector.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.dropwizard/dropwizard-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.dropwizard<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dropwizard-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dropwizard.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- mysql --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3、创建配置类"><a href="#3、创建配置类" class="headerlink" title="3、创建配置类"></a>3、创建配置类</h2><p>每个 Dropwizard 应用程序都有自己的<code>Configuration</code>类，用于指定特定于环境的参数。这些参数在YAML配置文件中指定，该文件会被加载，然后被反序列化为应用程序配置类的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloConfiguration</span> <span class="keyword">extends</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String defaultName = <span class="string">&quot;Stranger&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTemplate</span><span class="params">(String template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDefaultName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defaultName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultName = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个类会从 YAML 文件中反序列化，会去找两个跟级字段：<code>template</code>以及<code>defaultName</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">template:</span> <span class="string">Hello,</span> <span class="string">%s!</span> <span class="comment"># %s 是占位符，这里相当于一个模板字符串</span></span><br><span class="line"><span class="attr">defaultName:</span> <span class="string">Stranger</span></span><br></pre></td></tr></table></figure>

<p>这个文件要放在项目根目录下面</p>
<h2 id="4、创建一个Application类"><a href="#4、创建一个Application类" class="headerlink" title="4、创建一个Application类"></a>4、创建一个Application类</h2><p>必须要重写 <code>run</code> 方法（这个方法是抽象方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApplication</span> <span class="keyword">extends</span> <span class="title">Application</span>&lt;<span class="title">HelloConfiguration</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HelloWorldApplication().run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Bootstrap&lt;HelloConfiguration&gt; bootstrap)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(HelloConfiguration helloConfiguration, Environment environment)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、创建DAO类（pojo"><a href="#5、创建DAO类（pojo" class="headerlink" title="5、创建DAO类（pojo)"></a>5、创建DAO类（pojo)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Saying</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Saying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Saying</span><span class="params">(<span class="keyword">long</span> id, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6、创建Resource类"><a href="#6、创建Resource类" class="headerlink" title="6、创建Resource类"></a>6、创建Resource类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Path(&quot;/get&quot;)</span></span><br><span class="line"><span class="meta">@Produces(MediaType.APPLICATION_JSON)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String tempalte;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String defaultName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloResource</span><span class="params">(String tempalte, String defaultName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tempalte = tempalte;</span><br><span class="line">        <span class="keyword">this</span>.defaultName = defaultName;</span><br><span class="line">        <span class="keyword">this</span>.counter = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Saying <span class="title">sayHello</span><span class="params">(<span class="meta">@QueryParam(&quot;name&quot;)</span>Optional&lt;String&gt; name)</span></span>&#123;</span><br><span class="line">        String value = String.format(tempalte, name.orElse(defaultName));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Saying(counter.incrementAndGet(), value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、注册Resource类使其生效"><a href="#7、注册Resource类使其生效" class="headerlink" title="7、注册Resource类使其生效"></a>7、注册Resource类使其生效</h2><p>在Application类中注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelloWorldApplication</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(HelloConfiguration configuration, Environment env)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// new 一个对象</span></span><br><span class="line">    HelloResource helloResource = <span class="keyword">new</span> HelloResource(configuration.getTemplate(), configuration.getDefaultName());</span><br><span class="line">    <span class="comment">// 注册到应用程序的 Jersey 环境</span></span><br><span class="line">    env.jersey().register(helloResource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8、启动"><a href="#8、启动" class="headerlink" title="8、启动"></a>8、启动</h2><p>命令行启动：</p>
<p>命令行启动的话需要把配置文件放在<strong>子工程</strong>的根目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入子工程根目录</span></span><br><span class="line">java -jar target/01-HelloWorld-1.0-SNAPSHOT.jar server hello.yml</span><br></pre></td></tr></table></figure>



<p>IDEA启动：</p>
<p>需要把配置文件放在<strong>父工程</strong>的根目录</p>
<p><img src="../images/image-20210619134441719.png" alt="image-20210619134441719"></p>
<p>也可以在命令中指定配置文件路径</p>
<p><img src="../images/image-20210619134554883.png" alt="image-20210619134554883"></p>
<h2 id="9、测试"><a href="#9、测试" class="headerlink" title="9、测试"></a>9、测试</h2><p><img src="../images/image-20210619134648237.png" alt="image-20210619134648237"></p>
<h1 id="Dropwizard-Core"><a href="#Dropwizard-Core" class="headerlink" title="Dropwizard Core"></a>Dropwizard Core</h1><h2 id="提供了什么？"><a href="#提供了什么？" class="headerlink" title="提供了什么？"></a>提供了什么？</h2><ul>
<li>Jetty，一个高性能的 HTTP 服务器。</li>
<li>Jersey，一个功能齐全的 RESTful Web 框架。</li>
<li>Jackson，JVM 的最佳 JSON 库。</li>
<li>Metrics，一个优秀的应用程序度量库。</li>
<li>Logback，Log4j 的继承者，Java 使用最广泛的日志框架。</li>
<li>Hibernate Validator，Java Bean 验证标准的参考实现。</li>
</ul>
<p>官方建议把项目分成三个模块：<code>project-api</code>，<code>project-client</code>，和 <code>project-application</code>。</p>
<p>api：简单的Java bean</p>
<p>client：处理HTTP请求</p>
<p>application：应用类</p>
<h2 id="日志功能"><a href="#日志功能" class="headerlink" title="日志功能"></a>日志功能</h2><p>Dropwizard 使用<a href="http://logback.qos.ch/">Logback</a>作为其日志记录后端。它提供了一个<a href="http://www.slf4j.org/">slf4j</a>实现</p>
<p>slf4j 提供以下日志级别：</p>
<ul>
<li><code>ERROR</code>：可能仍允许应用程序继续运行的错误事件。</li>
<li><code>WARN</code>：可能有害的情况。</li>
<li><code>INFO</code>：在粗粒度级别突出显示应用程序进度的信息性消息。</li>
<li><code>DEBUG</code>：对调试应用程序最有用的细粒度信息事件。</li>
<li><code>TRACE</code>：比<code>DEBUG</code>级别更细粒度的信息事件。</li>
</ul>
<p>如果不想使用可以排除，具体参考：<a href="https://www.dropwizard.io/en/latest/manual/core.html">https://www.dropwizard.io/en/latest/manual/core.html</a></p>
<p>日志保存到文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">appenders:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">file</span></span><br><span class="line">      <span class="comment"># The file to which current statements will be logged.</span></span><br><span class="line">      <span class="attr">currentLogFilename:</span> <span class="string">./logs/example.log</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># When the log file rotates, the archived log will be renamed to this and gzipped. The</span></span><br><span class="line">      <span class="comment"># %d is replaced with the previous day (yyyy-MM-dd). Custom rolling windows can be created</span></span><br><span class="line">      <span class="comment"># by passing a SimpleDateFormat-compatible format as an argument: &quot;%d&#123;yyyy-MM-dd-hh&#125;&quot;.</span></span><br><span class="line">      <span class="attr">archivedLogFilenamePattern:</span> <span class="string">./logs/example-%d.log.gz</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># The number of archived files to keep.</span></span><br><span class="line">      <span class="attr">archivedFileCount:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># The timezone used to format dates. HINT: USE THE DEFAULT, UTC.</span></span><br><span class="line">      <span class="attr">timeZone:</span> <span class="string">UTC</span></span><br></pre></td></tr></table></figure>



<h2 id="Jersey"><a href="#Jersey" class="headerlink" title="Jersey"></a>Jersey</h2><p>一个框架，用于将传入 HTTP 请求的各个方面映射到 POJO，然后将 POJO 的各个方面映射到传出 HTTP 响应。</p>
<h2 id="Servlet-过滤器"><a href="#Servlet-过滤器" class="headerlink" title="Servlet 过滤器"></a>Servlet 过滤器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateNotSpecifiedServletFilter</span> <span class="keyword">implements</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Other methods in interface omitted for brevity</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequest) &#123;</span><br><span class="line">            String dateHeader = ((HttpServletRequest) request).getHeader(HttpHeaders.DATE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dateHeader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                chain.doFilter(request, response); <span class="comment">// This signals that the request should pass this filter</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">                httpResponse.setStatus(HttpStatus.BAD_REQUEST_400);</span><br><span class="line">                httpResponse.getWriter().print(<span class="string">&quot;Date Header was not specified&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将这个 servlet 过滤器包装在自己的 Application 类中<code>FilterHolder</code>并将其添加到应用程序上下文中，并与此过滤器将激活哪些路径的规范一起注册到您的 Application 类中。下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">environment.servlets()</span><br><span class="line">    .addFilter(<span class="string">&quot;DateNotSpecifiedServletFilter&quot;</span>, </span><br><span class="line">               <span class="keyword">new</span> DateNotSpecifiedServletFilter()).addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), <span class="keyword">true</span>, <span class="string">&quot;/*&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ol>
<li>Dropwizard 的所有 API 的设计都考虑到了可测试性，即使应用程序也可以进行单元测试</li>
<li>可以自定义 banner，放在<code>src/main/resources</code>目录下即可</li>
<li>每个资源类都必须有一个<code>@Path</code>注解</li>
<li><code>@Timed</code> 测量对资源请求的持续时间（不能和 <code>@Metered</code> 同时使用</li>
<li><code>@Metered</code> 衡量资源被访问的速率</li>
<li><code>@ResponseMetered</code> 测量每类响应代码的速率（1xx/2xx/3xx/4xx/5xx）</li>
<li><code>@ExceptionMetered</code> 测量处理资源的异常发生的频率</li>
<li>JSON 的一个常见问题是<code>camelCase</code>和<code>snake_case</code>字段名称之间的分歧。Java 和 Javascript 的人往往喜欢<code>camelCase</code>；Ruby、Python 和 Perl 的人坚持使用 <code>snake_case</code>. 要使 Dropwizard 自动将字段名称转换为<code>snake_case</code>（并返回），只需在类上面加注解<code>@JsonSnakeCase</code></li>
<li>返回大量信息，使用流式输出可能会大大提高性能和效率。通过返回一个实现 Jersey<code>StreamingOutput</code> 接口的对象，您的方法可以在块编码的输出流中流式传输响应实体</li>
</ol>
<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>依赖注入机制的底层库是 Eclipse 的<a href="https://github.com/eclipse-ee4j/glassfish-hk2">HK2</a>，推荐 Spring</p>
<h1 id="JDBI"><a href="#JDBI" class="headerlink" title="JDBI"></a>JDBI</h1><p>JDBI是Java的SQL连接处理的便利工具库。它试图以Java中使用集合，bean等来映射关系来访问关系数据库，同时保持与JDBC相同的粒度</p>
<p>要创建<a href="https://www.dropwizard.io/en/latest/manual/core.html#man-core-managed">托管的</a>检测<code>Jdbi</code>实例， <a href="https://www.dropwizard.io/en/latest/manual/core.html#man-core-configuration">配置类</a>需要一个<code>DataSourceFactory</code>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConfiguration</span> <span class="keyword">extends</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> DataSourceFactory database = <span class="keyword">new</span> DataSourceFactory();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;database&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceFactory</span><span class="params">(DataSourceFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.database = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;database&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceFactory <span class="title">getDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> database;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在Application类的<code>run</code>方法中，创建一个新的<code>JdbiFactory</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ExampleConfiguration config, Environment environment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> JdbiFactory factory = <span class="keyword">new</span> JdbiFactory();</span><br><span class="line">    <span class="keyword">final</span> Jdbi jdbi = factory.build(environment, config.getDataSourceFactory(), <span class="string">&quot;postgresql&quot;</span>);</span><br><span class="line">    environment.jersey().register(<span class="keyword">new</span> UserResource(jdbi));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将创建一个到数据库的新<a href="https://www.dropwizard.io/en/latest/manual/core.html#man-core-managed">托管</a>连接池、一个用于连接到数据库的 <a href="https://www.dropwizard.io/en/latest/manual/core.html#man-core-healthchecks">运行状况检查</a>以及一个<code>Jdbi</code> 供您使用的新实例。</p>
<p>配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">database:</span></span><br><span class="line">  <span class="comment"># the name of your JDBC driver</span></span><br><span class="line">  <span class="attr">driverClass:</span> <span class="string">org.postgresql.Driver</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the username</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">pg-user</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the password</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">iAMs00perSecrEET</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the JDBC URL</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">jdbc:postgresql://db.example.com/db-prod</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># any properties specific to your JDBC driver:</span></span><br><span class="line">  <span class="attr">properties:</span></span><br><span class="line">    <span class="attr">charSet:</span> <span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the maximum amount of time to wait on an empty pool before throwing an exception</span></span><br><span class="line">  <span class="attr">maxWaitForConnection:</span> <span class="string">1s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the SQL query to run when validating a connection&#x27;s liveness</span></span><br><span class="line">  <span class="attr">validationQuery:</span> <span class="string">&quot;/* MyService Health Check */ SELECT 1&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the timeout before a connection validation queries fail</span></span><br><span class="line">  <span class="attr">validationQueryTimeout:</span> <span class="string">3s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the minimum number of connections to keep open</span></span><br><span class="line">  <span class="attr">minSize:</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the maximum number of connections to keep open</span></span><br><span class="line">  <span class="attr">maxSize:</span> <span class="number">32</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># whether or not idle connections should be validated</span></span><br><span class="line">  <span class="attr">checkConnectionWhileIdle:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the amount of time to sleep between runs of the idle connection validation, abandoned cleaner and idle pool resizing</span></span><br><span class="line">  <span class="attr">evictionInterval:</span> <span class="string">10s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the minimum amount of time an connection must sit idle in the pool before it is eligible for eviction</span></span><br><span class="line">  <span class="attr">minIdleTime:</span> <span class="number">1</span> <span class="string">minute</span></span><br></pre></td></tr></table></figure>



<p>建议使用 JDBI 的<a href="http://jdbi.org/#_sql_objects">SQL Objects API</a>，它允许将 DAO 类编写为接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDAO</span> </span>&#123;</span><br><span class="line">  <span class="meta">@SqlUpdate(&quot;create table something (id int primary key, name varchar(100))&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">createSomethingTable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SqlUpdate(&quot;insert into something (id, name) values (:id, :name)&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="meta">@Bind(&quot;id&quot;)</span> <span class="keyword">int</span> id, <span class="meta">@Bind(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SqlQuery(&quot;select name from something where id = :id&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">findNameById</span><span class="params">(<span class="meta">@Bind(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MyDAO dao = database.onDemand(MyDAO.class);</span><br></pre></td></tr></table></figure>

<h1 id="Dropwizard-Hibernate"><a href="#Dropwizard-Hibernate" class="headerlink" title="Dropwizard Hibernate"></a>Dropwizard Hibernate</h1><h2 id="1、需要一个DataSourceFactory-实例"><a href="#1、需要一个DataSourceFactory-实例" class="headerlink" title="1、需要一个DataSourceFactory 实例"></a>1、需要一个<code>DataSourceFactory</code> 实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hibernate 配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateConfiguration</span> <span class="keyword">extends</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> DataSourceFactory database = <span class="keyword">new</span> DataSourceFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从配置文件中解析 database</span></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;database&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceFactory <span class="title">getDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> database;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;database&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceFactory</span><span class="params">(DataSourceFactory dataSourceFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.database = dataSourceFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、在应用类中注册这个实例"><a href="#2、在应用类中注册这个实例" class="headerlink" title="2、在应用类中注册这个实例"></a>2、在应用类中注册这个实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateApplication</span> <span class="keyword">extends</span> <span class="title">Application</span>&lt;<span class="title">HibernateConfiguration</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须实现 main 方法，声明这是个主类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HibernateApplication().run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个 hibernate 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HibernateBundle&lt;HibernateConfiguration&gt; hibernate = <span class="keyword">new</span> HibernateBundle&lt;HibernateConfiguration&gt;(Person.class) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DataSourceFactory <span class="title">getDataSourceFactory</span><span class="params">(HibernateConfiguration configuration)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> configuration.getDataSourceFactory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Bootstrap&lt;HibernateConfiguration&gt; bootstrap)</span> </span>&#123;</span><br><span class="line">        bootstrap.addBundle(hibernate);<span class="comment">// 在初始化加载器里注册 hibernate</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(HibernateConfiguration hibernateConfiguration, Environment environment)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在上下文环境中注册 resource 和 dao</span></span><br><span class="line">        <span class="keyword">final</span> PersonDAO dao = <span class="keyword">new</span> PersonDAO(hibernate.getSessionFactory());</span><br><span class="line">        environment.jersey().register(<span class="keyword">new</span> PersonResource(dao));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实体类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;person&quot;)</span></span><br><span class="line"><span class="meta">@NamedQueries(&#123;</span></span><br><span class="line"><span class="meta">        @NamedQuery(name = &quot;dao.Person.findAll&quot;, query = &quot;select p from Person p&quot;),</span></span><br><span class="line"><span class="meta">        @NamedQuery(name = &quot;dao.Person.findById&quot;, query = &quot;select p from Person p where p.id = ?1&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实体类对应的 DAO类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDAO</span> <span class="keyword">extends</span> <span class="title">AbstractDAO</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonDAO</span><span class="params">(SessionFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 id 查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">create</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> persist(person).getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找全部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list((CriteriaQuery&lt;Person&gt;) namedQuery(<span class="string">&quot;dao.Person.findAll&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>AbstractDAO</code>：一个用于特定于实体的 DAO 类的最小模板。它包含用于<code>SessionFactory</code>的常见操作的类型安全包装器</p>
<p>配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">database:</span></span><br><span class="line">  <span class="comment"># the name of the JDBC driver, mysql in our case</span></span><br><span class="line">  <span class="attr">driverClass:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="comment"># the username</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">  <span class="comment"># the password</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="comment"># the JDBC URL; the database is called DWGettingStarted</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/dropwizard?serverTimezone=CST</span></span><br><span class="line">  <span class="comment"># Hibernate properties</span></span><br><span class="line">  <span class="attr">properties:</span></span><br><span class="line">    <span class="attr">hibernate.dialect:</span> <span class="string">org.hibernate.dialect.MySQL5Dialect</span></span><br><span class="line">    <span class="attr">hibernate.hbm2ddl.auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">hibernate.format_sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">hibernate.show_sql:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="comment"># The default level of all loggers. Can be OFF, ERROR, WARN, INFO, DEBUG, TRACE, or ALL.</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">INFO</span></span><br></pre></td></tr></table></figure>

<h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>实现 resource 类，在应用类中配置 resource 类（上面配置过了），然后启动服务，打开浏览器在浏览器中请求（先启动应用，会自动生成表，然后插一条数据再请求）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Path(value = &quot;/person&quot;)</span></span><br><span class="line"><span class="meta">@Produces(MediaType.APPLICATION_JSON)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonDAO dao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonResource</span><span class="params">(PersonDAO dao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dao = dao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="meta">@Path(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Timed</span></span><br><span class="line">    <span class="meta">@UnitOfWork</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">findPerson</span><span class="params">(<span class="meta">@PathParam(&quot;id&quot;)</span> LongParam id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao.findById(id.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210630235119575.png" alt="image-20210630235119575"></p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="../images/image-20210701152901517.png" alt="image-20210701152901517"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Dropwizard</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Dropwizard</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA学习笔记</title>
    <url>/archives/4ac63db6.html</url>
    <content><![CDATA[<h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p>JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体<a href="https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96/7316192">对象持久化</a>到数据库中。 </p>
<span id="more"></span>

<p>Sun引入新的JPA ORM规范出于两个原因：其一，简化现有Java EE和Java SE应用开发工作；其二，Sun希望整合ORM技术，实现天下归一。</p>
<p>JPA包括以下3方面的技术：</p>
<p><strong>ORM映射元数据</strong></p>
<p>JPA支持XML和<a href="https://baike.baidu.com/item/JDK">JDK</a>5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体<a href="https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96">对象持久化</a>到数据库表中；</p>
<p><strong>API</strong></p>
<p>用来操作实体对象，执行CRUD操作，框架在后台替代我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。</p>
<p><strong>查询语言</strong></p>
<p>这是持久化操作中很重要的一个方面，通过<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。</p>
<p>JPA是需要Provider来实现其功能的，Hibernate就是JPA Provider中很强的一个，应该说无人能出其右。从功能上来说，JPA就是Hibernate功能的一个子集。</p>
<blockquote>
<p>JPA 是规范</p>
</blockquote>
<h2 id="2、HelloWorld"><a href="#2、HelloWorld" class="headerlink" title="2、HelloWorld"></a>2、HelloWorld</h2><p>（1）创建 persistence.xml, 在这个文件中配置持久化单元</p>
<p>JPA 规范要求在类路径的 META-INF 目录下放置persistence.xml</p>
<ul>
<li><p>需要指定跟哪个数据库进行交互;</p>
</li>
<li><p>需要指定 JPA 使用哪个持久化的框架以及配置该框架的基本属性</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">persistence</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/persistence&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--需要配置persistence-unit节点</span></span><br><span class="line"><span class="comment">    持久化单元:</span></span><br><span class="line"><span class="comment">        name:持久化单元名称</span></span><br><span class="line"><span class="comment">        transaction-type:事务管理的方式</span></span><br><span class="line"><span class="comment">                JTA: 分布式事先管理</span></span><br><span class="line"><span class="comment">                RESOURCE_LOCAL:本地事务管理</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">persistence-unit</span> <span class="attr">name</span>=<span class="string">&quot;myJPA&quot;</span> <span class="attr">transaction-type</span>=<span class="string">&quot;RESOURCE_LOCAL&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        jpa的实现方式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span>&gt;</span>org.hibernate.jpa.HibernatePersistenceProvider<span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 添加持久化类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.tcmyxc.helloworld.Customer<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--        数据库信息</span></span><br><span class="line"><span class="comment">              用户名, javax.persistence.jdbc.user</span></span><br><span class="line"><span class="comment">              密码, javax.persistence.jdbc.password</span></span><br><span class="line"><span class="comment">              驱动, javax.persistence.jdbc.driver</span></span><br><span class="line"><span class="comment">              数据库地址 javax.persistence.jdbc.url</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--            三个/  ///表示本地路径,端口为3306 jdbc:mysql://localhost:3306/test?serverTimezone=UTC--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///jpa_test?serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--        可选配置:配置jpa实现方的配置信息</span></span><br><span class="line"><span class="comment">                    显示sql执行语句</span></span><br><span class="line"><span class="comment">                    自动创建数据库表  hibernate.hbm2ddl.auto</span></span><br><span class="line"><span class="comment">                                        create,程序运行时创建数据库表(如果有表,先删除表再创建表)</span></span><br><span class="line"><span class="comment">                                        update,程序运行时创建表(如果表存在,则不会创建)</span></span><br><span class="line"><span class="comment">                                        none 不会创建表</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.show_sql&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span> <span class="attr">value</span>=<span class="string">&quot;update&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.format_sql&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">persistence-unit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistence</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>（2）创建实体类, 使用 annotation 来描述实体类跟数据库表之间的映射关系.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 持久化类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Table(name = &quot;JPA_CUSTOMERS&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;LAST_NAME&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（3）使用 JPA API 完成数据增加、删除、修改和查询操作</p>
<ul>
<li><p>创建 EntityManagerFactory (对应 Hibernate 中的 SessionFactory);</p>
</li>
<li><p>创建 EntityManager (对应 Hibernate 中的Session);</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建 EntityManagerFactory</span></span><br><span class="line">    String persistenceUnitName = <span class="string">&quot;myJPA&quot;</span>;</span><br><span class="line">    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(persistenceUnitName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、创建 EntityManager</span></span><br><span class="line">    EntityManager entityManager = entityManagerFactory.createEntityManager();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、开启事务</span></span><br><span class="line">    EntityTransaction transaction = entityManager.getTransaction();</span><br><span class="line">    transaction.begin();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、CRUD 操作</span></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setLastName(<span class="string">&quot;xwx&quot;</span>);</span><br><span class="line">    customer.setEmail(<span class="string">&quot;1282494272@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    entityManager.persist(customer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、提交事务</span></span><br><span class="line">    transaction.commit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、关闭 EntityManager</span></span><br><span class="line">    entityManager.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、关闭 EntityManagerFactory</span></span><br><span class="line">    entityManagerFactory.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行截图：</p>
<p><img src="../images/image-20210612173746712.png" alt="image-20210612173746712"></p>
<p><img src="../images/image-20210612173801846.png" alt="image-20210612173801846"></p>
<h2 id="3、注解"><a href="#3、注解" class="headerlink" title="3、注解"></a>3、注解</h2><h3 id="Entity"><a href="#Entity" class="headerlink" title="@Entity"></a>@Entity</h3><p>@Entity 标注用于实体类声明语句之前，指出该Java 类为实体类，将映射到指定的数据库表。</p>
<h3 id="Table"><a href="#Table" class="headerlink" title="@Table"></a>@Table</h3><p>当实体类与其映射的数据库表名不同名时需要使用 @Table 标注说明，该标注与 @Entity 标注并列使用，置于实体类声明语句之前，可写于单独语句行，也可与声明语句同行。</p>
<p>@Table 标注的常用选项是 name，用于指明数据库的表名</p>
<p>@Table标注还有一个两个选项 catalog 和 schema 用于设置表所属的数据库目录或模式，通常为数据库名。</p>
<p>uniqueConstraints 选项用于设置约束条件，通常不须设置。</p>
<h3 id="Id"><a href="#Id" class="headerlink" title="@Id"></a>@Id</h3><p>@Id 标注用于声明一个实体类的属性映射为数据库的主键列。该属性通常置于属性声明语句之前，可与声明语句同行，也可写在单独行上。</p>
<p>@Id标注也可置于属性的getter方法之前。</p>
<h3 id="GeneratedValue"><a href="#GeneratedValue" class="headerlink" title="@GeneratedValue"></a>@GeneratedValue</h3><p>@GeneratedValue  用于标注主键的生成策略，通过 strategy 属性指定。默认情况下，JPA 自动选择一个最适合底层数据库的主键生成策略：SqlServer 对应 identity，MySQL 对应 auto increment。</p>
<p>在 javax.persistence.GenerationType 中定义了以下几种可供选择的策略：</p>
<ul>
<li><p>IDENTITY：采用数据库 ID自增长的方式来自增主键字段，Oracle 不支持这种方式；</p>
</li>
<li><p><strong>AUTO</strong>： JPA自动选择合适的策略，是默认选项；</p>
</li>
<li><p>SEQUENCE：通过序列产生主键，通过 @SequenceGenerator 注解指定序列名，MySql 不支持这种方式</p>
</li>
<li><p>TABLE：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。</p>
</li>
</ul>
<h3 id="Basic"><a href="#Basic" class="headerlink" title="@Basic"></a>@Basic</h3><p>@Basic 表示一个简单的属性到数据库表的字段的映射,对于没有任何标注的 getXxxx() 方法,默认即为@Basic</p>
<p>fetch: 表示该属性的读取策略,有 EAGER 和 LAZY 两种,分别表示主支抓取和延迟加载,默认为 EAGER.</p>
<p>optional:表示该属性是否允许为null, 默认为true</p>
<h3 id="Column"><a href="#Column" class="headerlink" title="@Column"></a>@Column</h3><p>当实体的属性与其映射的数据库表的列不同名时需要使用@Column 标注说明，该属性通常置于实体的属性声明语句之前，还可与 @Id 标注一起使用。</p>
<p>@Column 标注的常用属性是 name，用于设置映射数据库表的列名。此外，该标注还包含其它多个属性，如：unique 、nullable、length 等。</p>
<p>@Column 标注的 columnDefinition 属性: 表示该字段在数据库中的实际类型.通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型,但是对于Date类型仍无法确定数据库中字段类型究竟是DATE,TIME还是TIMESTAMP.此外,String的默认映射类型为VARCHAR, 如果要将 String 类型映射到特定数据库的 BLOB 或TEXT 字段类型.</p>
<p>@Column标注也可置于属性的getter方法之前</p>
<h3 id="Transient"><a href="#Transient" class="headerlink" title="@Transient"></a>@Transient</h3><p>表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性.</p>
<p>如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic</p>
<h3 id="Temporal"><a href="#Temporal" class="headerlink" title="@Temporal"></a>@Temporal</h3><p>在核心的 Java API 中并没有定义 Date 类型的精度(temporal precision).  而在数据库中,表示 Date 类型的数据有 DATE, TIME, 和 TIMESTAMP 三种精度(即单纯的日期,时间,或者两者 兼备). 在进行属性映射时可使用@Temporal注解来调整精度</p>
<p><img src="../images/image-20210612175625699.png" alt="image-20210612175625699"></p>
<p>对应数据库：</p>
<p><img src="../images/image-20210612175607590.png" alt="image-20210612175607590"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create table jpa_customers;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `jpa_customers` (</span><br><span class="line">  `id` int NOT NULL,</span><br><span class="line">  `birth` date DEFAULT NULL,</span><br><span class="line">  `createdTime` datetime(6) DEFAULT NULL,</span><br><span class="line">  `email` varchar(255) DEFAULT NULL,</span><br><span class="line">  `LAST_NAME` varchar(50) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>

<h2 id="4、JPA-API"><a href="#4、JPA-API" class="headerlink" title="4、JPA API"></a>4、JPA API</h2><h3 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h3><p>用于获取 EntityManagerFactory 实例。该类包含一个名为 createEntityManagerFactory 的 静态方法 。</p>
<p>createEntityManagerFactory 方法有如下两个重载版本。</p>
<ul>
<li>带有一个参数的方法以 JPA 配置文件 persistence.xml 中的持久化单元名为参数</li>
<li>带有两个参数的方法：前一个参数含义相同，后一个参数 Map类型，用于设置 JPA 的相关属性，这时将忽略其它地方设置的属性。Map 对象的属性名必须是 JPA 实现库提供商的名字空间约定的属性名。</li>
</ul>
<p><img src="../images/image-20210612184416168.png" alt="image-20210612184416168"></p>
<h3 id="EntityManagerFactory"><a href="#EntityManagerFactory" class="headerlink" title="EntityManagerFactory"></a>EntityManagerFactory</h3><p>EntityManagerFactory 接口主要用来创建 EntityManager 实例。该接口约定了如下4个方法：</p>
<ul>
<li><p>createEntityManager()：用于创建实体管理器对象实例。</p>
</li>
<li><p>createEntityManager(Map map)：用于创建实体管理器对象实例的重载方法，Map 参数用于提供 EntityManager 的属性。</p>
</li>
<li><p>isOpen()：检查 EntityManagerFactory 是否处于打开状态。实体管理器工厂创建后一直处于打开状态，除非调用close()方法将其关闭。</p>
</li>
<li><p>close()：关闭 EntityManagerFactory 。 EntityManagerFactory 关闭后将释放所有资源，isOpen()方法测试将返回 false，其它方法将不能调用，否则将导致IllegalStateException异常。</p>
</li>
</ul>
<h3 id="EntityManager"><a href="#EntityManager" class="headerlink" title="EntityManager"></a>EntityManager</h3><p>是完成持久化操作的核心对象。实体作为普通 Java 对象，只有在调用 EntityManager 将其持久化后才会变成持久化对象。EntityManager 对象在一组实体类与底层数据源之间进行 O/R 映射的管理。它可以用来管理和更新 Entity Bean, 根椐主键查找 Entity Bean, 还可以通过JPQL语句查询实体。</p>
<p> 实体的状态:</p>
<p>新建状态:   新创建的对象，尚未拥有持久性主键。</p>
<p>持久化状态：已经拥有持久性主键并和持久化建立了上下文环境</p>
<p>游离状态：拥有持久化主键，但是没有与持久化建立上下文环境</p>
<p>删除状态:  拥有持久化主键，已经和持久化建立上下文环境，但是从数据库中删除。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">// 返回指定的 OID 对应的实体类对象</span><br><span class="line">find (Class&lt;T&gt; entityClass,Object primaryKey)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getReference (Class&lt;T&gt; entityClass,Object primaryKey)</span><br><span class="line"></span><br><span class="line">// 用于将新创建的 Entity 纳入到 EntityManager 的管理</span><br><span class="line">persist (Object entity)</span><br><span class="line"></span><br><span class="line">remove (Object entity)</span><br><span class="line"></span><br><span class="line">// 用于处理 Entity 的同步。即数据库的插入和更新操作</span><br><span class="line">merge (T entity)</span><br><span class="line"></span><br><span class="line">// 同步持久上下文环境</span><br><span class="line">flush ()</span><br><span class="line"></span><br><span class="line">// 设置持久上下文环境的Flush模式，自动更新或者提交事务才刷新</span><br><span class="line">setFlushMode (FlushModeType flushMode)</span><br><span class="line"></span><br><span class="line">// 获取持久上下文环境的Flush模式</span><br><span class="line">getFlushMode ()</span><br></pre></td></tr></table></figure>

<h3 id="EntityTransaction"><a href="#EntityTransaction" class="headerlink" title="EntityTransaction"></a>EntityTransaction</h3><p><code>begin(), commit(), rollback()</code> 等</p>
<h2 id="5、映射关系"><a href="#5、映射关系" class="headerlink" title="5、映射关系"></a>5、映射关系</h2><h3 id="单向多对一"><a href="#单向多对一" class="headerlink" title="单向多对一"></a>单向多对一</h3><p>例如：多个订单属于一个客户</p>
<p>只需从n的一端可以访问1的一端</p>
<p>1、订单实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;jpa_order&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_name&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderName</span><span class="params">(String orderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射单向多对一关系,，多个订单属于一个客户</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span><span class="comment">// 映射外键，同时声明列名</span></span><br><span class="line">    <span class="meta">@ManyToOne</span><span class="comment">// 这里可以设置懒加载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customer = customer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, orderName=&#x27;&quot;</span> + orderName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, customer=&quot;</span> + customer +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManyToOne</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setLastName(<span class="string">&quot;小华&quot;</span>);</span><br><span class="line">    customer.setEmail(<span class="string">&quot;ff@163.com&quot;</span>);</span><br><span class="line">    customer.setCreatedTime(<span class="keyword">new</span> Date());</span><br><span class="line">    customer.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setOrderName(<span class="string">&quot;O-FF-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setOrderName(<span class="string">&quot;O-FF-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order3 = <span class="keyword">new</span> Order();</span><br><span class="line">    order3.setOrderName(<span class="string">&quot;O-FF-3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联关系</span></span><br><span class="line">    order1.setCustomer(customer);</span><br><span class="line">    order2.setCustomer(customer);</span><br><span class="line">    order3.setCustomer(customer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存</span></span><br><span class="line">    entityManager.persist(customer);</span><br><span class="line">    entityManager.persist(order1);</span><br><span class="line">    entityManager.persist(order2);</span><br><span class="line">    entityManager.persist(order3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果先保存订单，实际上会把订单的<code>customer_id</code>设为<code>null</code>，之后再进行更新操作，开销变大了</p>
<p>【建议】</p>
<p>先保存 1 的一端，再保存多的一端</p>
<p>删除的时候因为有外键关联，不能直接删除 1 的一端</p>
<h3 id="单向一对多"><a href="#单向一对多" class="headerlink" title="单向一对多"></a>单向一对多</h3><p>一个客户有多个订单</p>
<p>1、修改订单类，去掉 Customer 属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;jpa_order&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_name&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderName</span><span class="params">(String orderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、在用户里添加订单属性（是个集合或者列表）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射单向一对多</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line"><span class="meta">@OneToMany</span><span class="comment">// 默认懒加载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Order&gt; <span class="title">getOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrders</span><span class="params">(Set&lt;Order&gt; orders)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orders = orders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOneToMany</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setLastName(<span class="string">&quot;小华&quot;</span>);</span><br><span class="line">    customer.setEmail(<span class="string">&quot;gg@163.com&quot;</span>);</span><br><span class="line">    customer.setCreatedTime(<span class="keyword">new</span> Date());</span><br><span class="line">    customer.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setOrderName(<span class="string">&quot;O-GG-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setOrderName(<span class="string">&quot;O-GG-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order3 = <span class="keyword">new</span> Order();</span><br><span class="line">    order3.setOrderName(<span class="string">&quot;O-GG-3&quot;</span>);</span><br><span class="line">    customer.getOrders().add(order1);</span><br><span class="line">    customer.getOrders().add(order2);</span><br><span class="line">    customer.getOrders().add(order3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存</span></span><br><span class="line">    entityManager.persist(customer);</span><br><span class="line">    entityManager.persist(order1);</span><br><span class="line">    entityManager.persist(order2);</span><br><span class="line">    entityManager.persist(order3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【注意】：单向一对多保存时一定会有更新语句发生，与保存顺序无关。因为多的一端再插入时不会同时插入外键列</p>
<p>删除一的一端，会把关联的多的一端外键置空，然后删除，可以在<code>@OneToMany</code>设置级联删除</p>
<h3 id="双向多对一"><a href="#双向多对一" class="headerlink" title="双向多对一"></a>双向多对一</h3><p>订单属性里面有客户，客户里面有订单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Date createdTime;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Order&gt; <span class="title">getOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orders;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span><span class="comment">// 映射外键</span></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>映射的外键名要一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManyToOne</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setLastName(<span class="string">&quot;小华&quot;</span>);</span><br><span class="line">    customer.setEmail(<span class="string">&quot;ww@163.com&quot;</span>);</span><br><span class="line">    customer.setCreatedTime(<span class="keyword">new</span> Date());</span><br><span class="line">    customer.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setOrderName(<span class="string">&quot;O-ww-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setOrderName(<span class="string">&quot;O-ww-2&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联关系</span></span><br><span class="line">    order1.setCustomer(customer);</span><br><span class="line">    order2.setCustomer(customer);</span><br><span class="line"></span><br><span class="line">    customer.getOrders().add(order1);</span><br><span class="line">    customer.getOrders().add(order2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存</span></span><br><span class="line">    entityManager.persist(customer);<span class="comment">// n条update，写后面就是 2n 条</span></span><br><span class="line">    entityManager.persist(order1);</span><br><span class="line">    entityManager.persist(order2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果先保存多的一端，会有多余的更新语句</p>
<p>让多的一方来维护关联关系，在 @OneToMany 中设置 mapperBy（值为多的一方的 customer 属性）</p>
<p>【注意】</p>
<p>如果在 1 的一端 @OneToMany 中使用 mapperBy，就不能再使用 @JoinColumn</p>
<h3 id="双向一对一"><a href="#双向一对一" class="headerlink" title="双向一对一"></a>双向一对一</h3><p>基于外键的 1-1 关联关系：在双向的一对一关联中，需要在关系被维护端(inverse side)中的 @OneToOne 注释中指定 mappedBy，以指定是这一关联中的被维护端。同时需要在关系维护端(owner side)建立外键列指向关系被维护端的主键列。</p>
<p>设计：一个部门只能有一个经理，一个经理也只能管一个部门</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;jpa_manager&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String mgrName;</span><br><span class="line">    <span class="keyword">private</span> Department dept;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToOne(mappedBy = &quot;mgr&quot;)</span><span class="comment">// 不维护关联关系（等于说是我这张表里面没有这个字段，虽然属性里面有），需要设置 mappedBy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;jpa_department&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String deptName;</span><br><span class="line">    <span class="keyword">private</span> Manager mgr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToOne</span> <span class="comment">// 映射一对一关联关系，维护关联关系</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;mgr_id&quot;, unique = true)</span><span class="comment">// 一对一需要添加 unique=true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Manager <span class="title">getMgr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mgr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOneToOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Manager manager = <span class="keyword">new</span> Manager();</span><br><span class="line">    manager.setMgrName(<span class="string">&quot;M-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Department department = <span class="keyword">new</span> Department();</span><br><span class="line">    department.setDeptName(<span class="string">&quot;D-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联关系</span></span><br><span class="line">    manager.setDept(department);</span><br><span class="line">    department.setMgr(manager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    entityManager.persist(manager);<span class="comment">// 先保存不维护关联关系的（即没有外键的一方）</span></span><br><span class="line">    entityManager.persist(department);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认情况下，若获取维护关联关系的一方，则会通过左外连接获取其关联的对象</span></span><br><span class="line"><span class="comment">// 但是可以设置维护关联关系的一方的 @OneToOne 的 fetch 属性来修改加载策略来实现懒加载</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOneToOneFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Department dept = entityManager.find(Department.class, <span class="number">1</span>);</span><br><span class="line">    System.out.println(dept.getDeptName());</span><br><span class="line">    System.out.println(dept.getMgr().getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        department0<span class="built_in">_</span>.id as id1<span class="built_in">_</span>1<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        department0<span class="built_in">_</span>.deptName as deptname2<span class="built_in">_</span>1<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        department0<span class="built_in">_</span>.mgr<span class="built_in">_</span>id as mgr<span class="built_in">_</span>id3<span class="built_in">_</span>1<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        manager1<span class="built_in">_</span>.id as id1<span class="built_in">_</span>2<span class="built_in">_</span>1<span class="built_in">_</span>,</span><br><span class="line">        manager1<span class="built_in">_</span>.mgr<span class="built_in">_</span>name as mgr<span class="built_in">_</span>name2<span class="built_in">_</span>2<span class="built_in">_</span>1<span class="built_in">_</span> </span><br><span class="line">    from</span><br><span class="line">        jpa<span class="built_in">_</span>department department0<span class="built_in">_</span> </span><br><span class="line">    left outer join</span><br><span class="line">        jpa<span class="built_in">_</span>manager manager1<span class="built_in">_</span> </span><br><span class="line">            on department0<span class="built_in">_</span>.mgr<span class="built_in">_</span>id=manager1<span class="built_in">_</span>.id </span><br><span class="line">    where</span><br><span class="line">        department0<span class="built_in">_</span>.id=?</span><br><span class="line">D-1</span><br><span class="line">com.tcmyxc.helloworld.Manager</span><br></pre></td></tr></table></figure>



<p>【注意】：默认情况下，若获取不维护关联关系的一方，则也会通过左外连接获取其关联的对象，虽然可以改为懒加载，但是会多发 SQL 语句，得不偿失</p>
<h3 id="双向多对多"><a href="#双向多对多" class="headerlink" title="双向多对多"></a>双向多对多</h3><p>在双向多对多关系中，我们必须指定一个关系维护端(owner side),可以通过 @ManyToMany 注释中指定 mappedBy 属性来标识其为关系维护端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;jpa_item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String itemName;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Category&gt; categories = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">// 不写会报空指针，因为不能直接使用接口，接口变量必须引用实现了接口的类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置多对多的关系</span></span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="comment">// 设置中间表</span></span><br><span class="line">    <span class="comment">// 1、joinColumns 映射当前类</span></span><br><span class="line">    <span class="comment">// 2、inverseJoinColumns 映射关联的类</span></span><br><span class="line">    <span class="meta">@JoinTable(joinColumns = &#123;</span></span><br><span class="line"><span class="meta">            @JoinColumn(name = &quot;item_id&quot;, // 中间表的外键名</span></span><br><span class="line"><span class="meta">                    referencedColumnName = &quot;id&quot;)// 外键指向当前表的那个字段</span></span><br><span class="line"><span class="meta">            &#125;,</span></span><br><span class="line"><span class="meta">            inverseJoinColumns = &#123;</span></span><br><span class="line"><span class="meta">            @JoinColumn(name = &quot;category_id&quot;,// 中间表的外键名</span></span><br><span class="line"><span class="meta">                    referencedColumnName = &quot;id&quot;)</span></span><br><span class="line"><span class="meta">            &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Category&gt; <span class="title">getCategories</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> categories;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;jpa_category&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Item&gt; items;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany(mappedBy = &quot;categories&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Item&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化表，可以发现建立了三张表</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    create table jpa<span class="built_in">_</span>category (</span><br><span class="line">       id integer not null auto<span class="built_in">_</span>increment,</span><br><span class="line">        category<span class="built_in">_</span>name varchar(255),</span><br><span class="line">        primary key (id)</span><br><span class="line">    ) engine=InnoDB</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    create table jpa<span class="built_in">_</span>item (</span><br><span class="line">       id integer not null auto<span class="built_in">_</span>increment,</span><br><span class="line">        item<span class="built_in">_</span>name varchar(255),</span><br><span class="line">        primary key (id)</span><br><span class="line">    ) engine=InnoDB</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    create table jpa<span class="built_in">_</span>item<span class="built_in">_</span>jpa<span class="built_in">_</span>category (</span><br><span class="line">       item<span class="built_in">_</span>id integer not null,</span><br><span class="line">        category<span class="built_in">_</span>id integer not null,</span><br><span class="line">        primary key (item<span class="built_in">_</span>id, category<span class="built_in">_</span>id)</span><br><span class="line">    ) engine=InnoDB</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    alter table jpa<span class="built_in">_</span>item<span class="built_in">_</span>jpa<span class="built_in">_</span>category </span><br><span class="line">       add constraint FKedbrfsg4dplyysrucevm258pk </span><br><span class="line">       foreign key (category<span class="built_in">_</span>id) </span><br><span class="line">       references jpa<span class="built_in">_</span>category (id)</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    alter table jpa<span class="built_in">_</span>item<span class="built_in">_</span>jpa<span class="built_in">_</span>category </span><br><span class="line">       add constraint FK7vk3csx9i2cq3etibrkouumid </span><br><span class="line">       foreign key (item<span class="built_in">_</span>id) </span><br><span class="line">       references jpa<span class="built_in">_</span>item (id)</span><br></pre></td></tr></table></figure>



<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManyToMany</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Item i1 = <span class="keyword">new</span> Item();</span><br><span class="line">    Item i2 = <span class="keyword">new</span> Item();</span><br><span class="line"></span><br><span class="line">    i1.setItemName(<span class="string">&quot;item1&quot;</span>);</span><br><span class="line">    i2.setItemName(<span class="string">&quot;item2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Category c1 = <span class="keyword">new</span> Category();</span><br><span class="line">    Category c2 = <span class="keyword">new</span> Category();</span><br><span class="line">    Category c3 = <span class="keyword">new</span> Category();</span><br><span class="line"></span><br><span class="line">    c1.setCategoryName(<span class="string">&quot;C-1&quot;</span>);</span><br><span class="line">    c2.setCategoryName(<span class="string">&quot;C-2&quot;</span>);</span><br><span class="line">    c3.setCategoryName(<span class="string">&quot;C-3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联关系</span></span><br><span class="line">    i1.getCategories().add(c1);</span><br><span class="line">    i1.getCategories().add(c2);</span><br><span class="line">    i1.getCategories().add(c3);</span><br><span class="line"></span><br><span class="line">    i2.getCategories().add(c1);</span><br><span class="line">    i2.getCategories().add(c3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    entityManager.persist(i1);</span><br><span class="line">    entityManager.persist(i2);</span><br><span class="line">    entityManager.persist(c1);</span><br><span class="line">    entityManager.persist(c2);</span><br><span class="line">    entityManager.persist(c3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>很尴尬地失败了</p>
<p><img src="../images/image-20210616165321122.png" alt="image-20210616165321122"></p>
<p>错误原因：不能直接使用接口变量，接口变量必须引用实现了接口的类的实例。</p>
<p>解决方法：在类定义那里把接口变量改为正确的引用。</p>
<p>查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManyToManyFind</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Item item = entityManager.find(Item.class, <span class="number">1</span>);</span><br><span class="line">    System.out.println(item.getItemName());</span><br><span class="line"></span><br><span class="line">    System.out.println(item.getCategories().size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        item0<span class="built_in">_</span>.id as id1<span class="built_in">_</span>4<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        item0<span class="built_in">_</span>.item<span class="built_in">_</span>name as item<span class="built_in">_</span>nam2<span class="built_in">_</span>4<span class="built_in">_</span>0<span class="built_in">_</span> </span><br><span class="line">    from</span><br><span class="line">        jpa<span class="built_in">_</span>item item0<span class="built_in">_</span> </span><br><span class="line">    where</span><br><span class="line">        item0<span class="built_in">_</span>.id=?</span><br><span class="line">I-1</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        categories0<span class="built_in">_</span>.item<span class="built_in">_</span>id as item<span class="built_in">_</span>id1<span class="built_in">_</span>0<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        categories0<span class="built_in">_</span>.category<span class="built_in">_</span>id as category2<span class="built_in">_</span>0<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        category1<span class="built_in">_</span>.id as id1<span class="built_in">_</span>1<span class="built_in">_</span>1<span class="built_in">_</span>,</span><br><span class="line">        category1<span class="built_in">_</span>.category<span class="built_in">_</span>name as category2<span class="built_in">_</span>1<span class="built_in">_</span>1<span class="built_in">_</span> </span><br><span class="line">    from</span><br><span class="line">        item<span class="built_in">_</span>category categories0<span class="built_in">_</span> </span><br><span class="line">    inner join</span><br><span class="line">        jpa<span class="built_in">_</span>category category1<span class="built_in">_</span> </span><br><span class="line">            on categories0<span class="built_in">_</span>.category<span class="built_in">_</span>id=category1<span class="built_in">_</span>.id </span><br><span class="line">    where</span><br><span class="line">        categories0<span class="built_in">_</span>.item<span class="built_in">_</span>id=?</span><br><span class="line">2</span><br></pre></td></tr></table></figure>



<p>可以看出来，这里默认用的是懒加载。其实从分类里面查标签也是懒加载。</p>
<h2 id="6、JQPL"><a href="#6、JQPL" class="headerlink" title="6、JQPL"></a>6、JQPL</h2><p>Java Persistence Query Language 的简称。JPQL 是一种和 SQL 非常类似的中间性和对象化查询语言，它最终会被编译成针对不同底层数据库的 SQL 查询，从而屏蔽不同数据库的差异。</p>
<p>JPQL语言的语句可以是 select 语句、update 语句或delete语句，它们都通过 Query 接口封装执行</p>
<h3 id="Query-接口"><a href="#Query-接口" class="headerlink" title="Query 接口"></a>Query 接口</h3><p>Query接口封装了执行数据库查询的相关方法。调用 EntityManager 的 createQuery、create NamedQuery 及 createNativeQuery 方法可以获得查询对象，进而可调用 Query 接口的相关方法来执行查询操作。</p>
<h3 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h3><p>用于执行查询。其语法可表示为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">select_clause </span><br><span class="line">form_clause </span><br><span class="line">[where_clause] </span><br><span class="line">[groupby_clause] </span><br><span class="line">[having_clause]</span><br><span class="line">[orderby_clause]</span><br></pre></td></tr></table></figure>

<p>select、from 都是 JPQL 的关键字，通常全大写或全小写，建议不要大小写混用。</p>
<p><strong>查询所有</strong>实体的 JPQL 查询字串很简单，例如：</p>
<p>​    select o from Order o 或  select o from Order as o</p>
<p>关键字 as 可以省去。</p>
<p>标识符变量的命名规范与 Java 标识符相同，且区分大小写。</p>
<p>调用 EntityManager 的 createQuery() 方法可创建查询对象，接着调用 Query 接口的 getResultList() 方法就可获得查询结果集。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query query = entityManager.createQuery( <span class="string">&quot;select o from Order o&quot;</span>); </span><br><span class="line">List orders = query.getResultList();</span><br><span class="line">Iterator iterator = orders.iterator();</span><br><span class="line"><span class="keyword">while</span>( iterator.hasNext() ) &#123;</span><br><span class="line">	<span class="comment">// 处理Order</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JPQL也支持<strong>包含参数的查询</strong>，例如：</p>
<p>​    select o from Orders o where o.id = :myId</p>
<p>​    select o from Orders o where o.id = :myId and o.customer = :customerName</p>
<p>注意：参数名前必须冠以冒号(:)，执行查询前须使用Query.setParameter(name, value)方法给参数赋值。</p>
<p>可以<strong>不使用参数名而使用参数的序号</strong>，例如：</p>
<p>select o from Order o where o.id = ?1 and o.customer = ?2</p>
<p>其中 ?1 代表第一个参数，?2 代表第一个参数。在执行查询之前需要使用重载方法Query.setParameter(pos, value) 提供参数值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query query = entityManager.createQuery( <span class="string">&quot;select o from Orders o where o.id = ?1 and o.customer = ?2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 占位符的索引是从 1 开始的</span></span><br><span class="line">query.setParameter( <span class="number">1</span>, <span class="number">2</span> );</span><br><span class="line">query.setParameter( <span class="number">2</span>, <span class="string">&quot;John&quot;</span> );</span><br><span class="line">List orders = query.getResultList();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>JPQL也支持子查询，在 where 或 having 子句中可以包含另一个查询。</p>
<p><strong>查询部分属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询部分属性</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPartlyProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jpql = <span class="string">&quot;select c.email, c.lastName from Customer c where c.id &gt; ?1&quot;</span>;</span><br><span class="line">    Query query = entityManager.createQuery(jpql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 占位符的索引是从 1 开始的</span></span><br><span class="line">    query.setParameter(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    List resultList = query.getResultList();</span><br><span class="line">    System.out.println(resultList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[[Ljava.lang.Object;@c6b2dd9, [Ljava.lang.Object;@73437222]</span><br></pre></td></tr></table></figure>

<p>可以看到是个 Object 数组</p>
<p>如果想返回对应类的对象，需要有对应参数的构造器，同时修改查询语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Customer 类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String lastName, String email)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    <span class="keyword">this</span>.email = email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试语句</span></span><br><span class="line">String jpql = <span class="string">&quot;select new Customer(c.email, c.lastName) from Customer c where c.id &gt; ?1&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[Customer&#123;id=null, lastName=&#x27;ww@163.com&#x27;, email=&#x27;小华&#x27;, createdTime=null, birth=null&#125;, Customer&#123;id=null, lastName=&#x27;ww@163.com&#x27;, email=&#x27;小华&#x27;, createdTime=null, birth=null&#125;]</span><br></pre></td></tr></table></figure>

<p>这里 JQPL 帮我们做了底层的转换，所以数组里面放的是 Customer 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(resultList.get(<span class="number">0</span>).getClass().getName());</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">com.tcmyxc.helloworld.Customer</span><br></pre></td></tr></table></figure>

<p><strong>查询语句也可以放在实体类头上</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NamedQuery(name = &quot;testNamedQuery&quot;, query = &quot;SELECT c FROM Customer c where c.id = ?1&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;JPA_CUSTOMERS&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 指定 name，同时设置参数</span></span><br><span class="line">    Query query = entityManager.createNamedQuery(<span class="string">&quot;testNamedQuerySQL&quot;</span>).setParameter(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    Customer customer = (Customer) query.getSingleResult();</span><br><span class="line">    System.out.println(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Customer&#123;id=1, lastName=&#x27;小华&#x27;, email=&#x27;ww@163.com&#x27;, createdTime=2021-06-13 17:07:17.677, birth=2021-06-13&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Native SQL</strong></p>
<p>指原生的 SQL 语句，不再是 JQPL 的语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativedQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;select birth from JPA_CUSTOMERS c where c.id = 1&quot;</span>;</span><br><span class="line">    Query query = entityManager.createNativeQuery(sql);</span><br><span class="line">    System.out.println(query.getSingleResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        birth </span><br><span class="line">    from</span><br><span class="line">        JPA<span class="built_in">_</span>CUSTOMERS c </span><br><span class="line">    where</span><br><span class="line">        c.id = 1</span><br><span class="line">2021-06-13</span><br></pre></td></tr></table></figure>



<p>JQPL 也支持 order by、group by、having、关联查询、子查询等</p>
<h3 id="update-和-delete"><a href="#update-和-delete" class="headerlink" title="update 和 delete"></a>update 和 delete</h3><p>更新操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;update Customer c set c.lastName = ?1 where c.id = ?2&quot;</span>;</span><br><span class="line">    Query query = entityManager.createQuery(sql);</span><br><span class="line">    query.setParameter(<span class="number">1</span>, <span class="string">&quot;YYY&quot;</span>).setParameter(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    query.executeUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210617115000945.png" alt="image-20210617115000945"></p>
<p>删除操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;delete from Order o where o.id = ?1&quot;</span>;</span><br><span class="line">    Query query = entityManager.createQuery(sql);</span><br><span class="line">    query.setParameter(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    query.executeUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210617120812216.png" alt="image-20210617120812216"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>JQPL</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC学习笔记</title>
    <url>/archives/319c21eb.html</url>
    <content><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><span id="more"></span>

<h2 id="什么是SpirngMVC？"><a href="#什么是SpirngMVC？" class="headerlink" title="什么是SpirngMVC？"></a>什么是SpirngMVC？</h2><h3 id="简单定义"><a href="#简单定义" class="headerlink" title="简单定义"></a>简单定义</h3><ul>
<li><p>Spring MVC是SpringFrameWork的一部分，是基于Java实现的MVC的轻量级web框架。</p>
</li>
<li><p>基于Servlet API构建的原始Web框架，从一开始就已包含在Spring框架中</p>
</li>
<li><p>围绕一个中心的DispatcherServlet设计的，它将请求发送给处理程序，具有可配置的处理程序映射、视图解析、区域设置、时区和主题解析以及对上载文件的支持。</p>
</li>
<li><p>默认处理程序基于@Controller和@RequestMapping注解</p>
</li>
<li><p>将请求发送给控制器，并提供其他有助于web应用程序开发的功能。然而，Spring的DispatcherServlet所做的不仅仅是这些。它与Spring IoC容器完全集成，因此允许您使用Spring的所有其他特性。</p>
</li>
</ul>
<blockquote>
<p>通过策略接口，Spring 框架是高度可配置的，而且包含多种视图技术，例如 [JavaServer Pages](<a href="https://baike.baidu.com/item/JavaServer">https://baike.baidu.com/item/JavaServer</a> Pages)（JSP）技术、<a href="https://baike.baidu.com/item/Velocity">Velocity</a>、<a href="https://baike.baidu.com/item/Tiles">Tiles</a>、<a href="https://baike.baidu.com/item/iText">iText</a>和POI。Spring MVC 框架并不知道使用的视图，所以不会强迫开发者只使用 JSP 技术。Spring MVC 分离了控制器、模型对象、过滤器以及处理程序对象的角色，这种分离让它们更容易进行定制。</p>
<p>——百度百科</p>
</blockquote>
<p>官方文档：<a href="https://docs.spring.io/spring/docs/4.3.27.RELEASE/spring-framework-reference/htmlsingle/#spring-web%EF%BC%88%E6%89%93%E5%BC%80%E5%BF%AB%EF%BC%89">https://docs.spring.io/spring/docs/4.3.27.RELEASE/spring-framework-reference/htmlsingle/#spring-web（打开快）</a></p>
<p>最新版文档（截止20200618）：<a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/web.html#spring-web">https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/web.html#spring-web</a></p>
<h3 id="为什么要学SpringMVC"><a href="#为什么要学SpringMVC" class="headerlink" title="为什么要学SpringMVC?"></a>为什么要学SpringMVC?</h3><ul>
<li>轻量级，简单易学</li>
<li>高效，基于请求响应的MVC框架</li>
<li>无缝结合Spring</li>
<li>约定大于配置</li>
<li>功能强大：RESTful、数据验证、格式化、本地化、主题</li>
<li>简单灵活</li>
</ul>
<h3 id="SpringWebMVC中Dispatcherservlet的请求处理工作流"><a href="#SpringWebMVC中Dispatcherservlet的请求处理工作流" class="headerlink" title="SpringWebMVC中Dispatcherservlet的请求处理工作流"></a>SpringWebMVC中Dispatcherservlet的请求处理工作流</h3><p><img src="../images/mvc.png" alt="mvc"></p>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="HelloSpringMVC"><a href="#HelloSpringMVC" class="headerlink" title="HelloSpringMVC"></a>HelloSpringMVC</h3><p>1、新建一个模块，添加web支持</p>
<p>放在项目上，右键增加模块</p>
<p><img src="../images/image-20200617194548060.png" alt="image-20200617194548060"></p>
<p>2、确定导入了SpringMVC的依赖</p>
<p>3、配置web.xml，注册DispatchServlet</p>
<p>tomcat7 web.xml头文件（版本号是3.0，tomcat 9版本号是4.0，tomcat 8版本号是3.1）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>4、编写SpringMVC配置文件。名称：springmvc-servlet.xml：【servletname】-servlet.xml（官方规定的命名方式）</p>
<ul>
<li>官方头如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>5、添加处理映射器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<p>6、添加处理适配器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<p>7、添加视图解析器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>8、编写业务操作controller，要么实现Controller接口，要么增加注解；需要返回一个ModleAndView，装数据，封视图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tcmyxc.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 模型和视图</span></span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装对象，放在 ModelAndView中</span></span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;HelloSpringMVC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装要跳转的视图</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>9、将自己的类交给SpingIOC容器，注册bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--handler--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.controller.HelloController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<p>10、写需要跳转的JSP页面，显示数据</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;$&#123;msg&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<p>11、配置tomcat，测试</p>
<p><strong>可能出现的问题：访问404，排查步骤：</strong></p>
<ol>
<li><p>查看控制台输出是不是少了什么jar包</p>
</li>
<li><p>如果不缺jar包，在IEDA的项目发布中，添加lib依赖</p>
<p><img src="../images/image-20200618153647336.png" alt="image-20200618153647336"></p>
</li>
<li><p>重启tomcat</p>
</li>
</ol>
<h3 id="简要分析执行流程"><a href="#简要分析执行流程" class="headerlink" title="简要分析执行流程"></a>简要分析执行流程</h3><p><img src="../images/image-20200618161157277.png" alt="image-20200618161157277"></p>
<ol>
<li>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截</li>
</ol>
<img src="../images/image-20200618161439581.png" alt="image-20200618161439581" style="zoom:150%;" />



<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="../images/image-20200618170449362.png" alt="image-20200618170449362"></p>
<p>1、新建一个WEB项目</p>
<p>2、导入相关的jar包</p>
<p>3、编写web.xml，注册DispatcherServlet</p>
<p>4、编写springmvc配置文件</p>
<p>5、创建控制类，controller</p>
<p>6、完善前端视图和controller之间的对应</p>
<p>7、测试</p>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><h3 id="springmvc-servlet-xml一般配置："><a href="#springmvc-servlet-xml一般配置：" class="headerlink" title="springmvc-servlet.xml一般配置："></a><code>springmvc-servlet.xml</code>一般配置：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--自动扫描包，让包下的注解生效，有IOC容器统一管理--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.tcmyxc.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--让springMVC不处理静态资源--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--支持MVC注解驱动--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="实现Controller接口"><a href="#实现Controller接口" class="headerlink" title="实现Controller接口"></a>实现Controller接口</h3><ul>
<li>不推荐使用，太麻烦，而且一个controller对应一个bean，太浪费</li>
</ul>
<h3 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h3><h2 id="RESTful风格"><a href="#RESTful风格" class="headerlink" title="RESTful风格"></a>RESTful风格</h2><p>RESTFUL特点包括：</p>
<p>1、每一个URI代表1种资源；</p>
<p>2、客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</p>
<p>3、通过操作资源的表现形式来操作资源；</p>
<p>4、资源的表现形式是XML或者HTML；</p>
<p>5、客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</p>
<p>可以达到URL复用的功能</p>
<p>一般的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://localhost:8888/springmvc_04_controller_war_exploded/add?a=1&amp;b=2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Model model)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = a + b;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;结果是：&quot;</span> + res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>RESTful形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RESTful风格</span></span><br><span class="line"><span class="comment">// http://localhost:8888/springmvc_04_controller_war_exploded/add2/a/b</span></span><br><span class="line"><span class="comment">// 比如：http://localhost:8888/springmvc_04_controller_war_exploded/add2/3/5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @RequestMapping(value=&quot;/add2/&#123;a&#125;/&#123;b&#125;&quot;, method = RequestMethod.GET),这个可以用下面代替</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/add2/&#123;a&#125;/&#123;b&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> a, <span class="meta">@PathVariable</span> <span class="keyword">int</span> b, Model model)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = a + b;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;结果是：&quot;</span> + res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><code>@RequestMapping</code>的几种简单形式：<code>@GetMapping</code>，<code>@PostMapping</code>，<code>@PutMapping</code>，<code>@DeleteMapping</code></p>
<h2 id="SpringMVC接收数据"><a href="#SpringMVC接收数据" class="headerlink" title="SpringMVC接收数据"></a>SpringMVC接收数据</h2><h3 id="前端后端参数名一样的情况"><a href="#前端后端参数名一样的情况" class="headerlink" title="前端后端参数名一样的情况"></a>前端后端参数名一样的情况</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://localhost:8888/springmvc_04_controller_war_exploded/user/t1?name=xwx</span></span><br><span class="line"><span class="comment">// 前端和后端参数名完全一样的情况：不用管了，直接可以拿到数据</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/t1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">text</span><span class="params">(String name, Model model)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1、接收前端参数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;前端参数为：&quot;</span> + name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、将结果返回前端</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、跳转视图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="前后端参数名不一样"><a href="#前后端参数名不一样" class="headerlink" title="前后端参数名不一样"></a>前后端参数名不一样</h3><ul>
<li>加注解（如果错了会给错误信息）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/t2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String userName, Model model)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1、接收前端参数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;前端参数为：&quot;</span> + userName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、将结果返回前端</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>, userName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、跳转视图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>【中文乱码问题】</p>
<p>在web.xml配置一下就好</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--解决中文乱码问题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>如果还不行，把tomcat的server.xml文件修改一下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8888&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">URIEncoding</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>



<p>但是，这种方式只对<code>get</code>方式提交有效，如果是<code>post</code>方式提交，你会发现，还是乱码！！！</p>
<p>终极解决方法：</p>
<p>自定义过滤器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tcmyxc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决get和post请求 全部乱码的过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//处理response的字符编码</span></span><br><span class="line">        HttpServletResponse myResponse=(HttpServletResponse) response;</span><br><span class="line">        myResponse.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转型为与协议相关对象</span></span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">// 对request包装增强</span></span><br><span class="line">        HttpServletRequest myrequest = <span class="keyword">new</span> MyRequest(httpServletRequest);</span><br><span class="line">        chain.doFilter(myrequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义request对象，HttpServletRequest的包装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRequest</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">    <span class="comment">//是否编码的标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasEncode;</span><br><span class="line">    <span class="comment">//定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);<span class="comment">// super必须写</span></span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对需要增强方法 进行覆盖</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getParameterMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先获得请求方式</span></span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;post&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// post请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理post乱码</span></span><br><span class="line">                request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> request.getParameterMap();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;get&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// get请求</span></span><br><span class="line">            Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">            <span class="keyword">if</span> (!hasEncode) &#123; <span class="comment">// 确保get手动编码逻辑只运行一次</span></span><br><span class="line">                <span class="keyword">for</span> (String parameterName : parameterMap.keySet()) &#123;</span><br><span class="line">                    String[] values = parameterMap.get(parameterName);</span><br><span class="line">                    <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 处理get乱码</span></span><br><span class="line">                                values[i] = <span class="keyword">new</span> String(values[i]</span><br><span class="line">                                        .getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                hasEncode = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parameterMap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getParameterMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取一个值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">        String[] values = parameterMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> values[<span class="number">0</span>]; <span class="comment">// 取回参数的第一个值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取所有值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">        String[] values = parameterMap.get(name);</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在web.xml文件中配置过滤器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.tcmyxc.controller.GenericEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  下面是 /* 代表处理所有的请求，</span></span><br><span class="line"><span class="comment">  / 代表处理部分请求</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  /* 才是真正意义上的过滤所有请求</span></span><br><span class="line"><span class="comment">  / 过滤除jsp页面之外的请求，也就是不对jsp页面的代码进行处理</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="前端接收的是一个对象"><a href="#前端接收的是一个对象" class="headerlink" title="前端接收的是一个对象"></a>前端接收的是一个对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前端传的是一个对象，会匹配user对象中的字段名，否则就匹配不到，该字段为null，前端给的顺序是无所谓的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 输入示例：http://localhost:8888/springmvc_04_controller_war_exploded/user/t3?id=1&amp;age=90&amp;name=user</span></span><br><span class="line"><span class="comment">* 输出：前端参数为：User&#123;id=1, name=&#x27;user&#x27;, age=90&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 输入：http://localhost:8888/springmvc_04_controller_war_exploded/user/t3?id=1&amp;age=90&amp;username=user</span></span><br><span class="line"><span class="comment">* 输出：前端参数为：User&#123;id=1, name=&#x27;null&#x27;, age=90&#125;</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/t3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;前端参数为：&quot;</span> + user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><p>后端部署后端，提供接口</p>
<p>前端独立部署，负责渲染页面</p>
<h3 id="后端返回json数据"><a href="#后端返回json数据" class="headerlink" title="后端返回json数据"></a>后端返回json数据</h3><ul>
<li>Jackson，阿里的fastjson等</li>
</ul>
<h4 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h4><p>1、导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/j1&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>  <span class="comment">// 加了这个注解，就不会走视图解析器，会直接返回一个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">json1</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;徐文祥&quot;</span>, <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// jackson ObjectMapper</span></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String str = mapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试截图：</p>
<p><img src="../images/image-20200619145337713.png" alt="image-20200619145337713"></p>
<p>【如果出现中文乱码】</p>
<p>1、原始思路</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/j1&quot;, produces = &quot;application/json;charset=utf-8&quot;)</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20200619145524809.png" alt="image-20200619145524809"></p>
<p>2、SpringMVC的做法</p>
<p>在<code>spingmvc-servlet.xml</code>配置文件中添加Jackson的有关配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--JSON乱码问题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;failOnEmptyBeans&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20200619150231895.png" alt="image-20200619150231895"></p>
<p>一些技巧：</p>
<ul>
<li><p><code>@RestController</code>注解如果加在类上，那么这个类返回的结果全部是字符串</p>
</li>
<li><p><code>@RestController</code>等于<code>@Controller</code>加<code>@ResponseBody</code>，两者不能同时用</p>
</li>
</ul>
<h3 id="显示时间"><a href="#显示时间" class="headerlink" title="显示时间"></a>显示时间</h3><h4 id="原始方式——自定义时间格式"><a href="#原始方式——自定义时间格式" class="headerlink" title="原始方式——自定义时间格式"></a>原始方式——自定义时间格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/j3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">json3</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jackson ObjectMapper</span></span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义时间格式</span></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是时间戳：Timestamp</span></span><br><span class="line">    String str = mapper.writeValueAsString(sdf.format(date));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="../images/image-20200619153044285.png" alt="image-20200619153044285"></p>
<h4 id="Jackson方式"><a href="#Jackson方式" class="headerlink" title="Jackson方式"></a>Jackson方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/j3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">json3</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jackson ObjectMapper</span></span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不使用时间戳的格式</span></span><br><span class="line">    mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, <span class="keyword">false</span>);</span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义时间格式</span></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    mapper.setDateFormat(sdf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是时间戳：Timestamp</span></span><br><span class="line">    <span class="comment">//        String str = mapper.writeValueAsString(sdf.format(date));</span></span><br><span class="line"></span><br><span class="line">    String str = mapper.writeValueAsString(date);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>效果相同的</p>
<h3 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tcmyxc.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializationFeature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载，如果传入的不是一个Date对象，那么设置时间格式对其没有影响，如果是Date对象，那就能起作用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getJson</span><span class="params">(Object object)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getJson(object, <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getJson</span><span class="params">(Object object, String dateFormat)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, <span class="keyword">false</span>);<span class="comment">// 禁用时间戳</span></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(dateFormat);<span class="comment">// 自定义时间格式</span></span><br><span class="line">        mapper.setDateFormat(sdf);</span><br><span class="line">        <span class="keyword">return</span> mapper.writeValueAsString(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/j2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">json2</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">    User user1 = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;徐文祥&quot;</span>, <span class="number">24</span>);</span><br><span class="line">    User user2 = <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">&quot;徐文祥&quot;</span>, <span class="number">24</span>);</span><br><span class="line">    User user3 = <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">&quot;徐文祥&quot;</span>, <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">    userList.add(user1);</span><br><span class="line">    userList.add(user2);</span><br><span class="line">    userList.add(user3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonUtil.getJson(userList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/j3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">json3</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JsonUtil.getJson(<span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>了解思想即可，注意方法重载是可以互相调用的。</p>
<h3 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h3><ul>
<li>一个 Java 库，可以将 Java 对象转换为 JSON 格式，也可以将 JSON 字符串转换为 Java 对象。</li>
<li>toJSONString方法即可将对象转换成 JSON 字符串</li>
<li>parseObject 方法则反过来将 JSON 字符串转换成对象</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.68<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/j4&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">json4</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">    User user1 = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;徐文祥&quot;</span>, <span class="number">24</span>);</span><br><span class="line">    User user2 = <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">&quot;徐文祥&quot;</span>, <span class="number">24</span>);</span><br><span class="line">    User user3 = <span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">&quot;徐文祥&quot;</span>, <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">    userList.add(user1);</span><br><span class="line">    userList.add(user2);</span><br><span class="line">    userList.add(user3);</span><br><span class="line"></span><br><span class="line">    String string = JSON.toJSONString(userList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="../images/image-20200619171516976.png" alt="image-20200619171516976"></p>
<p>公司让用哪个就用那个</p>
<h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE ssmbuild;</span><br><span class="line">USE ssmbuild;</span><br><span class="line">CREATE TABLE `books`(</span><br><span class="line">`bookID` INT NOT NULL AUTO_INCREMENT COMMENT &#x27;书id&#x27;,</span><br><span class="line">`bookName` VARCHAR(100) NOT NULL COMMENT &#x27;书名&#x27;,</span><br><span class="line">`bookCounts` INT NOT NULL COMMENT &#x27;数量&#x27;,</span><br><span class="line">`detail` VARCHAR(200) NOT NULL COMMENT &#x27;描述&#x27;,</span><br><span class="line">KEY `bookID`(`bookID`)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES</span><br><span class="line">(1,&#x27;Java&#x27;,1,&#x27;从入门到放弃&#x27;),</span><br><span class="line">(2,&#x27;MySQL&#x27;,10,&#x27;从删库到跑路&#x27;),</span><br><span class="line">(3,&#x27;Linux&#x27;,5,&#x27;从进门到进牢&#x27;);</span><br></pre></td></tr></table></figure>



<h3 id="新建一个maven项目"><a href="#新建一个maven项目" class="headerlink" title="新建一个maven项目"></a>新建一个maven项目</h3><p>【注意】c3p0连接池警告解决方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--c3p0的私有属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--下面这句话可以显式配置，如果不配置，也会默认帮我们做，</span></span><br><span class="line"><span class="comment">      因为c3p0默认是3个，但是我们最小配了10个，所有会覆盖默认配置，</span></span><br><span class="line"><span class="comment">      如果不配，会报一个警告：Bad pool size config, start 3 &lt; min 10. Using 10 as start.</span></span><br><span class="line"><span class="comment">      其实没啥影响</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--关闭连接不自动commit--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoCommitOnClose&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--获取连接超时时间--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接失败后的重试次数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireRetryAttempts&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记</title>
    <url>/archives/52ba89f4.html</url>
    <content><![CDATA[<p><img src="../images/spring-logo-9146a4d3298760c2e7e49595184e1975-1625654674518.svg"></p>
<span id="more"></span>

<h1 id="Spring简介"><a href="#Spring简介" class="headerlink" title="Spring简介"></a>Spring简介</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>◆目的：解决企业应用开发的复杂性</p>
<p>◆功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能</p>
<p>◆范围：任何Java应用</p>
<p>Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。</p>
<ul>
<li>2002年，Rod Jahnson（音乐学博士）出版的《Expert One-on-One J2EE Design and Development》，第一次出现了Spring的一些核心思想，雏形框架：interface21框架</li>
<li>2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版</li>
<li>Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架</li>
</ul>
<p>官网：<a href="https://spring.io/projects/spring-framework">https://spring.io/projects/spring-framework</a></p>
<p>官方下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a></p>
<p>中文文档：<a href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference">https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference</a></p>
<p>GitHub:<a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p>
<p>Maven:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一般来说，第一个够用了 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>一个开源的免费的框架</li>
<li>轻量级、非入侵式（集成了Spring之后不会影响原有的项目）的框架</li>
<li>控制反转（IOC）、面向切面编程（AOP）</li>
<li>支持事务的处理，对框架整合的支持</li>
</ul>
<p>==Spring是一个轻量级的控制反转（IOC）和面向切面编程(AOP)的框架==</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><img src="../images/1219227-20170930225010356-45057485-1625654784401.gif" alt="img" style="zoom:150%;" />



<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>现代化的java开发</p>
<ul>
<li>Spring Boot<ul>
<li>一个快速开发的脚手架</li>
<li>基于Spring Boot可以快速开发单个微服务</li>
<li>约定大于配置</li>
</ul>
</li>
<li>Spring Cloud<ul>
<li>Spring Cloud是基于Spring Boot实现的</li>
</ul>
</li>
</ul>
<p>==多数人都在用，Spring和SpringMVC是最最基础的==</p>
<p>弊端：发展了太久之后，违背了原来的理念！配置十分繁琐</p>
<h1 id="IOC理论"><a href="#IOC理论" class="headerlink" title="IOC理论"></a>IOC理论</h1><blockquote>
<p>比如说，Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。</p>
<p>采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。</p>
<p>IOC，我不要去创建了，别人创建好了，我直接拿来用</p>
</blockquote>
<p>控制反转：要实现不同的操作，只需要在xml配置文件中修改，<strong>对象让Spring来创建，管理，装配</strong></p>
<h2 id="IOC思想的简单解释"><a href="#IOC思想的简单解释" class="headerlink" title="IOC思想的简单解释"></a>IOC思想的简单解释</h2><p>传统方法：</p>
<ol>
<li>User接口</li>
<li>User实现类</li>
<li>UserService接口</li>
<li>UserService实现类</li>
<li>用户调用UserService实现类</li>
</ol>
<p><strong>上面的方法需要根据用户需求修改源代码，程序员自己去new对象</strong></p>
<p>革命性变化：让用户选择实现哪个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用set接口进行动态实现值得注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户实际使用的是业务层，DAO层用户不需要接触</span></span><br><span class="line">    UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让用户选择实现哪一个类（用户主动创建对象）</span></span><br><span class="line">    userService.setUserDao(<span class="keyword">new</span> UserOracleImpl());</span><br><span class="line"></span><br><span class="line">    userService.getUserService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>使用set注入之后，让用户自己创建对象</li>
</ul>
<p><strong>让用户自己去new自己想要的对象，用户选择自己需要的接口</strong></p>
<img src="../images/image-20200608203856946-1625654784402.png" alt="image-20200608203856946" style="zoom:125%;" />



<p>==<strong>本来程序员控制怎么new对象，现在换成用户自己new对象</strong>==</p>
<p>降低程序耦合性，程序员只需要专注业务实现即可</p>
<p>上面就是IOC的思想！！！</p>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p><img src="../images/container-magic-1625654784402.png" alt="container magic"></p>
<h1 id="IOC创建对象的方式"><a href="#IOC创建对象的方式" class="headerlink" title="IOC创建对象的方式"></a>IOC创建对象的方式</h1><ol>
<li><p>使用无参构造创建对象，默认（但是一般满足不了需求，比如一个类有多个属性）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;徐文祥&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>假如要使用有参构造创建对象</p>
<ol>
<li>下标赋值</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xwx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>参数类型匹配（不建议用）</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xwx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用参数名（建议使用）</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xwx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>自己写Spring的步骤：</p>
<ol>
<li>创建一个java bean</li>
<li>在配置文件注册bean</li>
<li>从配置文件获取容器</li>
<li>从容器中拿对象</li>
</ol>
<p>IOC创建对象一次性把注册的bean的对象全部创建，并且只创建一次</p>
<p><img src="../images/image-20200609002036061-1625654784402.png" alt="image-20200609002036061"></p>
<h1 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h1><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--别名--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;newUser&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="bean的配置"><a href="#bean的配置" class="headerlink" title="bean的配置"></a>bean的配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	id : bean 的唯一标识</span></span><br><span class="line"><span class="comment">	class : bean 对象所对应的全限定名 ： 包名 + 类型</span></span><br><span class="line"><span class="comment">	name : 也是别名，更高级，可以同时取多个别名</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.User2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user22,user23&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xwx&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>团队开发使用，合并配置文件用的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beans.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="依赖注入（Dependency-Injection）"><a href="#依赖注入（Dependency-Injection）" class="headerlink" title="依赖注入（Dependency Injection）"></a>依赖注入（Dependency Injection）</h1><p>依赖注入是IOC的实现</p>
<p>原始博客：<a href="https://martinfowler.com/articles/injection.html#InversionOfControl">https://martinfowler.com/articles/injection.html#InversionOfControl</a></p>
<ul>
<li>原始的文章（马丁富勒）提出了三种方法：构造函数注入，Setter注入和接口注入</li>
<li>Spring实现了两种，set注入和构造函数，官方和马丁福勒都提倡构造，但是大家一般喜欢set</li>
</ul>
<p>本质是set注入，必须有set方法，如果真的没有setf方法，那就只能通过构造函数来注入</p>
<p>依赖：bean 对象的创建依赖于容器</p>
<p>注入：bean 对象中的所有属性，由容器来注入</p>
<ul>
<li><p>可以混合使用基于构造函数的DI和基于设定值的DI</p>
</li>
<li><p>将构造函数用于强制性依赖项并将setter方法或配置方法用于可选依赖性是一个很好的经验法则。</p>
</li>
<li><p>可以 在setter方法上使用<a href="#beans-required-annotation">@Required</a>批注，以使该属性成为必需的依赖项。但是，最好使用带有参数的程序验证的构造函数注入。</p>
</li>
<li><p>Spring团队通常<strong>提倡构造函数注入</strong>，因为它可以让您将应用程序组件实现为不可变对象，并确保不存在必需的依赖项<code>null</code></p>
</li>
<li><p>构造函数注入的组件始终以完全初始化的状态返回到客户端（调用）代码</p>
</li>
<li><p>Setter注入主要应用于可以在类中分配合理的默认值的可选依赖项。否则，必须在代码使用依赖项的任何地方执行非空检查。setter注入的一个好处是，setter方法可使该类的对象在以后重新配置或重新注入</p>
</li>
<li><p><code>如果第三方类未公开任何setter方法，则构造函数注入可能是DI的唯一可用形式</code>。</p>
</li>
</ul>
<p>【环境搭建】</p>
<p>1、复杂类型</p>
<p>2、真实测试对象</p>
<h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><p>第三大点已经说过</p>
<h2 id="Set方式注入【重点】"><a href="#Set方式注入【重点】" class="headerlink" title="Set方式注入【重点】"></a>Set方式注入【重点】</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.Address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;杭州&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--普通注入，value--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;徐文祥&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--bean注入，ref--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--数组注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--list注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>吃饭<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>睡觉<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>打豆豆<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--map--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;身份证&quot;</span> <span class="attr">value</span>=<span class="string">&quot;122525212152525&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;学生卡&quot;</span> <span class="attr">value</span>=<span class="string">&quot;122525212152525&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--set--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>lol<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>碧蓝航线<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>阴阳师<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--null--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;wife&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--properties--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;性别&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;学号&quot;</span>&gt;</span>3152555666<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="拓展方式"><a href="#拓展方式" class="headerlink" title="拓展方式"></a>拓展方式</h2><p>p 命名空间和 c 命名空间</p>
<ul>
<li>the p-namespace lets you use the <code>bean</code> element’s attributes (instead of nested <code>&lt;property/&gt;</code> elements) to describe your property values collaborating beans, or both.</li>
<li>the c-namespace, introduced in Spring 3.1, allows inlined attributes for configuring the constructor arguments rather then nested <code>constructor-arg</code> elements.</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--P命名空间 : 就是属性，可以直接注入属性的值，必须有无参构造--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;xwx&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;24&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--C命名空间 : 构造器注入--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;徐文祥&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;24&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;userbean.xml&quot;</span>);</span><br><span class="line">    User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    User user2 = context.getBean(<span class="string">&quot;user2&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>【注意点】</p>
<ul>
<li>需要导入约束</li>
<li>P命名空间必须有无参构造</li>
<li>C命名空间必须有有参构造</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><img src="../images/image-20200614171513131-1625654784402.png" alt="image-20200614171513131"></p>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>默认的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;徐文祥&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;24&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>每次从容器中get对象，都会创建一个新的出来</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;xwx&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;24&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 测试作用域：单例以及原型</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;userbean.xml&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;================原型===========&quot;</span>);</span><br><span class="line">    User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">    User user2 = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user.hashCode()==user2.hashCode());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;================单例===========&quot;</span>);</span><br><span class="line">    User user3 = context.getBean(<span class="string">&quot;user2&quot;</span>, User.class);</span><br><span class="line">    User user4 = context.getBean(<span class="string">&quot;user2&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user3.hashCode()==user4.hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="../images/image-20200614172526855-1625654784402.png" alt="image-20200614172526855"></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>只能在web开发中使用</p>
<h1 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h1><ul>
<li>Spring满足bean依赖的一种方式</li>
<li>Spring会在上下文中寻找，并自动给bean装配属性</li>
</ul>
<p>三种装配的方式：</p>
<ul>
<li>在xml文件中显式配置</li>
<li>在java中显式配置</li>
<li>隐式的自动装配bean【重要】</li>
</ul>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>一个人有一只猫和一只狗</p>
<h2 id="byName"><a href="#byName" class="headerlink" title="byName"></a>byName</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> byName : 会自动在容器上下文中查找，和自己对象set方法后面的值对应的 beanid </span></span><br><span class="line"><span class="comment"> byType : 会自动在容器上下文中查找，和自己对象属性相同的 bean </span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;徐文祥&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="byType"><a href="#byType" class="headerlink" title="byType"></a>byType</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> byName : 会自动在容器上下文中查找，和自己对象set方法后面的值对应的 beanid</span></span><br><span class="line"><span class="comment"> byType : 会自动在容器上下文中查找，和自己对象属性相同的 bean</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;徐文祥&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>小结：</p>
<ul>
<li>byName需要所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致</li>
<li>byType需要所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致，可以省略id</li>
</ul>
<h2 id="使用注解实现自动装配"><a href="#使用注解实现自动装配" class="headerlink" title="使用注解实现自动装配"></a>使用注解实现自动装配</h2><p>使用注解须知：</p>
<ul>
<li><p>导入约束</p>
</li>
<li><p>==<strong>配置注解的支持</strong>==<code>&lt;context:annotation-config/&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Autowired【大家用的最多】"><a href="#Autowired【大家用的最多】" class="headerlink" title="@Autowired【大家用的最多】"></a>@Autowired【大家用的最多】</h3><p>直接在属性上使用即可，也可以在set方法上使用（构造方法也行，还有一些其他的，不过那些都不重要）</p>
<p>使用Autowired，可以不写set方法，但是这个自动装配的属性必须在IOC容器中存在且符合</p>
<p>科普：</p>
<ol>
<li>字段上**@Nullable**这个注解一加，说明允许为空</li>
<li></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认是true，如果显式定义为false，说明属性可以为空</p>
<ol start="3">
<li>如果环境复杂，自动装配无法通过@Autowired唯一定义，可以结合使用@Qualifier(value=”xxx”)来指定唯一的bean对象注入</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog11&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog222&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.pojo.Dog&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value=&quot;dog222&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>@Resource也可以自动装配，id和class至少要匹配一个，不然就会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>@Autowired和@Resource</p>
<ul>
<li>都是自动装配，都可以防止属性字段上</li>
<li>@Autowired是通过byType实现的，要求这个bean对象必须存在</li>
<li>@Resource默认byName，如果没有，之后byType，啥都没有就报错</li>
</ul>
<h1 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h1><p>在Spring4之后，想要使用注解开发，必须保证AOP的包被导入了</p>
<p>开启注解支持</p>
<p>【注意】这里的文件名就需要规范起来了，也就是<code>applicationContext.xml</code>不然会报找不到主类的错误</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--开启注解支持--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol>
<li><p>bean</p>
</li>
<li><p>属性如何注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 这个注解等价于 &lt;bean id=&quot;user&quot; class=&quot;com.tcmyxc.pojo.User&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  @Value(&quot;徐文祥&quot;)放这里也行，就不需要set方法了</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;徐文祥&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>衍生的注解（都是组件的意思，和@Component一样，都是说把某个类注册到容器中，只不过在MVC架构不同的层罢了）</p>
<ul>
<li>dao【@Repository】</li>
<li>service【@Service】</li>
<li>controller【@Controller】</li>
</ul>
</li>
<li><p>自动装配配置</p>
</li>
<li><p>作用域</p>
<p>@Scope</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 这个注解等价于 &lt;bean id=&quot;user&quot; class=&quot;com.tcmyxc.pojo.User&quot;/&gt;</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  @Value(&quot;徐文祥&quot;)放这里也行，就不需要set方法了</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;徐文祥&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>小结</p>
<ul>
<li>xml与注解<ul>
<li>xml更万能，适用任何场合，维护方便</li>
<li>注解更简单，但是不是自己的类使用不了，维护复杂</li>
</ul>
</li>
</ul>
</li>
<li><p>最佳实践</p>
<ul>
<li>xml管理bean，注解只用来属性的注入</li>
<li>使用过程中需要注意：==必须要让注解生效（在配置文件开启注解支持）==</li>
</ul>
</li>
</ol>
<h1 id="基于Java方式配置Spring"><a href="#基于Java方式配置Spring" class="headerlink" title="基于Java方式配置Spring"></a>基于Java方式配置Spring</h1><p>完全不使用xml配置，全部放在java代码中搞</p>
<p>Java-configuration 是Spring的一个子项目，在Spring4之后，成为一个核心功能</p>
<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 意思是把这个类放到容器里，让Spring接管</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;xwx&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 这个也会被注册到容器中，本身也是一个component</span></span><br><span class="line"><span class="comment">// 等价于xml文件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.tcmyxc.pojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个bean，相当于xml文件中的bean标签，方法名是标签的id</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果使用java配置类的方法，那么需要使用 AnnotationConfigApplicationContext</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//User user = context.getBean(&quot;getUser&quot;, User.class);// 方法名就是bean的名字</span></span><br><span class="line">        <span class="comment">//User user = context.getBean(&quot;user&quot;, User.class);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果方法名和是类名的小写，下面的也可以</span></span><br><span class="line">        User user = context.getBean(User.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>截图：</p>
<p><img src="../images/image-20200615121136136-1625654784402.png" alt="image-20200615121136136"></p>
<p>纯java的方式在SpringBoot随处可见</p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式是SpringAOP的底层</p>
<p>分类：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>好处：</p>
<ul>
<li>代理可以使真实角色更加纯粹，不需要关系公共业务</li>
<li>公共的业务交给代理来做，实现了业务的分工</li>
<li>公共业务发生拓展的时候，方便集中管理</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色会产生一个代理角色，代码量会翻倍，开发的效率会变低</li>
</ul>
<h2 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a>加深理解</h2><p>聊聊AOP</p>
<p><img src="../images/image-20200615170952410-1625654784402.png" alt="image-20200615170952410"></p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul>
<li>使用反射</li>
<li>动态代理和静态代理角色一样</li>
<li>动态代理的代理类是动态生成的</li>
<li>分为两大类：基于接口，基于类<ul>
<li>基于接口：JDK动态代理</li>
<li>基于类：cglib</li>
<li>java字节码实现：javasist</li>
</ul>
</li>
</ul>
<blockquote>
<p>CGLib (Code Generation Library) 是一个强大的,高性能,高质量的Code生成类库。</p>
<p>它可以在运行期扩展Java类与实现Java接口。</p>
<p>Hibernate用它来实现PO字节码的动态生成。</p>
<p>CGLib 比 Java 的 java.lang.reflect.Proxy 类更强的在于它不仅可以接管接口类的方法，还可以接管普通类的方法。</p>
<p>CGLib 的底层是Java字节码操作框架 —— <a href="http://www.oschina.net/p/asm">ASM</a>。</p>
</blockquote>
<p>需要了解两个类：</p>
<p>Proxy：一个类，代理</p>
<ul>
<li><code>Proxy</code>提供了创建动态代理类和实例的静态方法</li>
</ul>
<p>InvocationHandler：一个接口，调用处理程序，并返回结果</p>
<p>【总结】</p>
<p>好处：</p>
<ul>
<li>静态有的它都有</li>
<li>动态代理类代理的是接口，一般对应的是一类业务</li>
<li>一个动态代理类可以代理多个类，只要实现了同一个接口</li>
</ul>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h2><p><strong>在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</strong></p>
<p>一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。</p>
<p>通过<a href="https://baike.baidu.com/item/%E9%A2%84%E7%BC%96%E8%AF%91">预编译</a>方式和运行其动态代理实现在不修改<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81">源代码</a>的情况下给程序动态统一添加功能的一种技术</p>
<blockquote>
<p>AOP为Aspect Oriented Programming的缩写，意为：<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/6016335">面向切面编程</a>，通过<a href="https://baike.baidu.com/item/%E9%A2%84%E7%BC%96%E8%AF%91/3191547">预编译</a>方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是<a href="https://baike.baidu.com/item/OOP">OOP</a>的延续，是软件开发中的一个热点，也是<a href="https://baike.baidu.com/item/Spring">Spring</a>框架中的一个重要内容，是<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/4035031">函数式编程</a>的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的<a href="https://baike.baidu.com/item/%E8%80%A6%E5%90%88%E5%BA%A6/2603938">耦合度</a>降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p>——百度百科</p>
</blockquote>
<p><img src="../images/image-20200615182436583-1625654784402.png" alt="image-20200615182436583"></p>
<p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy去进行代理了。这时候Spring AOP会使用<strong>Cglib</strong>，生成一个被代理对象的子类，来作为代理，放一张图出来就明白了：</p>
<p><img src="../images/v2-e777957e808c92fefcbcbec3945a2f91_720w-1625654784402.jpg" alt="img"></p>
<p>上面讲的是AOP的第一种实现，<strong>运行时织入</strong>。</p>
<p><strong>但是不是所有AOP的实现都是在运行时进行织入的，因为这样效率太低了</strong>，而且只能针对方法进行AOP，无法针对构造函数、字段进行AOP。</p>
<h2 id="AOP在Spring中的作用"><a href="#AOP在Spring中的作用" class="headerlink" title="AOP在Spring中的作用"></a>AOP在Spring中的作用</h2><ul>
<li>  提供声明式企业服务。最重要的服务是 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction-declarative">声明式事务管理</a>。</li>
<li>  让用户实现自定义切面，以AOP补充其对OOP的使用。</li>
</ul>
<img src="../images/image-20200615182514889-1625654784402.png" alt="image-20200615182514889"  />

<img src="../images/image-20200615182534173-1625654784403.png" alt="image-20200615182534173"  />

<p><img src="../images/image-20200615191254441-1625654784403.png" alt="image-20200615191254441"></p>
<h2 id="使用Spring实现AOP"><a href="#使用Spring实现AOP" class="headerlink" title="使用Spring实现AOP"></a>使用Spring实现AOP</h2><p>【重点】需要导包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="方式一：使用原生Spring-API接口"><a href="#方式一：使用原生Spring-API接口" class="headerlink" title="方式一：使用原生Spring API接口"></a>方式一：使用原生Spring API接口</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一：使用原生Spring API接口--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  切入点</span></span><br><span class="line"><span class="comment">  expression：表达式</span></span><br><span class="line"><span class="comment">  execution(要执行的位置)</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.tcmyxc.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--执行环绕增加--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;log&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="方式二：使用自定义类来实现AOP【主要是切面定义】"><a href="#方式二：使用自定义类来实现AOP【主要是切面定义】" class="headerlink" title="方式二：使用自定义类来实现AOP【主要是切面定义】"></a>方式二：使用自定义类来实现AOP【主要是切面定义】</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式二：自定义类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diyPointcut&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.diy.DiyPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diyPointcut&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.tcmyxc.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通知--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="方式三：使用注解实现"><a href="#方式三：使用注解实现" class="headerlink" title="方式三：使用注解实现"></a>方式三：使用注解实现</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式三--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;annotationPointcut&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.diy.AnnotationPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启注解支持，默认使用的JDKproxy-target-class=&quot;false&quot; cglibproxy-target-class=&quot;true&quot;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用注解实现AOP</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationPointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.tcmyxc.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========方法执行前========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.tcmyxc.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========方法执行后========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕增强中，可以给定一个参数，代表我们要获取处理切入的点</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.tcmyxc.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========环绕前========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(joinPoint.getSignature());<span class="comment">//打印签名，看看方法是那个</span></span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        Object proceed = joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==========环绕后========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="整合mybatis"><a href="#整合mybatis" class="headerlink" title="整合mybatis"></a>整合mybatis</h1><p>步骤</p>
<ol>
<li>导包<ul>
<li>junit</li>
<li>mybatis</li>
<li>mysql数据库</li>
<li>spring相关</li>
<li>aop织入</li>
<li>mybatis-spring【<a href="http://mybatis.org/spring/zh/index.html%E3%80%91">http://mybatis.org/spring/zh/index.html】</a></li>
</ul>
</li>
<li>编写配置文件</li>
<li>测试</li>
</ol>
<h2 id="回顾mybatis"><a href="#回顾mybatis" class="headerlink" title="回顾mybatis"></a>回顾mybatis</h2><ol>
<li>编写实体类</li>
<li>编写核心配置文件</li>
<li>编写接口</li>
<li>编写mapper.xml文件</li>
<li>注册mapper</li>
<li>测试</li>
</ol>
<h2 id="mybatis-spring"><a href="#mybatis-spring" class="headerlink" title="mybatis-spring"></a>mybatis-spring</h2><p><strong>什么是mybatis-spring？</strong></p>
<p>MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 <code>SqlSession</code> 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 <code>DataAccessException</code>。最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。</p>
<p>官网：<a href="http://mybatis.org/spring/zh/index.html">http://mybatis.org/spring/zh/index.html</a></p>
<ol>
<li>编写数据源配置</li>
<li>sqlSessionFactory</li>
<li>sqlSessionTemplate</li>
<li>需要给接口加实现类</li>
<li>将实现类注入到Spring</li>
<li>测试</li>
</ol>
<h1 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h1><p>ACID原则：</p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
<h2 id="Spring中的事务管理"><a href="#Spring中的事务管理" class="headerlink" title="Spring中的事务管理"></a>Spring中的事务管理</h2><ul>
<li>声明式事务：AOP【常用】</li>
<li>编程式事务</li>
</ul>
<p>为什么需要事务？</p>
<ul>
<li>如果不配置事务，可能存在数据提交不一致的情况</li>
<li>如果不在spring中配置声明式事务，就需要在代码中手动配置事务</li>
<li>事务在开发中很重要</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/archives/14ea6df7.html</url>
    <content><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h2><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p>
<p>关系数据库管理系统(Relational Database Management System)的特点：</p>
<ul>
<li>  1.数据以表格的形式出现</li>
<li>  2.每行为各种记录名称</li>
<li>  3.每列为记录名称所对应的数据域</li>
<li>  4.许多的行和列组成一张表单</li>
<li>  5.若干的表单组成database</li>
</ul>
<span id="more"></span>

<h2 id="几个术语"><a href="#几个术语" class="headerlink" title="几个术语"></a>几个术语</h2><ul>
<li>  <strong>主键</strong>：<strong>主键是唯一的</strong>。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>
<li>  <strong>外键：</strong>外键用于关联两个表。</li>
<li>  <strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>
<li>  <strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>
</ul>
<h2 id="create-创建数据库"><a href="#create-创建数据库" class="headerlink" title="create 创建数据库"></a>create 创建数据库</h2><p>我们可以在登陆 MySQL 服务后，使用 <strong>create</strong> 命令创建数据库，语法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名;</span><br></pre></td></tr></table></figure>

<h2 id="drop-删除数据库"><a href="#drop-删除数据库" class="headerlink" title="drop 删除数据库"></a>drop 删除数据库</h2><p>drop 命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="use-选择-MySQL-数据库"><a href="#use-选择-MySQL-数据库" class="headerlink" title="use 选择 MySQL 数据库"></a>use 选择 MySQL 数据库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure>

<h2 id="创建-MySQL-数据表"><a href="#创建-MySQL-数据表" class="headerlink" title="创建 MySQL 数据表"></a>创建 MySQL 数据表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name (column_name column_type);</span><br></pre></td></tr></table></figure>



<p>创建数据表runoob_tbl：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `runoob_tbl`(</span><br><span class="line">   `runoob_id` INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">   `runoob_title` VARCHAR(100) NOT NULL,</span><br><span class="line">   `runoob_author` VARCHAR(40) NOT NULL,</span><br><span class="line">   `submission_date` DATE,</span><br><span class="line">   PRIMARY KEY ( `runoob_id` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<h2 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE 数据表名;</span><br></pre></td></tr></table></figure>

<h2 id="insert-into-插入数据"><a href="#insert-into-插入数据" class="headerlink" title="insert into 插入数据"></a>insert into 插入数据</h2><p>通用的 <strong>INSERT INTO</strong> SQL语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name ( field1, field2,...fieldN )</span><br><span class="line">                       VALUES</span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure>



<p>如果数据是字符型，必须使用单引号或者双引号，如：”value”。</p>
<h2 id="select-查询数据"><a href="#select-查询数据" class="headerlink" title="select 查询数据"></a>select 查询数据</h2><p>通用的 SELECT 语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name,column_name</span><br><span class="line">FROM table_name</span><br><span class="line">[WHERE Clause]</span><br><span class="line">[LIMIT N][ OFFSET M]</span><br></pre></td></tr></table></figure>



<ul>
<li>  查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</li>
<li>  SELECT 命令可以读取一条或者多条记录。</li>
<li>  你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据</li>
<li>  你可以使用 WHERE 语句来包含任何条件。</li>
<li>  你可以使用 LIMIT 属性来设定返回的记录数。</li>
<li>  你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</li>
</ul>
<h2 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h2><ul>
<li>  查询语句中你可以使用一个或者多个表，表之间使用逗号**,** 分割，并使用WHERE语句来设定查询条件。</li>
<li>  你可以在 WHERE 子句中指定任何条件。</li>
<li>  你可以使用 AND 或者 OR 指定一个或多个条件。</li>
<li>  WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。</li>
<li>  WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。</li>
</ul>
<h2 id="UPDATE-更新"><a href="#UPDATE-更新" class="headerlink" title="UPDATE 更新"></a>UPDATE 更新</h2><p>通用 SQL 语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table_name SET field1=new-value1, field2=new-value2[WHERE Clause]</span><br></pre></td></tr></table></figure>



<ul>
<li>  你可以同时更新一个或多个字段。</li>
<li>  你可以在 WHERE 子句中指定任何条件。</li>
<li>  你可以在一个单独表中同时更新数据。</li>
</ul>
<h2 id="DELETE-语句"><a href="#DELETE-语句" class="headerlink" title="DELETE 语句"></a>DELETE 语句</h2><p>通用语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM table_name [WHERE Clause]</span><br></pre></td></tr></table></figure>



<ul>
<li>  如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。</li>
<li>  你可以在 WHERE 子句中指定任何条件</li>
<li>  您可以在单个表中一次性删除记录。</li>
</ul>
<h2 id="LIKE-子句"><a href="#LIKE-子句" class="headerlink" title="LIKE 子句"></a>LIKE 子句</h2><ul>
<li>  在 where 子句中使用</li>
<li>  使用 <strong>%</strong> 字符来表示任意字符</li>
</ul>
<h2 id="ALTER-命令"><a href="#ALTER-命令" class="headerlink" title="ALTER 命令"></a>ALTER 命令</h2><p>修改数据表名或者修改数据表字段</p>
<h3 id="删除，添加或修改表字段"><a href="#删除，添加或修改表字段" class="headerlink" title="删除，添加或修改表字段"></a>删除，添加或修改表字段</h3><p>如下命令使用了 ALTER 命令及 DROP 子句来删除以上创建表的 i 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl  DROP i;</span><br></pre></td></tr></table></figure>

<p>如果数据表中只剩余一个字段则无法使用DROP来删除字段。</p>
<p>MySQL 中使用 ADD 子句来向数据表中添加列，如下实例在表 testalter_tbl 中添加 i 字段，并定义数据类型:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD i INT;</span><br></pre></td></tr></table></figure>

<h3 id="修改字段类型及名称"><a href="#修改字段类型及名称" class="headerlink" title="修改字段类型及名称"></a>修改字段类型及名称</h3><p>如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。</p>
<p>例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl MODIFY c CHAR(10);</span><br></pre></td></tr></table></figure>

<p>使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。尝试如下实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl CHANGE i j BIGINT;</span><br></pre></td></tr></table></figure>

<p>当你修改字段时，你可以指定是否包含值或者是否设置默认值。</p>
<p>以下实例，指定字段 j 为 NOT NULL 且默认值为100 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl     -&gt; MODIFY j BIGINT NOT NULL DEFAULT 100;</span><br></pre></td></tr></table></figure>

<p>如果你不设置默认值，MySQL会自动设置该字段默认为 NULL。</p>
<p>修改字段默认值</p>
<p>你可以使用 ALTER 来修改字段的默认值，尝试以下实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;</span><br></pre></td></tr></table></figure>



<h2 id="UNION-操作符"><a href="#UNION-操作符" class="headerlink" title="UNION 操作符"></a>UNION 操作符</h2><p>UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。</p>
<p>UNION 操作符语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions];</span><br></pre></td></tr></table></figure>



<ul>
<li>  <strong>DISTINCT:</strong> 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</li>
<li>  <strong>ALL:</strong> 可选，返回所有结果集，包含重复数据。</li>
</ul>
<h2 id="排序（默认升序）"><a href="#排序（默认升序）" class="headerlink" title="排序（默认升序）"></a>排序（默认升序）</h2><p>ORDER BY 子句将查询数据排序后再返回数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN FROM table_name1, table_name2...ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]</span><br></pre></td></tr></table></figure>



<h2 id="分组-GROUP-BY-语句"><a href="#分组-GROUP-BY-语句" class="headerlink" title="分组 GROUP BY 语句"></a>分组 GROUP BY 语句</h2><p>GROUP BY 语句根据一个或多个列对结果集进行分组。</p>
<p>在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。</p>
<h3 id="GROUP-BY-语法"><a href="#GROUP-BY-语法" class="headerlink" title="GROUP BY 语法"></a>GROUP BY 语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name;</span><br></pre></td></tr></table></figure>



<h2 id="多表查询-union"><a href="#多表查询-union" class="headerlink" title="多表查询 union"></a>多表查询 union</h2><ul>
<li>  <strong>INNER JOIN（内连接,或等值连接）</strong>：获取两个表中字段匹配关系的记录。</li>
<li>  <strong>LEFT JOIN（左连接）：</strong>获取左表所有记录，即使右表没有对应匹配的记录。</li>
<li>  <strong>RIGHT JOIN（右连接）：</strong> 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li>
</ul>
<h2 id="NULL-值处理"><a href="#NULL-值处理" class="headerlink" title="NULL 值处理"></a>NULL 值处理</h2><p>查找数据表中列是否为 NULL，必须使用 <strong>IS NULL</strong> 和 <strong>IS NOT NULL</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL;+---------------+--------------+| runoob_author | runoob_count |+---------------+--------------+| 菜鸟教程  | NULL         || Google        | NULL         |+---------------+--------------+2 rows in set (0.01 sec) mysql&gt; SELECT * from runoob_test_tbl WHERE runoob_count IS NOT NULL;+---------------+--------------+| runoob_author | runoob_count |+---------------+--------------+| RUNOOB        | 20           || FK            | 20           |+---------------+--------------+2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>



<h2 id="正则表达式-regexp（瑞杰克斯普）"><a href="#正则表达式-regexp（瑞杰克斯普）" class="headerlink" title="正则表达式 regexp（瑞杰克斯普）"></a>正则表达式 regexp（瑞杰克斯普）</h2><p>MySQL中使用 REGEXP 操作符来进行正则表达式匹配</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">匹配输入字符串的开始位置。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配输入字符串的结束位置。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像 ‘[.\n]’ 的模式。</td>
</tr>
<tr>
<td align="left">[…]</td>
<td align="left">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td>
</tr>
<tr>
<td align="left">[^…]</td>
<td align="left">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。</td>
</tr>
<tr>
<td align="left">p1|p2|p3</td>
<td align="left">匹配 p1 或 p2 或 p3。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td>
</tr>
</tbody></table>
<p>查找name字段中以’st’为开头的所有数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;^st&#x27;;</span><br></pre></td></tr></table></figure>

<p>查找name字段中以’ok’为结尾的所有数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;ok$&#x27;;</span><br></pre></td></tr></table></figure>

<p>查找name字段中包含’mar’字符串的所有数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;mar&#x27;;</span><br></pre></td></tr></table></figure>

<p>查找name字段中以元音字符开头或以’ok’字符串结尾的所有数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;^[aeiou]|ok$&#x27;;</span><br></pre></td></tr></table></figure>



<h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h2><ul>
<li>  在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li>
<li>  事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li>
<li>  事务用来管理 insert,update,delete 语句</li>
</ul>
<h3 id="MYSQL-事务处理主要有两种方法："><a href="#MYSQL-事务处理主要有两种方法：" class="headerlink" title="MYSQL 事务处理主要有两种方法："></a>MYSQL 事务处理主要有两种方法：</h3><p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p>
<ul>
<li>  <strong>BEGIN</strong> 开始一个事务</li>
<li>  <strong>ROLLBACK</strong> 事务回滚</li>
<li>  <strong>COMMIT</strong> 事务确认</li>
</ul>
<p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p>
<ul>
<li>  <strong>SET AUTOCOMMIT=0</strong> 禁止自动提交</li>
<li>  <strong>SET AUTOCOMMIT=1</strong> 开启自动提交</li>
</ul>
<h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><p>索引分单列索引和组合索引。</p>
<p>单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。</p>
<p>组合索引，即一个索引包含多个列。</p>
<p>索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p>
<p>索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p>
<h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX indexName ON table_name (column_name)</span><br></pre></td></tr></table></figure>

<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p>
<h3 id="修改表结构-添加索引"><a href="#修改表结构-添加索引" class="headerlink" title="修改表结构(添加索引)"></a>修改表结构(添加索引)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER table tableName ADD INDEX indexName(columnName)</span><br></pre></td></tr></table></figure>

<h3 id="创建表的时候直接指定"><a href="#创建表的时候直接指定" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mytable(   ID INT NOT NULL,    username VARCHAR(16) NOT NULL,   INDEX [indexName] (username(length))   );  </span><br></pre></td></tr></table></figure>

<h3 id="删除索引的语法"><a href="#删除索引的语法" class="headerlink" title="删除索引的语法"></a>删除索引的语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX [indexName] ON mytable; </span><br></pre></td></tr></table></figure>

<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<h3 id="创建索引-1"><a href="#创建索引-1" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length)) </span><br></pre></td></tr></table></figure>

<h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER table mytable ADD UNIQUE [indexName] (username(length))</span><br></pre></td></tr></table></figure>

<h3 id="创建表的时候直接指定-1"><a href="#创建表的时候直接指定-1" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mytable(   ID INT NOT NULL,    username VARCHAR(16) NOT NULL,   UNIQUE [indexName] (username(length))   );  </span><br></pre></td></tr></table></figure>

<h3 id="使用ALTER-命令添加和删除索引"><a href="#使用ALTER-命令添加和删除索引" class="headerlink" title="使用ALTER 命令添加和删除索引"></a>使用ALTER 命令添加和删除索引</h3><p>有四种方式来添加数据表的索引：</p>
<ul>
<li>  ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li>
<li>  <strong>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):</strong> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li>
<li>  <strong>ALTER TABLE tbl_name ADD INDEX index_name (column_list):</strong> 添加普通索引，索引值可出现多次。</li>
<li>  **ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):**该语句指定了索引为 FULLTEXT ，用于全文索引。</li>
</ul>
<p>以下实例为在表中添加索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD INDEX (c);</span><br></pre></td></tr></table></figure>

<p>你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP INDEX c;</span><br></pre></td></tr></table></figure>


<h3 id="使用-ALTER-命令添加和删除主键"><a href="#使用-ALTER-命令添加和删除主键" class="headerlink" title="使用 ALTER 命令添加和删除主键"></a>使用 ALTER 命令添加和删除主键</h3><p>主键作用于列上（可以一个列或多个列联合主键），添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);</span><br></pre></td></tr></table></figure>

<p>你也可以使用 ALTER 命令删除主键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<p>删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。</p>
<h3 id="显示索引信息"><a href="#显示索引信息" class="headerlink" title="显示索引信息"></a>显示索引信息</h3><p>你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。</p>
<p>尝试以下实例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM table_name; \G........</span><br></pre></td></tr></table></figure>



<h2 id="MySQL-临时表（加个关键字-temporary）"><a href="#MySQL-临时表（加个关键字-temporary）" class="headerlink" title="MySQL 临时表（加个关键字 temporary）"></a>MySQL 临时表（加个关键字 temporary）</h2><p>保存一些临时数据</p>
<p>临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间，也可以手动删除。</p>
<h2 id="MySQL-复制表"><a href="#MySQL-复制表" class="headerlink" title="MySQL 复制表"></a>MySQL 复制表</h2><p> <strong>SHOW CREATE TABLE</strong> 命令获取创建数据表(<strong>CREATE TABLE</strong>) 语句，该语句包含了原数据表的结构，索引等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE targetTable LIKE sourceTable;INSERT INTO targetTable SELECT * FROM sourceTable;</span><br></pre></td></tr></table></figure>



<p>REPL(Read Eval Print Loop:交互式解释器) </p>
<h2 id="获取服务器元数据"><a href="#获取服务器元数据" class="headerlink" title="获取服务器元数据"></a>获取服务器元数据</h2><p>以下命令语句可以在 MySQL 的命令提示符使用</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SELECT VERSION( )</td>
<td align="left">服务器版本信息</td>
</tr>
<tr>
<td align="left">SELECT DATABASE( )</td>
<td align="left">当前数据库名 (或者返回空)</td>
</tr>
<tr>
<td align="left">SELECT USER( )</td>
<td align="left">当前用户名</td>
</tr>
<tr>
<td align="left">SHOW STATUS</td>
<td align="left">服务器状态</td>
</tr>
<tr>
<td align="left">SHOW VARIABLES</td>
<td align="left">服务器配置变量</td>
</tr>
</tbody></table>
<h2 id="MySQL-序列使用"><a href="#MySQL-序列使用" class="headerlink" title="MySQL 序列使用"></a>MySQL 序列使用</h2><p>MySQL 序列是一组整数：1, 2, 3, …，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。</p>
<ul>
<li>  使用 AUTO_INCREMENT 来定义序列</li>
<li>  使用 LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值</li>
</ul>
<h2 id="防止SQL注入"><a href="#防止SQL注入" class="headerlink" title="防止SQL注入"></a>防止SQL注入</h2><p>注意以下几个要点：</p>
<ul>
<li>  1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双”-“进行转换等。</li>
<li>  2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。</li>
<li>  3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li>
<li>  4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。</li>
<li>  5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装</li>
<li>  6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。</li>
</ul>
<h2 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h2><p>使用 SELECT … INTO OUTFILE 语句导出数据</p>
<p>可以通过命令选项来设置数据输出的指定格式，以下实例为导出 CSV 格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM passwd INTO OUTFILE &#x27;/tmp/runoob.txt&#x27;    -&gt; FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;&quot;&#x27;    -&gt; LINES TERMINATED BY &#x27;\r\n&#x27;;</span><br></pre></td></tr></table></figure>



<h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><h3 id="source-命令导入"><a href="#source-命令导入" class="headerlink" title="source 命令导入"></a>source 命令导入</h3><p>source 命令导入数据库需要先登录到数库终端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database abc;      # 创建数据库mysql&gt; use abc;                  # 使用已创建的数据库 mysql&gt; set names utf8;           # 设置编码mysql&gt; source /home/abc/abc.sql  # 导入备份数据库</span><br></pre></td></tr></table></figure>



<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p>  菜鸟论坛</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis学习笔记</title>
    <url>/archives/7fd48667.html</url>
    <content><![CDATA[<p><img src="../images/mybatis-logo.png" alt="MyBatis logo"></p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>MyBatis 是一款优秀的<strong>持久层框架</strong></li>
<li>它支持自定义 SQL、存储过程以及高级映射。</li>
<li>MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。</li>
<li>MyBatis 可以通过简单的 <strong>XML 或注解</strong>来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li>
</ul>
<p>中文文档：<a href="https://mybatis.org/mybatis-3/zh/getting-started.html">https://mybatis.org/mybatis-3/zh/getting-started.html</a></p>
<ul>
<li>每个基于 MyBatis 的应用都是以一个 <strong>SqlSessionFactory</strong> 的实例为核心的。</li>
<li>SqlSessionFactory 的实例可以通过 <strong>SqlSessionFactoryBuilder</strong> 获得。</li>
<li>而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</li>
</ul>
<p><img src="../images/image-20210110191228913-1625652999701.png" alt="image-20210110191228913"></p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><h3 id="新建基础数据库"><a href="#新建基础数据库" class="headerlink" title="新建基础数据库"></a>新建基础数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database mybatis;</span><br><span class="line">use mybatis;</span><br><span class="line">create table user(</span><br><span class="line">	id int(20) not null primary key,</span><br><span class="line">	name varchar(30) default null,</span><br><span class="line">	pwd varchar(30) default null</span><br><span class="line">)engine=innodb default charset=utf8;</span><br></pre></td></tr></table></figure>

<h3 id="IDEA项目创建"><a href="#IDEA项目创建" class="headerlink" title="IDEA项目创建"></a>IDEA项目创建</h3><h4 id="新建maven项目"><a href="#新建maven项目" class="headerlink" title="新建maven项目"></a>新建maven项目</h4><p><img src="../images/image-20200603153745867-1625652999702.png" alt="image-20200603153745867"></p>
<h4 id="删除src文件夹（将其作为一个父工程）"><a href="#删除src文件夹（将其作为一个父工程）" class="headerlink" title="删除src文件夹（将其作为一个父工程）"></a>删除src文件夹（将其作为一个父工程）</h4><p><img src="../images/image-20200603153920975-1625652999702.png" alt="image-20200603153920975"></p>
<h4 id="在pom-xml文件中添加依赖"><a href="#在pom-xml文件中添加依赖" class="headerlink" title="在pom.xml文件中添加依赖"></a>在<code>pom.xml</code>文件中添加依赖</h4><p>依赖去maven仓库找，找个用的人最多的就行。</p>
<p>mybatis依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--版本填自己的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>较为全面的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置资源导出，防止资源导出失败，下面这些配置需要放在父工程，如果出现问题，则在相应的子工程也引入即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在build中配置resource，防止资源导出失败--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="新建一个module"><a href="#新建一个module" class="headerlink" title="新建一个module"></a>新建一个module</h4><h4 id="在子项目resources目录下新建配置文件"><a href="#在子项目resources目录下新建配置文件" class="headerlink" title="在子项目resources目录下新建配置文件"></a>在子项目<code>resources</code>目录下新建配置文件</h4><ul>
<li>文件名一般是<strong>mybatis-config.xml</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">		<span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">		<span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--配置环境，可以配置多个环境，同时可以指定默认环境--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--开发环境--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="新建一个工具类"><a href="#新建一个工具类" class="headerlink" title="新建一个工具类"></a>新建一个工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tcmyxc.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SqlSessionFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用mybatis获取SqlSessionFactory对象</span></span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。</span></span><br><span class="line">    <span class="comment">// SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。</span></span><br><span class="line">    <span class="comment">// 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得 SqlSession 的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h4><ul>
<li><p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tcmyxc.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, pwd=&#x27;&quot;</span> + pwd + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>DAO接口（DAO，数据库访问对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tcmyxc.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tcmyxc.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接口实现类（由原来的接口实现类转换为mapper配置文件）</p>
<p><strong>UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">		<span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">		<span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace=绑定一个对应的Dao/Mapper接口，命名空间需要改成自己的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.tcmyxc.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--查询语句--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--id是接口中的方法名--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span>&gt;</span></span><br><span class="line">		/*这里写具体的SQL语句*/</span><br><span class="line">		select * from user;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>注意点：</p>
<p><code>org.apache.ibatis.binding.BindingException: Type interface com.tcmyxc.dao.UserDao is not known to the MapperRegistry.</code></p>
<p><strong>MapperRegistry是什么？</strong></p>
<p>核心配置文件注册<strong>mapper</strong> !</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个mapper配置文件都需要在mybatis核心配置文件中注册--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/tcmyxc/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>junit测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tcmyxc.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tcmyxc.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.tcmyxc.utils.MybatisUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取sqlSession</span></span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行SQL语句</span></span><br><span class="line">        <span class="comment">// 方式一：使用mapper</span></span><br><span class="line">        UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">        List&lt;User&gt; userList = mapper.getUserList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭sqlSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用mybatis增删改查（增删改需要提交事务）"><a href="#使用mybatis增删改查（增删改需要提交事务）" class="headerlink" title="使用mybatis增删改查（增删改需要提交事务）"></a>使用mybatis增删改查（增删改需要提交事务）</h2><ul>
<li>编写接口</li>
<li>编写对应mapper中的sql语句</li>
<li>注册mapper.xml文件</li>
<li>测试</li>
</ul>
<p>三个文件依次是接口文件，接口mapper文件，junit测试文件</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据ID查询用户</span></span><br><span class="line"><span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这里#&#123;&#125;里面填写的是getUserById方法的形参--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取sqlSession</span></span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行SQL语句</span></span><br><span class="line">    UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">    User user = mapper.getUserById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭sqlSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加用户</span></span><br><span class="line"><span class="comment">//int addUser(int id, String username, String password);傻孩子，插入一个用户，参数就写用户就行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--增加用户--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对象中的属性可以直接取出来，这里#&#123;&#125;里面填写的是User对象的属性（字段）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    insert into user(id, name, pwd) values(#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取sqlSession</span></span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行SQL语句</span></span><br><span class="line">    UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">    mapper.addUser(<span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">&quot;哈哈哈&quot;</span>, <span class="string">&quot;123456&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭sqlSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--删除用户--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    delete from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--修改用户信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    update user set pwd = #&#123;pwd&#125;, name = #&#123;name&#125; where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="万能的Map"><a href="#万能的Map" class="headerlink" title="万能的Map"></a>万能的Map</h3><p>假设，实体类中或者数据库中字段过多，要考虑使用map</p>
<p>野路子，最万能！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 万能的map</span><br><span class="line">User getUserById2(Map&lt;String, Object&gt; map);</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--万能的map--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from user where id = #&#123;userId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;userId&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    User user = mapper.getUserById2(map);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map传递参数，直接在sql中取出key即可！</p>
<p>对象传递参数，直接在sql中取对象的属性即可！</p>
<p>只有一个基本参数类型的情况，可以省略<strong>parameterType</strong></p>
<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--模糊查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserLike&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from user where name like #&#123;key&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserLike</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserDao mapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">    List&lt;User&gt; userList = mapper.getUserLike(<span class="string">&quot;%李%&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息</p>
<p><img src="../images/image-20200607003605046-1625652999702.png" alt="image-20200607003605046"></p>
<h3 id="环境配置（environments）"><a href="#环境配置（environments）" class="headerlink" title="环境配置（environments）"></a>环境配置（environments）</h3><ul>
<li>MyBatis 可以配置成适应多种环境</li>
<li><strong>尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></li>
</ul>
<p><strong>事务管理器（transactionManager）</strong></p>
<p>在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）</p>
<p><strong>数据源（dataSource）</strong></p>
<p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p>
<p>有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）</p>
<h3 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h3><p>【<code>推荐使用resource方式引用</code>】</p>
<p>告诉 MyBatis 到哪里去找映射文件 </p>
<p>可以使用：</p>
<ul>
<li>相对于类路径的资源引用</li>
<li>完全限定资源定位符（包括 <code>file:///</code> 形式的 URL）</li>
<li>类名和包名</li>
</ul>
<p><img src="../images/image-20200607012832870-1625652999702.png" alt="image-20200607012832870"></p>
<p>使用class文件和包扫描绑定注册<strong>注意点</strong>：</p>
<ul>
<li>接口和mapper文件必须同名！</li>
<li>接口和mapper文件必须在同一个包下！</li>
</ul>
<h3 id="属性（properties）"><a href="#属性（properties）" class="headerlink" title="属性（properties）"></a>属性（properties）</h3><p>属性可以在外部进行配置，并可以进行动态替换</p>
<p>优先级：命令行&gt;外部文件&gt;内部</p>
<p>加载机制：</p>
<ul>
<li>首先读取在 properties 元素体内指定的属性。</li>
<li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。</li>
<li>最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。</li>
</ul>
<p>使用步骤：</p>
<p>1、先编写一个db.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<p>2、在核心配置文件中引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入外部配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者根据url引入</p>
<p>【易错点】</p>
<p><strong>#{}</strong> 是占位符</p>
<p>**$()**是直接字符替换，不安全，有注入风险</p>
<p><img src="../images/image-20200610144415025-1625652999702.png" alt="image-20200610144415025"></p>
<h3 id="类型别名（typeAliases）"><a href="#类型别名（typeAliases）" class="headerlink" title="类型别名（typeAliases）"></a>类型别名（typeAliases）</h3><ul>
<li>为 Java 类型设置一个缩写名字。</li>
<li>它仅用于 XML 配置，意在<strong>降低冗余的全限定类名书写</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.tcmyxc.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select id, name, pwd as password from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.tcmyxc.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>扫描实体类的包，它的默认别名就是这个类的类名，首字母小写（实际上也可以大写，但推荐小写）！</p>
<blockquote>
<p>在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名</p>
<p>——官方原话</p>
</blockquote>
<p>实体类较少，使用第一种。</p>
<p>如果实体类较大，使用第二种。</p>
<p>第二种可以直接定制化，第二种可以使用注解的方式定制名字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    select id, name, pwd as password from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="设置（settings）"><a href="#设置（settings）" class="headerlink" title="设置（settings）"></a>设置（settings）</h3><p><img src="../images/image-20200607012510711-1625652999702.png" alt="image-20200607012510711"></p>
<p><img src="../images/image-20200607012535219-1625652999702.png" alt="image-20200607012535219"></p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="../images/image-20200607014411150-1625652999702.png" alt="image-20200607014411150"></p>
<p>不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong></p>
<p><strong>SqlSessionFactoryBuilder</strong></p>
<ul>
<li>一旦创建了 SqlSessionFactory，就不再需要它了</li>
<li>局部变量</li>
</ul>
<p><strong>SqlSessionFactory</strong></p>
<ul>
<li>可以认为是数据库连接池</li>
<li>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例</strong></li>
<li>最佳实践是在应用运行期间不要重复创建多次，浪费资源！</li>
<li>因此 SqlSessionFactory 的最佳作用域是<strong>应用作用域</strong></li>
<li>最简单的就是使用<strong>单例模式</strong>或者静态单例模式</li>
</ul>
<p><strong>SqlSession</strong></p>
<ul>
<li>连接到连接池的一个请求</li>
<li>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域</li>
<li>用完之后需要赶紧关闭，否则资源被占用</li>
</ul>
<p><img src="../images/image-20200607014445923-1625652999702.png" alt="image-20200607014445923"></p>
<p>这里面每一个mapper就是一个业务。</p>
<h2 id="解决实体类的属性名和数据库字段名不一致的问题"><a href="#解决实体类的属性名和数据库字段名不一致的问题" class="headerlink" title="解决实体类的属性名和数据库字段名不一致的问题"></a>解决实体类的属性名和数据库字段名不一致的问题</h2><p><img src="../images/image-20200607015718674-1625652999702.png" alt="image-20200607015718674"></p>
<p>测试结果：</p>
<p><img src="../images/image-20200607015735913-1625652999702.png" alt="image-20200607015735913"></p>
<h3 id="解决方案一：起别名"><a href="#解决方案一：起别名" class="headerlink" title="解决方案一：起别名"></a>解决方案一：起别名</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select id, name, pwd as password from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20200607015930679-1625652999702.png" alt="image-20200607015930679"></p>
<h3 id="方案二：结果集映射"><a href="#方案二：结果集映射" class="headerlink" title="方案二：结果集映射"></a>方案二：结果集映射</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">数据库字段：id name pwd</span><br><span class="line">实体属性值：id name password</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--property是实体类属性，column是数据库子段--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20200607020636794-1625652999702.png" alt="image-20200607020636794"></p>
<h2 id="日志——log4j"><a href="#日志——log4j" class="headerlink" title="日志——log4j"></a>日志——log4j</h2><p>如果数据库操作出现异常，我们需要排错，日志就是最好的助手！</p>
<p>曾经：sout，debug</p>
<p>现在：日志工厂</p>
<p><img src="../images/image-20200607155906508-1625652999702.png" alt="image-20200607155906508"></p>
<ul>
<li>SLF4J </li>
<li>LOG4J【掌握】 </li>
<li>LOG4J2 </li>
<li>JDK_LOGGING</li>
<li>COMMONS_LOGGING </li>
<li>STDOUT_LOGGING【标准日志输出，不需要引包，掌握】 </li>
<li>NO_LOGGING</li>
</ul>
<h3 id="log4j是什么？"><a href="#log4j是什么？" class="headerlink" title="log4j是什么？"></a>log4j是什么？</h3><ul>
<li>Log4j是<a href="https://baike.baidu.com/item/Apache/8512995">Apache</a>的一个开源项目</li>
<li>使用Log4j，可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%B0/2438626">控制台</a>、文件、<a href="https://baike.baidu.com/item/GUI">GUI</a>组件，甚至是套接口服务器、<a href="https://baike.baidu.com/item/NT/3443842">NT</a>的事件记录器、<a href="https://baike.baidu.com/item/UNIX">UNIX</a> <a href="https://baike.baidu.com/item/Syslog">Syslog</a><a href="https://baike.baidu.com/item/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/966835">守护进程</a>等</li>
<li>可以控制每一条日志的输出格式</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</li>
<li>这些可以通过一个<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/286550">配置文件</a>来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
<p><strong>使用步骤如下：</strong></p>
<h3 id="在pom-xml中添加依赖"><a href="#在pom-xml中添加依赖" class="headerlink" title="在pom.xml中添加依赖"></a>在<code>pom.xml</code>中添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--log4j--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置log4j-properties文件"><a href="#配置log4j-properties文件" class="headerlink" title="配置log4j.properties文件"></a>配置<code>log4j.properties</code>文件</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### set log levels ###</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span> = <span class="string">DEBUG,Console,File</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">###  输出到控制台  ###</span></span><br><span class="line"><span class="meta">log4j.appender.Console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.Console.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.Console.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.Console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.Console.layout.ConversionPattern</span>=<span class="string">[%d&#123;yy/MM/dd HH:mm:ss:SSS&#125;]-%l:%m%n</span></span><br><span class="line"><span class="attr">​</span></span><br><span class="line"><span class="comment">### 输出到日志文件 ###</span></span><br><span class="line"><span class="meta">log4j.appender.File</span>=<span class="string">org.apache.log4j.RollingFileAppender </span></span><br><span class="line"><span class="meta">log4j.appender.File.File</span>=<span class="string">./log/app.log</span></span><br><span class="line"><span class="meta">log4j.appender.File.MaxFileSize</span>=<span class="string">10MB</span></span><br><span class="line"><span class="meta">log4j.appender.File.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.File.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.File.layout.ConversionPattern</span>=<span class="string">[%p][%d&#123;yyyy-MM-dd HH\:mm\:ss,SSS&#125;][%c]%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 日志输出级别</span></span><br><span class="line"><span class="meta">log4j.logger.org.mybatis</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.org.java.sql</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.org.java.sql.Statement</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.org.java.sql.ResultSet</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.org.java.sql.PreparedStatement</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>



<p><strong>其实这就已经配置好了</strong>！！！是不是很惊喜！！！</p>
<p><img src="../images/image-20200607163020444-1625652999702.png" alt="image-20200607163020444"></p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>1、在要使用log4j的类中导包</p>
<p>2、生成一个日志对象，参数为当前类的class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">static</span> Logger logger = Logger.getLogger(UserMapper.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLog4j</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 三种日志级别</span></span><br><span class="line">    logger.info(<span class="string">&quot;info:进入了testLog4j方法&quot;</span>);</span><br><span class="line">    logger.debug(<span class="string">&quot;debug:进入了testLog4j方法&quot;</span>);</span><br><span class="line">    logger.error(<span class="string">&quot;error:进入了testLog4j方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p><strong>思考：为什么使用分页？</strong></p>
<ul>
<li>减少数据处理量</li>
</ul>
<h3 id="使用limit分页"><a href="#使用limit分页" class="headerlink" title="使用limit分页"></a>使用limit分页</h3><ol>
<li>新建一个子项目</li>
<li>写核心配置文件</li>
<li>写工具类</li>
<li>写接口</li>
<li>写mapper.xml文件</li>
<li>注册mapper.xml</li>
<li>测试</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user limit startIndex,pageSize</span><br><span class="line"></span><br><span class="line">开始的下标，每页的数量</span><br></pre></td></tr></table></figure>

<h3 id="使用RowBounds分页"><a href="#使用RowBounds分页" class="headerlink" title="使用RowBounds分页"></a>使用RowBounds分页</h3><ul>
<li>不建议在开发中使用</li>
</ul>
<p><img src="../images/image-20200608184730139-1625652999705.png" alt="image-20200608184730139"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UserMapper.java</span></span><br><span class="line"><span class="comment">// 使用RowBounds分页，我只要查询就好，分页让java对象去做</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserListByRowBounds</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserListByRowBounds</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过java代码层面实现分页</span></span><br><span class="line"></span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">    RowBounds rowBounds = <span class="keyword">new</span> RowBounds(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;com.tcmyxc.dao.UserMapper.getUserListByRowBounds&quot;</span>, <span class="keyword">null</span>, rowBounds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20200608185830678-1625652999705.png" alt="image-20200608185830678"></p>
<h2 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h2><p>1、注解在接口上实现</p>
<p>2、在核心配置文件绑定接口</p>
<p>3、本质是反射机制实现，底层是动态代理</p>
<h3 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h3><p>如果依赖于抽象类来定义行为，往往导致过于复杂的继承关系，而通过接口定义行为能够更有效地分离行为与实现，为代码的维护和修改带来方便。</p>
<p>关于接口的理解：</p>
<ul>
<li>接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。</li>
<li>接口的本身反映了系统设计人员对系统的抽象理解。</li>
<li>接口应有两类：<ul>
<li>第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)；</li>
<li>第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；</li>
</ul>
</li>
<li>一个体有可能有多个抽象面。</li>
<li>抽象体与抽象面是有区别的。</li>
</ul>
<p>interface在某些地方和abstract有相似的地方，但是采用哪种方式来声明类主要参照以下两点：</p>
<ul>
<li>如果要创建不带任何方法定义和<a href="https://baike.baidu.com/item/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">成员变量</a>的基类，那么就应该选择接口而不是抽象类。</li>
<li>如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在<strong>必须要有方法定义和成员变量</strong>的时候，才应该选择<a href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E7%B1%BB">抽象类</a>。因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。</li>
</ul>
<h3 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h3><h4 id="新建工具类，实体类"><a href="#新建工具类，实体类" class="headerlink" title="新建工具类，实体类"></a>新建工具类，实体类</h4><h4 id="只需要写接口，不需要UserMapper-xml文件"><a href="#只需要写接口，不需要UserMapper-xml文件" class="headerlink" title="只需要写接口，不需要UserMapper.xml文件"></a>只需要写接口，不需要UserMapper.xml文件</h4><p><img src="../images/image-20200607133246696-1625652999705.png" alt="image-20200607133246696"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from user&quot;)</span><br><span class="line">    List<span class="tag">&lt;<span class="name">User</span>&gt;</span> getUserList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="在核心配置文件mybatis-config-xml文件中注册接口（使用类名注册）"><a href="#在核心配置文件mybatis-config-xml文件中注册接口（使用类名注册）" class="headerlink" title="在核心配置文件mybatis-config.xml文件中注册接口（使用类名注册）"></a>在核心配置文件<code>mybatis-config.xml</code>文件中注册接口（使用类名注册）</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--绑定接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; userList = mapper.getUserList();</span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20200607133944786-1625652999705.png" alt="image-20200607133944786"></p>
<p>注意错误点：属性和字段不一致的问题比较烦人（可以使用笨方法）</p>
<p><img src="../images/image-20200607135301326-1625652999705.png" alt="image-20200607135301326"></p>
<p><img src="../images/image-20200607135309505-1625652999705.png" alt="image-20200607135309505"></p>
<p><code>所以稍微复杂的还是XML来吧</code></p>
<p>注意点：</p>
<ul>
<li><p>简单的sql语句可以使用</p>
</li>
<li><p>复杂的还是xml配置文件来</p>
</li>
<li><p>对一个接口来说，<strong>可以混用</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.tcmyxc.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/tcmyxc/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句</p>
</li>
<li><p>选择何种方式来配置映射，以及认为是否应该要统一映射语句定义的形式，完全取决于你和你的团队。换句话说，永远不要拘泥于一种方式，你可以很轻松的在基于注解和 XML 的语句映射方式间自由移植和切换</p>
</li>
</ul>
<h3 id="Mybatis详细执行流程"><a href="#Mybatis详细执行流程" class="headerlink" title="Mybatis详细执行流程"></a>Mybatis详细执行流程</h3><h3 id="使用注解完成CRUD"><a href="#使用注解完成CRUD" class="headerlink" title="使用注解完成CRUD"></a>使用注解完成CRUD</h3><p>我们可以在工具类创建的时候实现自动提交事务！但是<strong>尽量不要自动提交</strong>！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 设置自动提交事务</span></span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><code>@Param(&quot;param&quot;)注解</code>问题</strong></p>
<ul>
<li>基本类型的参数或者String类型，需要加上</li>
<li>引用类型不需要加</li>
<li>单个基本类型，参数可不写</li>
<li>多个参数必须写</li>
</ul>
<p><img src="../images/image-20200607150848662-1625652999705.png" alt="image-20200607150848662"></p>
<p>参数取的时候取得是注解里面的参数！</p>
<p>几种错误情况：</p>
<p>1、错误1</p>
<p><img src="../images/image-20200607153127240-1625652999705.png" alt="image-20200607153127240"></p>
<p><img src="../images/image-20200607152538086-1625652999705.png" alt="image-20200607152538086"></p>
<p><img src="../images/image-20200607152523428-1625652999705.png" alt="image-20200607152523428"></p>
<p>修改成下面即可：</p>
<p><img src="../images/image-20200607153248749-1625652999705.png" alt="image-20200607153248749"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="keyword">int</span> res = mapper.insertUser2(<span class="keyword">new</span> User(<span class="number">11</span>, <span class="string">&quot;哈哈哈&quot;</span>, <span class="string">&quot;234t&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;插入成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20200607153333159-1625652999705.png" alt="image-20200607153333159"></p>
<p>【注意】<strong>我们必须要将接口注册到核心配置文件</strong></p>
<h3 id="和-区别"><a href="#和-区别" class="headerlink" title="#{} 和${}区别"></a><code>#&#123;&#125; 和$&#123;&#125;</code>区别</h3><ul>
<li><code>#&#123;&#125; </code>可以防止SQL注入</li>
<li><code>$&#123;&#125; </code>不安全</li>
</ul>
<blockquote>
<p>默认情况下，使用 <code>#&#123;&#125;</code> 参数语法时，MyBatis 会创建 <code>PreparedStatement</code> 参数占位符，并通过占位符安全地设置参数（就像使用 ? 一样）。 这样做更安全，更迅速，通常也是首选做法</p>
<p><code>$&#123;column&#125;</code> 会被直接替换，用作语句参数是不安全的，会导致潜在的 SQL 注入攻击。因此，要么不允许用户输入这些字段，要么自行转义并检验这些参数。</p>
</blockquote>
<h2 id="一对多和多对一"><a href="#一对多和多对一" class="headerlink" title="一对多和多对一"></a>一对多和多对一</h2><p>一个老师，多个学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table teacher(</span><br><span class="line">    id int(10) not null,</span><br><span class="line">    name varchar(30) default null,</span><br><span class="line">    primary key(id)    </span><br><span class="line">)engine=innodb default charset=utf8</span><br><span class="line"></span><br><span class="line">insert into teacher values (1, &#x27;徐老师&#x27;);</span><br><span class="line"></span><br><span class="line">create table student(</span><br><span class="line">    id int(10) not null,</span><br><span class="line">    name varchar(30) default null,</span><br><span class="line">    tid int(10) default null,</span><br><span class="line">    primary key (id),</span><br><span class="line">    foreign key (tid) references teacher (id)</span><br><span class="line">)engine=innodb default charset=utf8</span><br><span class="line"></span><br><span class="line">insert into student values (1, &#x27;张三&#x27;, 1);</span><br><span class="line">insert into student values (2, &#x27;李四&#x27;, 1);</span><br><span class="line">insert into student values (3, &#x27;王五&#x27;, 1);</span><br><span class="line">insert into student values (4, &#x27;赵六&#x27;, 1);</span><br><span class="line">insert into student values (5, &#x27;秦七&#x27;, 1);</span><br></pre></td></tr></table></figure>

<p><strong>测试环境搭建：</strong></p>
<ol>
<li>建数据库</li>
<li>新建老师，同学实体类</li>
<li>建立mapper接口</li>
<li>建立mapper.xml文件</li>
<li>注册mapper.xml文件</li>
<li>测试</li>
</ol>
<h3 id="查询所有的学生以及学生老师的信息"><a href="#查询所有的学生以及学生老师的信息" class="headerlink" title="查询所有的学生以及学生老师的信息"></a>查询所有的学生以及学生老师的信息</h3><p>按照结果处理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher&quot;</span>&gt;</span></span><br><span class="line">    select s.id as sid, s.name as sname, t.id as tid, t.name as tname</span><br><span class="line">    from student as s, teacher as t</span><br><span class="line">    where s.tid = t.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStudentList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">    List&lt;Student&gt; studentList = mapper.getStudentList();</span><br><span class="line">    <span class="keyword">for</span> (Student student : studentList) &#123;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果：</p>
<p><img src="../images/image-20200610163826690-1625652999705.png" alt="image-20200610163826690"></p>
<h3 id="查询老师有多少个学生"><a href="#查询老师有多少个学生" class="headerlink" title="查询老师有多少个学生"></a>查询老师有多少个学生</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudentMap&quot;</span>&gt;</span></span><br><span class="line">    select t.id as tid, t.name as tname, s.id as sid, s.name as sname</span><br><span class="line">    from teacher as t, student as s</span><br><span class="line">    where t.id = s.tid and t.id = #&#123;tid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudentMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  集合 : collection</span></span><br><span class="line"><span class="comment">  关联 : association</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  集合中的泛型用ofType</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	Teacher&#123;</span></span><br><span class="line"><span class="comment">		id=1,</span></span><br><span class="line"><span class="comment">		name=&#x27;徐老师&#x27;,</span></span><br><span class="line"><span class="comment">		students=</span></span><br><span class="line"><span class="comment">			[</span></span><br><span class="line"><span class="comment">			Student&#123;id=1, name=&#x27;张三&#x27;, tid=0&#125;,</span></span><br><span class="line"><span class="comment">			Student&#123;id=2, name=&#x27;李四&#x27;, tid=0&#125;,</span></span><br><span class="line"><span class="comment">			Student&#123;id=3, name=&#x27;王五&#x27;, tid=0&#125;,</span></span><br><span class="line"><span class="comment">			Student&#123;id=4, name=&#x27;赵六&#x27;, tid=0&#125;,</span></span><br><span class="line"><span class="comment">			Student&#123;id=5, name=&#x27;秦七&#x27;, tid=0&#125;</span></span><br><span class="line"><span class="comment">			]</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>关联 - association 【多对一】</li>
<li>集合 - collection 【一对多】</li>
<li>javaType 和 ofType<ul>
<li>javaType 用来指定实体类中属性的类型</li>
<li>ofType 用来指定到List或者集合中的 pojo 类型</li>
</ul>
</li>
</ol>
<p>面试高频：</p>
<ul>
<li>MySql引擎</li>
<li>InnoDB底层原理</li>
<li>索引</li>
<li>索引优化</li>
<li>查询优化</li>
</ul>
<h2 id="动态SQL语句"><a href="#动态SQL语句" class="headerlink" title="动态SQL语句"></a>动态SQL语句</h2><p><strong>根据不同的条件生成不同的SQL语句</strong></p>
<ul>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>trim (where, set)</li>
<li>foreach</li>
</ul>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>有就用，没有就不用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h3><p>传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="trim、where、set"><a href="#trim、where、set" class="headerlink" title="trim、where、set"></a>trim、where、set</h3><p><em>where</em>元素</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findActiveBlogLike&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;state != null&quot;</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><em>set</em> 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个例子中，<em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostIn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>foreach</em> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！</p>
<p><strong>提示</strong> 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p>
<h2 id="自定义缓存-ehcache"><a href="#自定义缓存-ehcache" class="headerlink" title="自定义缓存-ehcache"></a>自定义缓存-ehcache</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>ehcache.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">updateCheck</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;./tmpdir/Tmp_EhCache&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag"><span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxElementsInMemory</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;1800&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;259200&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag"><span class="attr">name</span>=<span class="string">&quot;cloud_user&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxElementsInMemory</span>=<span class="string">&quot;5000&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;1800&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;1800&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>工作中都是用redis！</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本上就是这样。这个简单语句的效果如下:</p>
<ul>
<li>映射语句文件中的所有 select 语句的结果将会被缓存。</li>
<li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li>
<li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li>
<li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li>
<li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li>
<li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/archives/4509351.html</url>
    <content><![CDATA[<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><blockquote>
<p>  这篇文章我只是个搬运工，虽然自己也总结了，但是感觉人家写的更好。</p>
<p>  原文链接：<a href="https://github.com/liguigui/CyC2018-CS-Notes">https://github.com/liguigui/CyC2018-CS-Notes</a></p>
</blockquote>
<span id="more"></span>

<h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><a href="https://camo.githubusercontent.com/d1efb1abc3173aa2a607316dda79bea560fe333f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232303934383038342e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232303934383038342e706e67" alt="img"></a></p>
<h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h3><ul>
<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</li>
</ul>
<h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><ul>
<li>ArrayList：基于动态数组实现，支持随机访问。</li>
<li>Vector：和 ArrayList 类似，但它是线程安全的。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<h3 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h3><ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><a href="https://camo.githubusercontent.com/cd126ae7572489beead8b33f3a26a5a0bb1f288e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232343735373835352e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232343735373835352e706e67" alt="img"></a></p>
<ul>
<li>TreeMap：基于红黑树实现。</li>
<li>HashMap：基于哈希表实现。</li>
<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>
<h1 id="二、容器中的设计模式"><a href="#二、容器中的设计模式" class="headerlink" title="二、容器中的设计模式"></a>二、容器中的设计模式</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p><a href="https://camo.githubusercontent.com/6ee13e3fa6717189ef266359ec74ed8a8fb88d62/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232353330313937332e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232353330313937332e706e67" alt="img"></a></p>
<p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;a&quot;);</span><br><span class="line">list.add(&quot;b&quot;);</span><br><span class="line">for (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SafeVarargs</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a)</span><br></pre></td></tr></table></figure>

<p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;1, 2, 3&#125;;</span><br><span class="line">List list = Arrays.asList(arr);</span><br></pre></td></tr></table></figure>

<p>也可以使用以下方式调用 asList()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List list = Arrays.asList(1, 2, 3);</span><br></pre></td></tr></table></figure>

<h1 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h1><p>如果没有特别说明，以下源码分析基于 JDK 1.8。</p>
<p>在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h3><p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>数组的默认大小为 10。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br></pre></td></tr></table></figure>

<p><a href="https://camo.githubusercontent.com/d1e665d0dfc95837e4ba243d2b26eccf2148f7f1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233323232313236352e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233323232313236352e706e67" alt="img"></a></p>
<h3 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2. 扩容"></a>2. 扩容</h3><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3. 删除元素"></a>3. 删除元素</h3><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-序列化"><a href="#4-序列化" class="headerlink" title="4. 序列化"></a>4. 序列化</h3><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br></pre></td></tr></table></figure>

<p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s)    throws java.io.IOException, ClassNotFoundException &#123;    elementData = EMPTY_ELEMENTDATA;    // Read in size, and any hidden stuff    s.defaultReadObject();    // Read in capacity    s.readInt(); // ignored    if (size &gt; 0) &#123;        // be like clone(), allocate array based upon size not capacity        ensureCapacityInternal(size);        Object[] a = elementData;        // Read in all elements in the proper order.        for (int i=0; i&lt;size; i++) &#123;            a[i] = s.readObject();        &#125;    &#125;&#125;private void writeObject(java.io.ObjectOutputStream s)    throws java.io.IOException&#123;    // Write out element count, and any hidden stuff    int expectedModCount = modCount;    s.defaultWriteObject();    // Write out size as capacity for behavioural compatibility with clone()    s.writeInt(size);    // Write out all elements in the proper order.    for (int i=0; i&lt;size; i++) &#123;        s.writeObject(elementData[i]);    &#125;    if (modCount != expectedModCount) &#123;        throw new ConcurrentModificationException();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList list = new ArrayList();ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));oos.writeObject(list);</span><br></pre></td></tr></table></figure>

<h3 id="5-Fail-Fast"><a href="#5-Fail-Fast" class="headerlink" title="5. Fail-Fast"></a>5. Fail-Fast</h3><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h3 id="1-同步"><a href="#1-同步" class="headerlink" title="1. 同步"></a>1. 同步</h3><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized boolean add(E e) &#123;    modCount++;    ensureCapacityHelper(elementCount + 1);    elementData[elementCount++] = e;    return true;&#125;public synchronized E get(int index) &#123;    if (index &gt;= elementCount)        throw new ArrayIndexOutOfBoundsException(index);    return elementData(index);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-扩容-1"><a href="#2-扩容-1" class="headerlink" title="2. 扩容"></a>2. 扩容</h3><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Vector(int initialCapacity, int capacityIncrement) &#123;    super();    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                           initialCapacity);    this.elementData = new Object[initialCapacity];    this.capacityIncrement = capacityIncrement;&#125;private void grow(int minCapacity) &#123;    // overflow-conscious code    int oldCapacity = elementData.length;    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?                                     capacityIncrement : oldCapacity);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</span><br></pre></td></tr></table></figure>

<p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Vector(int initialCapacity) &#123;    this(initialCapacity, 0);&#125;public Vector() &#123;    this(10);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-与-ArrayList-的比较"><a href="#3-与-ArrayList-的比较" class="headerlink" title="3. 与 ArrayList 的比较"></a>3. 与 ArrayList 的比较</h3><ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li>
</ul>
<h3 id="4-替代方案"><a href="#4-替代方案" class="headerlink" title="4. 替代方案"></a>4. 替代方案</h3><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="1. 读写分离"></a>1. 读写分离</h3><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;    final ReentrantLock lock = this.lock;    lock.lock();    try &#123;        Object[] elements = getArray();        int len = elements.length;        Object[] newElements = Arrays.copyOf(elements, len + 1);        newElements[len] = e;        setArray(newElements);        return true;    &#125; finally &#123;        lock.unlock();    &#125;&#125;final void setArray(Object[] a) &#123;    array = a;&#125;@SuppressWarnings(&quot;unchecked&quot;)private E get(Object[] a, int index) &#123;    return (E) a[index];&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h3><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="1-概览-1"><a href="#1-概览-1" class="headerlink" title="1. 概览"></a>1. 概览</h3><p>基于双向链表实现，使用 Node 存储链表节点信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;    E item;    Node&lt;E&gt; next;    Node&lt;E&gt; prev;&#125;</span><br></pre></td></tr></table></figure>

<p>每个链表存储了 first 和 last 指针：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transient Node&lt;E&gt; first;transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<p><a href="https://camo.githubusercontent.com/333ccf04b7d4667fbc7c4f1a217e7e5526c400fe/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233333934303036362e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233333934303036362e706e67" alt="img"></a></p>
<h3 id="2-与-ArrayList-的比较"><a href="#2-与-ArrayList-的比较" class="headerlink" title="2. 与 ArrayList 的比较"></a>2. 与 ArrayList 的比较</h3><p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p>
<ul>
<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li>
<li>链表不支持随机访问，但插入删除只需要改变指针。</li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>为了便于理解，以下源码分析以 JDK 1.7 为主。</p>
<h3 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p>
<p><a href="https://camo.githubusercontent.com/5d81dca069e6bd97466ee40c53ea963696cfc1ef/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233343934383230352e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233343934383230352e706e67" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transient Entry[] table;static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;    final K key;    V value;    Entry&lt;K,V&gt; next;    int hash;    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;        value = v;        next = n;        key = k;        hash = h;    &#125;    public final K getKey() &#123;        return key;    &#125;    public final V getValue() &#123;        return value;    &#125;    public final V setValue(V newValue) &#123;        V oldValue = value;        value = newValue;        return oldValue;    &#125;    public final boolean equals(Object o) &#123;        if (!(o instanceof Map.Entry))            return false;        Map.Entry e = (Map.Entry)o;        Object k1 = getKey();        Object k2 = e.getKey();        if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123;            Object v1 = getValue();            Object v2 = e.getValue();            if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))                return true;        &#125;        return false;    &#125;    public final int hashCode() &#123;        return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());    &#125;    public final String toString() &#123;        return getKey() + &quot;=&quot; + getValue();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-拉链法的工作原理"><a href="#2-拉链法的工作原理" class="headerlink" title="2. 拉链法的工作原理"></a>2. 拉链法的工作原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(&quot;K1&quot;, &quot;V1&quot;);map.put(&quot;K2&quot;, &quot;V2&quot;);map.put(&quot;K3&quot;, &quot;V3&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>新建一个 HashMap，默认大小为 16；</li>
<li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</li>
<li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</li>
<li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</li>
</ul>
<p>应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p>
<p>查找需要分成两步进行：</p>
<ul>
<li>计算键值对所在的桶；</li>
<li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li>
</ul>
<p><a href="https://camo.githubusercontent.com/a7761ef5ade932ba3513693653ee65bedfa0f5db/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233353235383634332e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233353235383634332e706e67" alt="img"></a></p>
<h3 id="3-put-操作"><a href="#3-put-操作" class="headerlink" title="3. put 操作"></a>3. put 操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;    if (table == EMPTY_TABLE) &#123;        inflateTable(threshold);    &#125;    // 键为 null 单独处理    if (key == null)        return putForNullKey(value);    int hash = hash(key);    // 确定桶下标    int i = indexFor(hash, table.length);    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;            V oldValue = e.value;            e.value = value;            e.recordAccess(this);            return oldValue;        &#125;    &#125;    modCount++;    // 插入新键值对    addEntry(hash, key, value, i);    return null;&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private V putForNullKey(V value) &#123;    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;        if (e.key == null) &#123;            V oldValue = e.value;            e.value = value;            e.recordAccess(this);            return oldValue;        &#125;    &#125;    modCount++;    addEntry(0, null, value, 0);    return null;&#125;</span><br></pre></td></tr></table></figure>

<p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;        resize(2 * table.length);        hash = (null != key) ? hash(key) : 0;        bucketIndex = indexFor(hash, table.length);    &#125;    createEntry(hash, key, value, bucketIndex);&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123;    Entry&lt;K,V&gt; e = table[bucketIndex];    // 头插法，链表头部指向新的键值对    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);    size++;&#125;Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;    value = v;    next = n;    key = k;    hash = h;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-确定桶下标"><a href="#4-确定桶下标" class="headerlink" title="4. 确定桶下标"></a>4. 确定桶下标</h3><p>很多操作都需要先确定一个键值对所在的桶下标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int hash = hash(key);int i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>

<p><strong>4.1 计算 hash 值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final int hash(Object k) &#123;    int h = hashSeed;    if (0 != h &amp;&amp; k instanceof String) &#123;        return sun.misc.Hashing.stringHash32((String) k);    &#125;    h ^= k.hashCode();    // This function ensures that hashCodes that differ only by    // constant multiples at each bit position have a bounded    // number of collisions (approximately 8 at default load factor).    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;public final int hashCode() &#123;    return Objects.hashCode(key) ^ Objects.hashCode(value);&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.2 取模</strong></p>
<p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x   : 00010000x-1 : 00001111</span><br></pre></td></tr></table></figure>

<p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y       : 10110010x-1     : 00001111y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure>

<p>这个性质和 y 对 x 取模效果是一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y   : 10110010x   : 00010000y%x : 00000010</span><br></pre></td></tr></table></figure>

<p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;    return h &amp; (length-1);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-扩容-基本原理"><a href="#5-扩容-基本原理" class="headerlink" title="5. 扩容-基本原理"></a>5. 扩容-基本原理</h3><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>capacity</td>
<td>table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td>size</td>
<td>键值对数量。</td>
</tr>
<tr>
<td>threshold</td>
<td>size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td>
</tr>
<tr>
<td>loadFactor</td>
<td>装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 16;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;transient Entry[] table;transient int size;int threshold;final float loadFactor;transient int modCount;</span><br></pre></td></tr></table></figure>

<p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;    Entry&lt;K,V&gt; e = table[bucketIndex];    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);    if (size++ &gt;= threshold)        resize(2 * table.length);&#125;</span><br></pre></td></tr></table></figure>

<p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;    Entry[] oldTable = table;    int oldCapacity = oldTable.length;    if (oldCapacity == MAXIMUM_CAPACITY) &#123;        threshold = Integer.MAX_VALUE;        return;    &#125;    Entry[] newTable = new Entry[newCapacity];    transfer(newTable);    table = newTable;    threshold = (int)(newCapacity * loadFactor);&#125;void transfer(Entry[] newTable) &#123;    Entry[] src = table;    int newCapacity = newTable.length;    for (int j = 0; j &lt; src.length; j++) &#123;        Entry&lt;K,V&gt; e = src[j];        if (e != null) &#123;            src[j] = null;            do &#123;                Entry&lt;K,V&gt; next = e.next;                int i = indexFor(e.hash, newCapacity);                e.next = newTable[i];                newTable[i] = e;                e = next;            &#125; while (e != null);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-扩容-重新计算桶下标"><a href="#6-扩容-重新计算桶下标" class="headerlink" title="6. 扩容-重新计算桶下标"></a>6. 扩容-重新计算桶下标</h3><p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">capacity     : 00010000new capacity : 00100000</span><br></pre></td></tr></table></figure>

<p>对于一个 Key，它的哈希值 hash 在第 5 位：</p>
<ul>
<li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；</li>
<li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。</li>
</ul>
<h3 id="7-计算数组容量"><a href="#7-计算数组容量" class="headerlink" title="7. 计算数组容量"></a>7. 计算数组容量</h3><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p>
<p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mask |= mask &gt;&gt; 1    11011000mask |= mask &gt;&gt; 2    11111110mask |= mask &gt;&gt; 4    11111111</span><br></pre></td></tr></table></figure>

<p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num     10010000mask+1 100000000</span><br></pre></td></tr></table></figure>

<p>以下是 HashMap 中计算数组容量的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123;    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-链表转红黑树"><a href="#8-链表转红黑树" class="headerlink" title="8. 链表转红黑树"></a>8. 链表转红黑树</h3><p>从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。</p>
<h3 id="9-与-Hashtable-的比较"><a href="#9-与-Hashtable-的比较" class="headerlink" title="9. 与 Hashtable 的比较"></a>9. 与 Hashtable 的比较</h3><ul>
<li>Hashtable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="1-存储结构-1"><a href="#1-存储结构-1" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p><a href="https://camo.githubusercontent.com/f701cb7c0c3f8cc5b5da3db85d01c57d3095fa77/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230393030313033383032342e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230393030313033383032342e706e67" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;    final int hash;    final K key;    volatile V value;    volatile HashEntry&lt;K,V&gt; next;&#125;</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<p>Segment 继承自 ReentrantLock。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;    private static final long serialVersionUID = 2249069246763182397L;    static final int MAX_SCAN_RETRIES =        Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;    transient volatile HashEntry&lt;K,V&gt;[] table;    transient int count;    transient int modCount;    transient int threshold;    final float loadFactor;&#125;final Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>

<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final int DEFAULT_CONCURRENCY_LEVEL = 16;</span><br></pre></td></tr></table></figure>

<h3 id="2-size-操作"><a href="#2-size-操作" class="headerlink" title="2. size 操作"></a>2. size 操作</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** * The number of elements. Accessed only either within locks * or among other volatile reads that maintain visibility. */transient int count;</span><br></pre></td></tr></table></figure>

<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** * Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result. */static final int RETRIES_BEFORE_LOCK = 2;public int size() &#123;    // Try a few times to get accurate count. On failure due to    // continuous async changes in table, resort to locking.    final Segment&lt;K,V&gt;[] segments = this.segments;    int size;    boolean overflow; // true if size overflows 32 bits    long sum;         // sum of modCounts    long last = 0L;   // previous sum    int retries = -1; // first iteration isn&#x27;t retry    try &#123;        for (;;) &#123;            // 超过尝试次数，则对每个 Segment 加锁            if (retries++ == RETRIES_BEFORE_LOCK) &#123;                for (int j = 0; j &lt; segments.length; ++j)                    ensureSegment(j).lock(); // force creation            &#125;            sum = 0L;            size = 0;            overflow = false;            for (int j = 0; j &lt; segments.length; ++j) &#123;                Segment&lt;K,V&gt; seg = segmentAt(segments, j);                if (seg != null) &#123;                    sum += seg.modCount;                    int c = seg.count;                    if (c &lt; 0 || (size += c) &lt; 0)                        overflow = true;                &#125;            &#125;            // 连续两次得到的结果一致，则认为这个结果是正确的            if (sum == last)                break;            last = sum;        &#125;    &#125; finally &#123;        if (retries &gt; RETRIES_BEFORE_LOCK) &#123;            for (int j = 0; j &lt; segments.length; ++j)                segmentAt(segments, j).unlock();        &#125;    &#125;    return overflow ? Integer.MAX_VALUE : size;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-JDK-1-8-的改动"><a href="#3-JDK-1-8-的改动" class="headerlink" title="3. JDK 1.8 的改动"></a>3. JDK 1.8 的改动</h3><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p>
<p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p>
<p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** * The head (eldest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; head;/** * The tail (youngest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure>

<p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;void afterNodeInsertion(boolean evict) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h3><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last    LinkedHashMap.Entry&lt;K,V&gt; last;    if (accessOrder &amp;&amp; (last = tail) != e) &#123;        LinkedHashMap.Entry&lt;K,V&gt; p =            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;        p.after = null;        if (b == null)            head = a;        else            b.after = a;        if (a != null)            a.before = b;        else            last = b;        if (last == null)            head = p;        else &#123;            p.before = last;            last.after = p;        &#125;        tail = p;        ++modCount;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h3><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest    LinkedHashMap.Entry&lt;K,V&gt; first;    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;        K key = first.key;        removeNode(hash(key), key, null, false, true);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;    return false;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h3><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES 为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;    private static final int MAX_ENTRIES = 3;    protected boolean removeEldestEntry(Map.Entry eldest) &#123;        return size() &gt; MAX_ENTRIES;    &#125;    LRUCache() &#123;        super(MAX_ENTRIES, 0.75f, true);    &#125;&#125;public static void main(String[] args) &#123;    LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;();    cache.put(1, &quot;a&quot;);    cache.put(2, &quot;b&quot;);    cache.put(3, &quot;c&quot;);    cache.get(1);    cache.put(4, &quot;d&quot;);    System.out.println(cache.keySet());&#125;[3, 1, 4]</span><br></pre></td></tr></table></figure>

<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentCache"><a href="#ConcurrentCache" class="headerlink" title="ConcurrentCache"></a>ConcurrentCache</h3><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<p>ConcurrentCache 采取的是分代缓存：</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class ConcurrentCache&lt;K, V&gt; &#123;    private final int size;    private final Map&lt;K, V&gt; eden;    private final Map&lt;K, V&gt; longterm;    public ConcurrentCache(int size) &#123;        this.size = size;        this.eden = new ConcurrentHashMap&lt;&gt;(size);        this.longterm = new WeakHashMap&lt;&gt;(size);    &#125;    public V get(K k) &#123;        V v = this.eden.get(k);        if (v == null) &#123;            v = this.longterm.get(k);            if (v != null)                this.eden.put(k, v);        &#125;        return v;    &#125;    public void put(K k, V v) &#123;        if (this.eden.size() &gt;= size) &#123;            this.longterm.putAll(this.eden);            this.eden.clear();        &#125;        this.eden.put(k, v);    &#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统概念</title>
    <url>/archives/531663ae.html</url>
    <content><![CDATA[<h1 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h1><blockquote>
<p>  参考文献：</p>
<ul>
<li>  [1]操作系统概念（第九版） - 机械工业出版社</li>
<li>  [2]OS 课件（感谢JJM老师）</li>
</ul>
</blockquote>
<span id="more"></span>



<h1 id="第一章：简介"><a href="#第一章：简介" class="headerlink" title="第一章：简介"></a>第一章：简介</h1><h2 id="1、特权指令和非特权指令"><a href="#1、特权指令和非特权指令" class="headerlink" title="1、特权指令和非特权指令"></a>1、特权指令和非特权指令</h2><p>特权指令：不允许用户程序中直接使用的指令。例如：I/O指令、设置时钟、 置控制寄存器等指令都是特权指令。 </p>
<p>非特权指令:用户程序中所使用的指令。</p>
<h2 id="2、用户态和内核态"><a href="#2、用户态和内核态" class="headerlink" title="2、用户态和内核态"></a>2、用户态和内核态</h2><p>内核态 </p>
<ul>
<li>  能够访问所有系统资源，可以执行特权指令，可以直接操作和管理硬件设备。 </li>
<li>  操作系统内核程序运行在内核态下 </li>
<li>  使用内核栈 </li>
</ul>
<p>用户态 </p>
<ul>
<li>  只能访问属于它的存储空间和普通寄存器，只能执行普通指令。 </li>
<li>  用户程序以及操作系统核外服务程序运行在用户态下 </li>
<li>  使用用户栈</li>
</ul>
<h2 id="3、分布式系统"><a href="#3、分布式系统" class="headerlink" title="3、分布式系统"></a>3、分布式系统</h2><p>定义：物理上分开的、可能异构的、通过网络相连的一组计算机系统。</p>
<h1 id="第二章：操作系统结构"><a href="#第二章：操作系统结构" class="headerlink" title="第二章：操作系统结构"></a>第二章：操作系统结构</h1><h2 id="1、系统调用"><a href="#1、系统调用" class="headerlink" title="1、系统调用"></a>1、系统调用</h2><p>系统调用：进程和内核之间的程序接口。</p>
<ul>
<li>  系统调用的实现是在内核完成的</li>
<li>  系统调用是通过软中断向内核发出一个明确的请求，每个系统调用对应一个封装例程（wrapper routine，唯一目的就是发布系统调用）</li>
</ul>
<p>分为六大类：</p>
<p>进程控制、文件管理、设备管理、信息维护、通信、保护</p>
<h2 id="2、如何向操作系统提供参数？"><a href="#2、如何向操作系统提供参数？" class="headerlink" title="2、如何向操作系统提供参数？"></a>2、如何向操作系统提供参数？</h2><ul>
<li>  通过寄存器</li>
<li>  存在内存的块或表中，块地址再作为参数传给寄存器</li>
<li>  放在栈里面，让操作系统弹出</li>
</ul>
<p>后面两种方法不限制参数的数量和长度</p>
<h2 id="几个Linux命令"><a href="#几个Linux命令" class="headerlink" title="几个Linux命令"></a>几个Linux命令</h2><p><code>lsmod</code>：查看所有内核模块</p>
<p><code>insmod 模块名</code>：加载内核模块</p>
<p><code>rmmod 模块名（不需要.ko后缀</code>：卸载模块</p>
<p><code>dmesg</code>：查看系统启动信息</p>
<h1 id="第三章：进程"><a href="#第三章：进程" class="headerlink" title="第三章：进程"></a>第三章：进程</h1><h2 id="1、进程是什么？"><a href="#1、进程是什么？" class="headerlink" title="1、进程是什么？"></a>1、进程是什么？</h2><ul>
<li>一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。进程是操作系统进行资源分配和调度的一个独立单位。</li>
<li>正在执行中的程序 a program in execution</li>
</ul>
<p><img src="../images/image-20210120155904570.png" alt="image-20210120155904570"></p>
<blockquote>
<p>  张尧学，计算机操作系统教程，清华大学出版社</p>
</blockquote>
<p><img src="../images/image-20200626162307991.png" alt="image-20200626162307991"></p>
<h2 id="2、进程组成"><a href="#2、进程组成" class="headerlink" title="2、进程组成"></a>2、进程组成</h2><ul>
<li>代码段</li>
<li>数据段（全局变量）</li>
<li>堆（动态申请空间）</li>
<li>程序计数器（PC）</li>
<li>一组寄存器</li>
<li>栈（临时变量）</li>
</ul>
<p>示意图：</p>
<p><img src="../images/image-20210120160234236.png" alt="image-20210120160234236"></p>
<p>PCB（进程控制块）</p>
<ul>
<li>进程状态</li>
<li>程序计数器</li>
<li>CPU寄存器</li>
<li>CPU调度信息</li>
<li>内存管理信息</li>
<li>记账信息</li>
<li>IO状态信息</li>
</ul>
<h2 id="3、进程状态（5个）"><a href="#3、进程状态（5个）" class="headerlink" title="3、进程状态（5个）"></a>3、进程状态（5个）</h2><p>new、running、ready、waiting、terminated</p>
<p><img src="../images/image-20200626162734708.png" alt="image-20200626162734708"></p>
<p>一个处理器一次只能运行一个进程</p>
<p>三个基本状态之间可能转换和转换原因如下：</p>
<ul>
<li>  就绪→运行：当处理器空闲时，进程调度程序必将处理机分配给一个处于就绪状态的进程 ，该进程便由就绪状态转换为运行状态。</li>
<li>  运行→等待：处于运行状态的进程在运行过程中需要等待某一事件发生后（例如因I／O请求等待I／O完成后），才能继续运行，则该进程放弃处理器，从运行状态转换为等待状态。</li>
<li>  等待→就绪：处于等待状态的进程，若其等待的事件已经发生，于是进程由等待状态转换为就绪状态。</li>
<li>  运行→就绪：处于运行状态的进程在其运行过程中，因分给它的处理器时间片已用完，而不得不让出（被抢占）处理器，于是进程由运行态转换为就绪态。</li>
</ul>
<p>等待→运行，就绪→等待这二种状态转换一般不可能发生。</p>
<p>处于运行状态进程：如系统有一个处理器，则在任何一时刻，最多只有一个进程处于运行状态。</p>
<p>处于就绪状态进程：一般处于就绪状态的进程按照一定的算法（如先来的进程排在前面，或采用优先权高的进程排在前面）排成一个就绪队列。</p>
<p>处于等待状态进程：处于等待状态的进程排在等待队列中。由于等待事件原因不同，等待队列也可以按事件分成几个队列。</p>
<h2 id="4、进程和程序"><a href="#4、进程和程序" class="headerlink" title="4、进程和程序"></a>4、进程和程序</h2><ul>
<li>进程是动态的，程序是静态的</li>
<li>进程是暂时的，程序是永久的</li>
<li>进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程状态信息）</li>
<li>通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序</li>
</ul>
<h2 id="5、进程调度"><a href="#5、进程调度" class="headerlink" title="5、进程调度"></a>5、进程调度</h2><p>调度队列和调度程序</p>
<p>上下文切换：切换 CPU 到另外一个进程需要保存当前进程的状态，同时恢复另一个进程的状态</p>
<p>进程上下文用进程 PCB 表示</p>
<h2 id="6、进程操作"><a href="#6、进程操作" class="headerlink" title="6、进程操作"></a>6、进程操作</h2><h3 id="6-1-创建进程"><a href="#6-1-创建进程" class="headerlink" title="6.1 创建进程"></a>6.1 创建进程</h3><p><img src="../images/image-20210120162500381.png" alt="image-20210120162500381"></p>
<p>进程标识符（pid）唯一标识一个进程</p>
<p>子进程可能共享父进程的所有资源或者部分资源，或者直接不共享</p>
<p>创建新进程，可以使用 fork() 这个系统调用</p>
<ul>
<li>  子进程继承了父进程的地址空间</li>
<li>  子进程 PID 是 0，父进程的 PID 值是子进程的 PID</li>
</ul>
<h3 id="6-2-进程终止"><a href="#6-2-进程终止" class="headerlink" title="6.2 进程终止"></a>6.2 进程终止</h3><p>引起进程终止的事件：</p>
<ul>
<li>  正常结束</li>
<li>  异常结束</li>
<li>  外界干预</li>
</ul>
<p>僵尸进程：进程已经中止，但父进程未调用wait()</p>
<p>孤儿进程：父进程未调用wait()就终止了，处理方式：将init进程（1号进程）作为孤儿进程的父进程</p>
<h3 id="6-3-进程通信-Interprocess-Communication，IPC"><a href="#6-3-进程通信-Interprocess-Communication，IPC" class="headerlink" title="6.3 进程通信(Interprocess Communication，IPC)"></a>6.3 进程通信(Interprocess Communication，IPC)</h3><p>IPC为进程提供了一种无需共享相同地址空间就可以进行通信和同步操作的机制</p>
<p>两种模型：共享内存、消息传递</p>
<p><img src="../images/image-20210123094831885.png" alt="image-20210123094831885"></p>
<p>通信类型：直接通信、间接通信</p>
<p>常用通信机制：</p>
<ul>
<li>信号(signal)</li>
<li>共享存储区(shared memory)</li>
<li>管道(pipe)</li>
<li>消息(message)</li>
<li>套接字(socket)</li>
</ul>
<p>Linux实现进程间通信(IPC Inter Process Communication)：</p>
<ul>
<li><p>System V IPC机制:</p>
<ul>
<li>信号量、 消息队列、 共享内存</li>
</ul>
</li>
<li><p>管道（pipe）、命名管道 </p>
</li>
<li><p>套接字（socket）</p>
</li>
<li><p>信号( signal )</p>
</li>
<li><p>文件锁(file lock)</p>
</li>
<li><p>POSIX线程：</p>
<ul>
<li>互斥锁(互斥体、互斥量)（mutex）、条件变量(condition variables)</li>
</ul>
</li>
<li><p>POSIX：</p>
<ul>
<li>消息队列、信号量、共享内存</li>
</ul>
</li>
</ul>
<h2 id="7、IPC"><a href="#7、IPC" class="headerlink" title="7、IPC"></a>7、IPC</h2><h3 id="7-1-共享内存"><a href="#7-1-共享内存" class="headerlink" title="7.1 共享内存"></a>7.1 共享内存</h3><ul>
<li>  希望通信的进程之间共享的一块内存区域</li>
<li>  通信在用户进程的控制下，而不是操作系统的控制下。</li>
<li>  主要问题是提供一种机制，允许用户进程在访问共享内存时同步它们的操作</li>
<li>  协同进程的并发执行需要允许进程之间进行通信并同步它们的动作的机制</li>
<li>生产者-消费者问题<ul>
<li>  有界缓冲区</li>
<li>  无界缓冲区</li>
</ul>
</li>
</ul>
<h3 id="7-2-消息传递"><a href="#7-2-消息传递" class="headerlink" title="7.2 消息传递"></a>7.2 消息传递</h3><p>进程之间的通信不需要依赖共享变量</p>
<p>如果 P 和 Q 要通信，需要两步：</p>
<p>1、建立连接</p>
<p>2、交换信息</p>
<p><strong>直接通信</strong></p>
<ul>
<li>  明确说明要发给谁或者从谁接收信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">send (P, message) – send a message to process P</span><br><span class="line">receive(Q, message) – receive a message from process Q</span><br></pre></td></tr></table></figure>

<p>通信连接的特性：</p>
<ul>
<li>  连接自动建立</li>
<li>  一个链接只与一对通信进程相关联，换言之，一对通信之间只有一个链接</li>
<li>  链接可能是单向的，但通常是双向的</li>
</ul>
<p><strong>间接通信</strong></p>
<ul>
<li>  从邮箱(mailbox，也称为端口)定向和接收消息</li>
<li>  每个邮箱都有一个唯一的id</li>
<li>  进程只有在共享邮箱时才能通信</li>
</ul>
<p>通信链路的特性</p>
<ul>
<li>  仅当进程共享一个公共邮箱时才建立链接</li>
<li>  一个链接可能与许多进程相关联</li>
<li>  每一对进程可以共享几个通信链路</li>
<li>  链接可以是单向的，也可以是双向的</li>
</ul>
<h2 id="8、同步异步"><a href="#8、同步异步" class="headerlink" title="8、同步异步"></a>8、同步异步</h2><p>消息传递可以是阻塞的，也可以是非阻塞的</p>
<p><strong>阻塞</strong>被认为是<strong>同步</strong>的。</p>
<ul>
<li><p>  阻塞发送——发送方被阻塞，直到接收方接收到消息</p>
</li>
<li><p>  阻塞接收——接收者被阻塞，直到有消息可用</p>
</li>
</ul>
<p><strong>非阻塞</strong>被视为<strong>异步</strong>的</p>
<ul>
<li><p>  非阻塞发送——发送者发送消息并继续</p>
</li>
<li><p>  非阻塞接收——接收方接收到有效的消息，或空消息</p>
</li>
</ul>
<p><strong>RPC</strong></p>
<p>如同调用本地过程一样调用远程主机的过程</p>
<p><strong>管道</strong></p>
<ul>
<li>  普通管道：单向（单工）通信，标准的生产者消费者方式进行通信——生产者向管道一端写入，消费者从管道另一端读出；进程通信时管道才存在</li>
<li>  命名管道：可以双向通信，一个管道可以被多个进程使用</li>
</ul>
<h2 id="9、几个命令"><a href="#9、几个命令" class="headerlink" title="9、几个命令"></a>9、几个命令</h2><p>查看所有活动进程的详细信息：<code>ps -el</code></p>
<p><img src="../images/image-20210120161756889.png" alt="image-20210120161756889"></p>
<p>杀进程：<code>kill -9 进程号</code></p>
<p>查看文件：<code>cat 文件名</code></p>
<h1 id="第四章：线程和并发"><a href="#第四章：线程和并发" class="headerlink" title="第四章：线程和并发"></a>第四章：线程和并发</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>线程定义为进程内一个执行单元或一个可调度实体。</p>
<p>线程只拥有一点在运行中必不可省的资源（程序计数器、一组寄存器和栈），但它可与同属一个进程的其它线程共享进程拥有的全部资源。</p>
<p>通常，使用一个包含读个线程的进程更加有效</p>
<p>延伸：</p>
<ul>
<li>  线程私有的：线程ID、程序计数器、一组寄存器和栈</li>
<li>  线程共享的：代码段、数据段、其他操作系统资源</li>
</ul>
<p>资源拥有单元称为进程，调度的单位称为线程。</p>
<p>线程：</p>
<ul>
<li>  有执行状态（状态转换）</li>
<li>  不运行时保存上下文</li>
<li>  有一个执行栈</li>
<li>  有一些局部变量的静态存储</li>
<li>  可存取所在进程的内存和其他资源</li>
<li>  可以创建、撤消另一个线程</li>
</ul>
<p>线程的特点：</p>
<ul>
<li>  不拥有系统资源（只拥有少量的资源，资源是分配给进程） </li>
<li>  一个进程中的多个线程可并发执行（进程可创建线程执行同一程序的不同部分） </li>
<li>  系统开销小、切换快。（进程的多个线程都在进程的地址空间活动）</li>
</ul>
<p>优点：</p>
<ul>
<li>  <strong>创建一个新线程花费时间少</strong>（结束亦如此）</li>
<li>  <strong>两个线程的切换花费时间少</strong>（如果机器设有“存储[恢复]所有寄存器”指令，则整个切换过程用几条指令即可完成）</li>
<li>  <strong>通信方便</strong>：因为同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核</li>
<li>  <strong>适合多处理机系统</strong></li>
</ul>
<h2 id="2、线程的实现机制"><a href="#2、线程的实现机制" class="headerlink" title="2、线程的实现机制"></a>2、线程的实现机制</h2><blockquote>
<p>  了解即可</p>
</blockquote>
<p><strong>用户级线程</strong>：不依赖于OS核心（内核不了解用户线程的存在），应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程</p>
<p>调度由应用软件内部进行，通常采用非抢占式和更简单的规则，也无需用户态/核心态切换，所以速度特别快。</p>
<p>一个线程发起系统调用而阻塞，则整个进程在等待。 </p>
<p>特点：</p>
<ul>
<li>  用户线程的维护由应用进程完成；</li>
<li>  内核不了解用户线程的存在；</li>
<li>  用户线程切换不需要内核特权；</li>
<li>  用户线程调度算法可针对应用优化；</li>
<li>  一个线程发起系统调用而阻塞，则整个进程在等待。（一对多模型中）</li>
</ul>
<p><strong>内核级线程</strong>：依赖于OS核心，由内核的内部需求进行创建和撤销，用来执行一个指定的函数。一个线程发起系统调用而阻塞，不会影响其他线程。时间片分配给线程，所以多线程的进程获得更多CPU时间。</p>
<p>特点：</p>
<ul>
<li>  内核维护进程和线程的上下文信息；</li>
<li>  线程切换由内核完成；</li>
<li>  时间片分配给线程，所以多线程的进程获得更多CPU时间；</li>
<li>  一个线程发起系统调用而阻塞，不会影响其他线程的运行。</li>
</ul>
<p>并行：同时执行多个任务</p>
<p>并发：支持多个任务，并允许所有任务都有其进展</p>
<p>用户级线程和内核级线程的映射关系：</p>
<p>1、一对一：一个用户级线程对应一个内核级线程。一个线程阻塞，整个进程阻塞；不能用在多核处理器上</p>
<p>2、多对一：多个用户级线程对应一个内核级线程。内核级线程数量需要限制；允许多个线程并行运行在多处理器上；没有增加并发（内核一次只能调度一个线程）</p>
<p>3、多对多：多路复用多个用户级线程到同等数量或者数量更少的内核线程上。</p>
<p>多线程创建的策略：</p>
<p>1、同步线程：父线程创建子线程后，等到所有的子线程执行完毕，自己才继续执行（分叉-连接策略）。这里，由父线程创建的线程并发执行工作，但是父线程在这个工作完成之前无法继续。一旦每个线程完成了它的工作，它就会终止，并与父线程连接。只有在所有子线程都连接之后，父线程才恢复执行。通常，同步线程涉及线程之间的大量数据的共享。例如，父线程可以组合由子线程计算的结果。</p>
<p>2、异步线程：父线程创建子线程后，自己恢复自身的执行，这样父线程与子线程会并发执行。每个线程的运行独立于其他线程，父线程无需知道子线程何时终止。由于线程是独立的，所以线程之间通常很少有数据共享。</p>
<p><img src="../images/image-20210123113518672.png" alt="image-20210123113518672"></p>
<h2 id="3、线程池"><a href="#3、线程池" class="headerlink" title="3、线程池"></a>3、线程池</h2><p>主要思想是:在进程开始时创建一定数量的线程，并加到池中以等待工作。当服务器收到请求时，它会唤醒池内的一个线程(如果有可用线程)，并将需要服务的请求传递给它。一旦线程完成了服务，它会返回到池中再等待工作。如果池内没有可用线程，那么服务器会等待,直到有空线程为止。</p>
<p>线程池具有以下优点:</p>
<ul>
<li>  用现有线程服务请求比等待创建一个线程更快。</li>
<li>  线程池<strong>限制了任何时候可用线程的数量</strong>。这对那些不能支持大量并发线程的系统非常重要。</li>
<li>  <strong>每个线程的运行策略可定制</strong>：将要执行任务从创建任务的机制中分离出来，允许我们采用不同策略运行任务。例如，任务可以被安排在某一个时间延迟后执行,或定期执行。</li>
<li>  <strong>可以提前估算线程池大小</strong>：池内线程的数量可以通过一些因素来加以估算，如系统CPU的数量、物理内存的大小和并发客户请求数量的期望值等。更为高级的线程池架构可以根据使用模式动态调整池内线程数量。这类架构在系统负荷低时，提供了较小的池，从而减低内存消耗。</li>
</ul>
<h1 id="第五章：进程调度"><a href="#第五章：进程调度" class="headerlink" title="第五章：进程调度"></a>第五章：进程调度</h1><h2 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h2><p>CPU 调度 = 处理器调度 = 进程调度</p>
<p>单处理器系统：同一时间只有一个进程可以运行</p>
<p>多处理器系统：多个进程同时处于内存。当一个进程等待时，操作系统就从该进程接管 CPU 控制权，并把 CPU 交给另外一个进程。</p>
<p>三层调度模型：</p>
<p><img src="../images/image-20210201152812097.png" alt="image-20210201152812097"></p>
<h3 id="5-1-1-CPU-调度程序"><a href="#5-1-1-CPU-调度程序" class="headerlink" title="5.1.1 CPU 调度程序"></a>5.1.1 CPU 调度程序</h3><p>每当 CPU 空闲的时候，操作系统就应该从就绪队列中选择一个进程来执行。干这个工作的叫做 <strong>CPU 调度程序</strong>。调度程序从内存里面选择一个可以执行的进程，并为其分配 CPU</p>
<p>队列里面放的是进程控制块（PCB）</p>
<h3 id="5-1-2-什么时候需要进程调度？"><a href="#5-1-2-什么时候需要进程调度？" class="headerlink" title="5.1.2 什么时候需要进程调度？"></a>5.1.2 什么时候需要进程调度？</h3><ol>
<li> 运行状态切换到等待状态（ IO 请求）</li>
<li> 运行状态切换到就绪状态（出现中断）</li>
<li> 等待切换到就绪（IO 请求完成）</li>
<li> 进程终止</li>
</ol>
<p><img src="../images/image-20210201153740780.png" alt="image-20210201153740780"></p>
<p>调度方式：</p>
<p>非抢占式（Nonpreemptive）调度:调度程序一旦把处理器分配给某进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理器分配给另一个进程。如上1、4</p>
<p>抢占式（Preemptive）调度:当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。剥夺原则有：优先权原则、短进程优先原则、时间片原则。如上2、3</p>
<h3 id="5-1-3-Dispatcher（调度程序）"><a href="#5-1-3-Dispatcher（调度程序）" class="headerlink" title="5.1.3 Dispatcher（调度程序）"></a>5.1.3 Dispatcher（调度程序）</h3><p>是个模块，把 CPU 的控制权交给<strong>短期调度程序</strong>选择的进程</p>
<p>功能：</p>
<ul>
<li>  切换上下文</li>
<li>  切换到用户模式</li>
<li>  跳转到用户程序的合适位置，以便重新启动程序</li>
</ul>
<p>特点：尽可能快。因为每次进程切换都需要使用。</p>
<p>Dispatch latency（调度延迟） ：调度程序停止一个进程到启动一个进程所需要的时间</p>
<p>Linux命令：vmstat</p>
<h2 id="5-2-调度准则"><a href="#5-2-调度准则" class="headerlink" title="5.2 调度准则"></a>5.2 调度准则</h2><p><strong>最大化 CPU 利用率和吞吐量，最小化周转时间、等待时间和响应时间，公平！！</strong></p>
<p>周转时间Turnaround time ：进程从提交到完成所经历的时间。包括：在CPU上执行，就绪队列和阻塞队列中等待。</p>
<p>响应时间Response time ：从进程提出请求到首次被响应（而不是输出结果）的时间段（在分时系统环境下）</p>
<p>等待时间Waiting time  – 进程在就绪队列中等待的时间总和</p>
<p>公平性：不因作业或进程本身的特性而使上述指标过分恶化。如长进程等待很长时间。</p>
<p>优先级：可以使关键任务达到更好的指标</p>
<p>调度算法本身的调度性能准则</p>
<ul>
<li>  易于实现</li>
<li>  执行开销比较小</li>
</ul>
<h2 id="5-3-调度算法"><a href="#5-3-调度算法" class="headerlink" title="5.3 调度算法"></a>5.3 调度算法</h2><ul>
<li>  First-Come, First-Served (FCFS) Scheduling     <strong>先来先服务</strong>调度</li>
<li>  Shortest-Job-First (SJF) Scheduling                     <strong>短作业优先</strong>调度</li>
<li>  Priority Scheduling                                               <strong>优先权</strong>调度</li>
<li>  Round Robin (RR)                                                 <strong>时间片轮转</strong>调度</li>
<li>  Multilevel Queue Scheduling                             <strong>多级队列</strong>调度</li>
<li>  Multilevel Feedback Queue Scheduling           多级反馈队列调度</li>
<li>高响应比优先调度算法 Highest Response Ratio Next(HRRN)<ul>
<li>  响应比R = (等待时间 + 要求执行时间) / 要求执行时间</li>
</ul>
</li>
</ul>
<h3 id="5-3-1-FCFS算法"><a href="#5-3-1-FCFS算法" class="headerlink" title="5.3.1 FCFS算法"></a>5.3.1 FCFS算法</h3><ul>
<li>  按照进程或作业提交顺序形成就绪状态的先后次序，分派CPU</li>
<li>  当前进程或作业占用CPU，直到执行完或阻塞，才出让CPU（非抢占方式）</li>
<li>  在进程或作业唤醒后（如I/O完成），并不立即恢复执行，通常等到当前作业或进程出让CPU</li>
<li>  最简单的算法</li>
<li>  用一个队列就可以实现</li>
</ul>
<p>FCFS的特点</p>
<ul>
<li>比较有利于长进程，而不利于短进程。</li>
<li>有利于CPU Bound的进程，而不利于I/O Bound的进程。</li>
</ul>
<h3 id="5-3-2-SJF算法"><a href="#5-3-2-SJF算法" class="headerlink" title="5.3.2 SJF算法"></a>5.3.2 SJF算法</h3><ul>
<li>  对预计执行时间短的作业（进程）优先分派处理器</li>
<li>  最优的算法</li>
<li>  平均等待时间最小</li>
<li>  常用于长期调度</li>
</ul>
<p>SJF的变型：</p>
<ul>
<li>最短剩余时间优先<strong>SRTF</strong>(Shortest Remaining Time First)-基于抢占的SJF算法<ul>
<li>  允许比当前进程剩余时间更短的进程来抢占</li>
</ul>
</li>
<li>最高响应比优先HRRN(Highest Response Ratio Next)<ul>
<li>响应比R = (等待时间 + 要求执行时间) / 要求执行时间<br>  是FCFS和SJF的折衷</li>
</ul>
</li>
</ul>
<h3 id="5-3-3-优先权调度"><a href="#5-3-3-优先权调度" class="headerlink" title="5.3.3 优先权调度"></a>5.3.3 优先权调度</h3><p>该算法总是把处理机分配给就绪队列中具有最高优先权的进程。</p>
<p>常用以下两种方法来确定进程的优先权： </p>
<p>静态优先权: 静态优先权是在创建进程时确定的，在整个运行期间不再改变。依据有：进程类型、进程对资源的要求、用户要求的优先权。</p>
<p>动态优先权: 动态优先权是基于某种原则，使进程的优先权随时间改变而改变。</p>
<p>假定：最小的整数 = 最高的优先级.</p>
<p>SJF是以下一次CPU脉冲长度作为优先数的优先级调度</p>
<p>可以是抢占也可以非抢占</p>
<p>会产生饥饿：优先权低的进程可能永远不会被执行</p>
<ul>
<li>  解决方法：老化：随着时间推移，等待时间长的进程优先级会被提高</li>
</ul>
<h3 id="5-3-4-时间片轮转"><a href="#5-3-4-时间片轮转" class="headerlink" title="5.3.4 时间片轮转"></a>5.3.4 时间片轮转</h3><p>特点：允许抢占，平均等待时间一般较长</p>
<p>基本思路：通过时间片轮转，提高进程并发性和响应时间特性，从而提高资源利用率。</p>
<p>RR算法：</p>
<ul>
<li>  将系统中所有的就绪进程按照FCFS原则，排成一个队列。</li>
<li>  每次调度时将CPU分派给队首进程，让其执行一个时间片 (time slice) 。时间片的长度从几个ms到几百ms。</li>
<li>  在一个时间片结束时，发生时钟中断。</li>
<li>  调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程。</li>
<li>  进程可以未使用完一个时间片，就出让CPU（如阻塞）。</li>
</ul>
<p>时间片长度的影响因素：</p>
<ul>
<li>  就绪进程的数目：数目越多，时间片越小（当响应时间一定时）</li>
<li>  系统的处理能力：应当使用户输入通常在一个时间片内能处理完，否则使响应时间，平均周转时间和平均带权周转时间延长。</li>
</ul>
<p>【其他】</p>
<p>在RR调度算法中，没有进程被连续分配超过一个时间片的CPU（除非它是唯一可运行的进程）。</p>
<p>如果进程的CPU执行超过一个时间片，那么该进程会被抢占，并被放回到就绪队列。</p>
<h3 id="5-3-5-多级队列调度"><a href="#5-3-5-多级队列调度" class="headerlink" title="5.3.5 多级队列调度"></a>5.3.5 多级队列调度</h3><p>特点：引入多个就绪队列，通过各队列的区别对待，达到一个综合的调度目标</p>
<p>根据进程的性质或类型的不同，将就绪队列再分为若干个子队列。</p>
<p>每个作业固定归入一个队列。</p>
<p>各队列的不同处理：不同队列可有不同的优先级、时间片长度、调度策略等。如：系统进程、用户交互进程、批处理进程等。</p>
<p>级队列算法调度须在队列间进行</p>
<ul>
<li><p>  固定优先级调度，即前台运行完后再运行后台。有可能产生饥饿</p>
</li>
<li><p>  给定时间片调度，即每个队列得到一定的CPU时间，进程在给定时间内执行；如，80%的时间执行前台的RR调度，20%的时间执行后台的FCFS调度</p>
</li>
</ul>
<img src="../images/image-20210201160951705.png" alt="image-20210201160951705" style="zoom: 67%;" />

<h3 id="5-3-6-多级反馈队列"><a href="#5-3-6-多级反馈队列" class="headerlink" title="5.3.6 多级反馈队列"></a>5.3.6 多级反馈队列</h3><p>多级反馈队列算法是时间片轮转算法和优先级算法的综合和发展。</p>
<p>优点：</p>
<ul>
<li>  为提高系统吞吐量和缩短平均周转时间而照顾短进程</li>
<li>  为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程</li>
<li>  不必估计进程的执行时间，动态调节</li>
</ul>
<p>设置多个就绪队列，分别赋予不同的优先级，如逐级降低，队列1的优先级最高。每个队列执行时间片的长度也不同，规定优先级越低则时间片越长，如逐级加倍</p>
<p>新进程进入内存后，先投入队列1的末尾，按FCFS算法调度；若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，同样按FCFS算法调度；如此下去，降低到最后的队列，则按”时间片轮转”算法调度直到完成。</p>
<p>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢占执行新进程，并把被抢占的进程投入原队列的末尾。</p>
<img src="../images/image-20210201161158163.png" alt="image-20210201161158163" style="zoom:50%;" />

<h2 id="5-4-线程调度"><a href="#5-4-线程调度" class="headerlink" title="5.4 线程调度"></a>5.4 线程调度</h2><p>在支待线程的操作系统上，内核级线程（而不是进程）才是操作系统所调度的。用户级线程是由线程库来管理的，而内核并不知道它们。用户级线程为了运行在CPU上，最终应映射到相关的内核级线程，但是这种映射可能不是直接的，可能采用轻量级进程(LWP)。</p>
<h1 id="第六章：进程同步"><a href="#第六章：进程同步" class="headerlink" title="第六章：进程同步"></a>第六章：进程同步</h1><p>进程之间竞争资源面临三个控制问题：</p>
<ul>
<li><p>  <strong>互斥</strong>（mutual exclusion )指多个进程不能同时使用同一个资源</p>
</li>
<li><p>  <strong>死锁</strong>（deadlock )指多个进程互不相让，都得不到足够的资源。永远得不到资源</p>
</li>
<li><p>  <strong>饥饿</strong>（starvation )指一个进程长时间得不到资源（其他进程可能轮流占用资源）。资源分配不公平</p>
</li>
</ul>
<h2 id="6-1-临界区问题"><a href="#6-1-临界区问题" class="headerlink" title="6.1 临界区问题"></a>6.1 临界区问题</h2><p>每个进程有一段代码，称为临界区(critical section) ，进程在执行该区时可能修改公共变量、更新一个表、写一个文件等。</p>
<p>当一个进程在临界区内执行时，其他进程不允许在它们的临界区内执行。也就是说，没有两个进程可以在它们的临界区内同时执行。</p>
<p>临界区问题(critical-section problem)是，设计一个协议以便协作进程。在进入临界区前，每个进程应请求许可。实现这一请求的代码区段称为进入区(entry section) 。临界区之后可以有退出区(exit section) ，其他代码为剩余区(remainder section) 。</p>
<p>临界资源：一次只允许一个进程使用(访问)的资源。如：硬件打印机、磁带机等，软件的消息缓冲队列、变量、数组、缓冲区等。</p>
<p>临界区：访问临界资源的那段代码</p>
<p>必须满足的要求：</p>
<ul>
<li>  互斥</li>
<li>  空闲让进</li>
<li>  有限等待</li>
</ul>
<h2 id="6-2-锁"><a href="#6-2-锁" class="headerlink" title="6.2 锁"></a>6.2 锁</h2><h3 id="6-2-1-互斥锁"><a href="#6-2-1-互斥锁" class="headerlink" title="6.2.1 互斥锁"></a>6.2.1 互斥锁</h3><p>一个进程在进入临界区时应得到锁；它在退出临界区时释放锁</p>
<p>当一个进程试图获取不可用的锁时，它会阻塞，直到锁被释放</p>
<h3 id="6-2-2-自旋锁-spinlock"><a href="#6-2-2-自旋锁-spinlock" class="headerlink" title="6.2.2 自旋锁 spinlock"></a>6.2.2 自旋锁 spinlock</h3><p>是一个与共用数据结构有关的锁定机制。特殊形式的互斥锁</p>
<p>储存在共用内存中。为了速度和使用任何在处理器体系下提供的锁定机构，获取和释放自旋锁的代码是用汇编语言写的。</p>
<p>当线程试图获得自旋锁时，在处理器上所有其它工作将终止。因此<strong>拥有自旋锁的线程永远不会被抢占</strong>，但允许它继续执行以便使它尽快把锁释放。内核对于使用自旋锁十分小心，当它拥有自旋锁时，它执行的指令数将减至最少。</p>
<p>【优点】：当进程在等待锁时，没有上下文切换（上下文切换可能需要相当长的时间） 。</p>
<p>因此，当使用锁的时间较短时，自旋锁还是有用的。自旋锁通常用于多处理器系统，一个线程可以在一个处理器上“旋转＂，而其他线程在其他处理器上执行临界区。</p>
<h2 id="6-3-信号量"><a href="#6-3-信号量" class="headerlink" title="6.3 信号量"></a>6.3 信号量</h2><p>整形变量，只能 wait( ）和signal( ），原子性操作，当 S &lt;= 0 的时候，进程必须等待</p>
<p>通常用信号量表示资源或临界区</p>
<p>信号量的物理含义  </p>
<ul>
<li><p>  <code>S.value &gt;0</code> 表示有 <code>S.value</code> 个资源可用； </p>
</li>
<li><p>  <code>S.value=0</code>  表示无资源可用或表示不允许进程再进入临界区； </p>
</li>
<li><p>  <code>S.value&lt;0</code>  则 <code>|S.value|</code> 表示在等待队列中进程的个数或表示等待进入临界区的进程个数。 </p>
</li>
</ul>
<p>wait(S) ≡ P(S) ≡ down(S)  ： 表示申请一个资源</p>
<p>signal(S) ≡ V(S) ≡ up(S)   ： 表示释放一个资源</p>
<p>分类：</p>
<ul>
<li>  整型信号量</li>
<li>  记录型信号量</li>
<li>  AND型信号量</li>
<li>  二值信号量</li>
</ul>
<p>二值信号量类似互斥锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex;    <span class="comment">//  initialized to 1</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	wait (mutex);</span><br><span class="line">         <span class="comment">// Critical Section</span></span><br><span class="line">     signal (mutex);</span><br><span class="line">		<span class="comment">// remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (TRUE);</span><br></pre></td></tr></table></figure>



<p>计数信号量可以用于控制访问具有多个实例的某种资源。</p>
<p>1、信号量的初值为可用资源数量。</p>
<p>2、当进程需要使用资源时，需要对该信号扯执行wait( ）操作。</p>
<p>3、当进程释放资源时，需要对该信号最执行signal( ）操作。</p>
<p>4、当信号量的计数为0 时，所有资源都在使用中。之后，需要使用资源的进程将会阻塞，直到计数大于0 。</p>
<p>【信号量的实现】</p>
<p>当一个进程执行 P 操作并且发现信号量不为正时，它必须等待。然而，该进程不是忙等待而是阻塞自己 block()。阻塞操作将一个进程放到与信号量相关的等待队列中，并且将该进程状态切换成等待状态。然后，控制转到CPU 调度程序，以便选择执行另一个进程。</p>
<p>等待信号量 S 而阻塞的进程，在其他进程执行操作signal( ）后，应被重新执行。进程的重新执行是通过操作 wakeup( ）来进行的，它将进程从等待状态改为就绪状态。然后，进程被添加到就绪队列</p>
<p>wait、signal操作必须成对出现，有一个wait操作就一定有一个signal操作。一般情况下：当为互斥操作时，它们同处于同一进程；当为同步操作时，则不在同一进程中出现。 </p>
<p>如果两个wait操作相邻，那么它们的顺序至关重要，而两个相邻的signal操作的顺序无关紧要。一个同步wait操作与一个互斥wait操作在一起时，同步wait操作在互斥wait操作前。 </p>
<p>wait、signal操作的优缺点 </p>
<p>优点：简单，而且表达能力强 </p>
<p>缺点：不够安全；wait、signal操作使用不当会出现死锁；实现复杂。 </p>
<h2 id="6-4-经典同步问题"><a href="#6-4-经典同步问题" class="headerlink" title="6.4 经典同步问题"></a>6.4 经典同步问题</h2><ul>
<li>  生产者消费者问题（有界缓冲区问题）</li>
<li>  读者写者问题</li>
<li>  哲学家就餐问题</li>
</ul>
<p>生产者-消费者问题是最著名的同步问题，它描述一组生产者（P1  ……Pm）向一组消费者（C1……Cq）提供消息。它们共享一个有限缓冲池（bounded buffer pool）,生产者向其中投放消息，消费者从中取得消息。</p>
<p>生产者-消费者问题是许多相互合作进程的一种抽象。</p>
<p>读者写者</p>
<p>一个数据集（如文件）如果被几个并行进程所共享：</p>
<ul>
<li><p>  有些进程只要求读数据集内容，它称读者</p>
</li>
<li><p>  一些进程则要求修改数据集内容，它称写者</p>
</li>
<li><p>  几个读者可以同时读些数据集，而不需要互斥</p>
</li>
<li><p>  一个写者不能和其它进程（不管是写者或读者）同时访问些数据集，它们之间必须互斥。</p>
</li>
</ul>
<p>当写者写入数据时，独占数据库</p>
<p>【问题变种】</p>
<ul>
<li>第一读者写者问题<ul>
<li>  读者进程不应等待，除非数据库被另一个进程使用</li>
</ul>
</li>
<li>第二读者写者问题<ul>
<li>  一旦写者进程就绪，那么写者进程就必须尽可能快被执行</li>
</ul>
</li>
</ul>
<p>哲学家就餐问题</p>
<p>多个进程之间分配多个资源，并且不会产生饥饿和死锁。</p>
<p>为了避免死锁，把哲学家分为三种状态：思考、饥饿、吃饭，并且一次拿到两只筷子，否则不拿。（Dijkstra）</p>
<h2 id="6-5-管程"><a href="#6-5-管程" class="headerlink" title="6.5 管程"></a>6.5 管程</h2><p>管程的定义：管程是关于共享资源的数据结构及一组针对该资源的操作过程所构成的软件模块。</p>
<p>管程是管理进程间同步的机制，它保证进程互斥地访问共享变量，并方便地阻塞和唤醒进程。</p>
<p>管程可以函数库的形式实现。相比之下，管程比信号量好控制</p>
<p>主要特性：</p>
<ul>
<li><p>  模块化：一个管程是一个基本程序单位，可以单独编译；</p>
</li>
<li><p>  抽象数据类型：管程是一种特殊的数据类型，其中不仅有数据，而且有对数据进行操作的代码</p>
</li>
<li><p>  信息封装：管程是半透明的，管程中的外部过程（函数）实现了某些功能，至于这些功能是怎样实现的，在其外部则是不可见的；</p>
</li>
</ul>
<p>实现要素：</p>
<ul>
<li><p>  管程中的共享变量在管程外部是不可见的，外部只能通过调用管程中所说明的外部过程（函数）来间接地访问管程中的共享变量；</p>
</li>
<li><p>  为了保证管程共享变量的数据完整性，规定管程互斥进入；</p>
</li>
<li><p>  管程通常是用来管理资源的，因而在管程中应当设有进程等待队列以及相应的等待及唤醒操作；</p>
</li>
</ul>
<p>组成：</p>
<ul>
<li><p>  名称：为每个共享资源设立一个管程</p>
</li>
<li><p>  数据结构说明：一组局部于管程的控制变量</p>
</li>
<li><p>  操作原语：对控制变量和临界资源进行操作的一组原语过程（程序代码），是访问该管程的唯一途径。这些原语本身是互斥的，任一时刻只允许一个进程去调用，其余需要访问的进程就等待。</p>
</li>
<li><p>  初始化代码：对控制变量进行初始化的代码</p>
</li>
</ul>
<p>由于管程通常是用于管理资源的，因而在管程内部，应当存在某种等待机制。当进入管程的进程因资源被占用等原因不能继续运行时使其等待。为此在管程内部可以说明和使用一种特殊类型的变量—-<strong>条件变量</strong>。</p>
<p>每个条件变量表示一种等待原因，并不取具体数值－－相当于每个原因对应一个队列。</p>
<h1 id="第七章：死锁"><a href="#第七章：死锁" class="headerlink" title="第七章：死锁"></a>第七章：死锁</h1><h2 id="7-1-概念"><a href="#7-1-概念" class="headerlink" title="7.1 概念"></a>7.1 概念</h2><p>死锁：指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进</p>
<p>四个必要条件：</p>
<p>1、互斥：一个资源同一时间只能被一个进程使用</p>
<p>2、Hold and wait（占有并等待、请求和保持）：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已经获得的其它资源保持不放</p>
<p>3、不可抢占、不剥夺：已有的资源不能被抢占</p>
<p>4、循环等待</p>
<h2 id="7-2-处理策略"><a href="#7-2-处理策略" class="headerlink" title="7.2 处理策略"></a>7.2 处理策略</h2><p>简单讲：预防、避免、检测、解除、装死看不到</p>
<p>大体分三种：</p>
<p>1、通过协议来预防或避免死锁，确保系统不会进入死锁状态。打破死锁的必要条件，一般是限制申请资源来解决，或者运行抢占资源，再比如就是进程有序申请资源</p>
<p>2、可以允许系统进入死锁状态，然后检测它，并加以恢复。</p>
<p>3、可以忽视这个问题，认为死锁不可能在系统内发生（如果发生了，程序员自己解决）</p>
<h2 id="7-3-死锁避免算法"><a href="#7-3-死锁避免算法" class="headerlink" title="7.3 死锁避免算法"></a>7.3 死锁避免算法</h2><h3 id="7-3-1-资源分配图算法"><a href="#7-3-1-资源分配图算法" class="headerlink" title="7.3.1 资源分配图算法"></a>7.3.1 资源分配图算法</h3><p>算法：假设进程Pi申请资源Rj。只有在需求边Pi –&gt; Rj 变成分配边 Rj –&gt; Pi 而不会导致资源分配图形成环时，才允许申请。</p>
<p>用算法循环检测，如果没有环存在，那么资源分配会使系统处于安全状态。如果存在环，资源分配会使系统不安全。进程Pi必须等待。</p>
<h3 id="7-3-2-银行家算法"><a href="#7-3-2-银行家算法" class="headerlink" title="7.3.2 银行家算法"></a>7.3.2 银行家算法</h3><p>Dijkstra 提出的</p>
<h2 id="7-4-死锁检测"><a href="#7-4-死锁检测" class="headerlink" title="7.4 死锁检测"></a>7.4 死锁检测</h2><p>死锁检测</p>
<p>死锁恢复</p>
<ul>
<li>终止进程<ul>
<li>  终止所有死锁的进程</li>
<li>  一次终止一个进程，直到消除死锁循环为止</li>
</ul>
</li>
<li>允许资源抢占<ul>
<li>  选择牺牲进程</li>
<li>  回滚牺牲的进程</li>
<li>  饥饿避免（不能总牺牲同一个）</li>
</ul>
</li>
</ul>
<h1 id="第八章：内存管理"><a href="#第八章：内存管理" class="headerlink" title="第八章：内存管理"></a>第八章：内存管理</h1><h2 id="8-1-背景"><a href="#8-1-背景" class="headerlink" title="8.1 背景"></a>8.1 背景</h2><p>操作系统的主要目的是执行程序，在执行时，这些程序及其访问的数据应该至少部分在内存中。</p>
<p>内存是现代计算机运行的核心 。 内存由一个很大的字节数组来组成， 每个字节都有各自的地址。 CPU 根据程序计数器的值从内存中提取指令，这些指令可能引 起对特定内存地址的额外加载与存储。 </p>
<p>CPU 可以直接访问的通用存储只有<strong>内存</strong>和处理器<strong>内置的寄存器</strong>。 机器指令可以用内存地址作为参数，而不能用磁盘地址作为参数。 因此，执行指令以及指令使用的数据，应处在这些可直接访问的存储设备上。 如果数据不在内存中，那么在 CPU 使用它们之前应先把数据移到内存。 </p>
<p>CPU 内置寄存器通常可以在一个 CPU 时钟周期内完成访问。对千寄存器的内容，大多数 CPU 可以在一个时钟周期内解释并执行一条或多条指令。而对于内存（它可通过内存总线的事务来访问），就不行了。完成内存的访问可能需要多个 CPU 时钟周期。在这种情况下，由于没有数据以便完成正在执行的指令，CPU 通常需要暂停(stall)。由于内存访问的频繁，这种情况是无法容忍的。补救措施是在 CPU 与内存之间，通常是在 CPU 芯片上，增加更快的内存；这称为高速缓存(cache)</p>
<p><img src="../images/image-20210210141158021.png" alt="image-20210210141158021"></p>
<p>确保每个进程都有一个单独的内存空间。 单独的进程内存空间可以保护 进程而不互相影响</p>
<p>基地址寄存器(base register) 含有最小的合法的物理内存地址，而界限地址寄存器 (limit register) 指定了范围的大小。 </p>
<p><img src="../images/image-20210210140936759.png" alt="image-20210210140936759"></p>
<p>内存空间保护的实现是通过 CPU 硬件对在用户模式下产生的地址与寄存器的地址进行比较来完成的</p>
<p>只有操作系统可以通过特殊的特权指令，才能加载基地址寄存器和界限地址寄存器。</p>
<h3 id="8-1-1-绝对地址和相对地址"><a href="#8-1-1-绝对地址和相对地址" class="headerlink" title="8.1.1 绝对地址和相对地址"></a>8.1.1 绝对地址和相对地址</h3><p>Logical address（逻辑地址，相对地址，虚地址）</p>
<ul>
<li><p>用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式。</p>
</li>
<li><p>首地址为0，其余指令中的地址都相对于首地址来编址。</p>
</li>
<li><p>不能用逻辑地址在内存中读取信息。</p>
</li>
</ul>
<p>Physical address （物理地址，绝对地址，实地址）</p>
<ul>
<li>内存中存储单元的地址。</li>
<li>物理地址可直接寻址</li>
</ul>
<p>从虚拟地址到物理地址的运行时映射是由内存管理单元 (Memory-Management Unit, MMU ) 的硬件设备来完成。</p>
<h2 id="8-1-2-动态加载和动态链接"><a href="#8-1-2-动态加载和动态链接" class="headerlink" title="8.1.2 动态加载和动态链接"></a>8.1.2 动态加载和动态链接</h2><p> 采用动态加载时，一个程序只有在调用时才会加载。所有程序都以 可重定位加载格式保存在磁盘上。</p>
<p>程序执行步骤：</p>
<p>1、主程序被加载到内存，并执行。 </p>
<p>2、当一个程序需要调用另一 个程序时，调用程序首先检查另一个程序是否已加载。 如果没有，可重定位链接程序会加 载所需的程序到内存，并更新程序的地址表以反映这一变化。 </p>
<p>3、控制传递给新加载的 程序。</p>
<p>优点：只有一个程序被需要时，它才会被加载；</p>
<p>在内核模式下执行的操作系统可以无限制地访问操作系统及用户的内存。 </p>
<p>1、加载用户程序到用户内存</p>
<p>2、转储出现错误的程序</p>
<p>3、访问和修改系统调用的参数</p>
<p>4、执行用户内存的 IO</p>
<p>5、提供许多其他服务等</p>
<h2 id="8-2-Swapping（交换技术）"><a href="#8-2-Swapping（交换技术）" class="headerlink" title="8.2 Swapping（交换技术）"></a>8.2 Swapping（交换技术）</h2><p>进程必须在内存中以便执行。不过，进程可以暂时从内存交换(swap)到备份存储(backing store)，当再次执行时再调回到内存中。</p>
<p>交换有可能让所有进程的总的物理地址空间超过真实系统的物理地址空间，</p>
<p>如果我们想要换出一个进程，那么应确保该进程是完全处于空闲的。</p>
<p>一个常用的变种是(UNIX, Linux, and Windows)：</p>
<p>正常情况下，禁止交换；</p>
<p>当空闲内存（未被操作系统或进程使用的内存）低千某个阙值时，启用交换。</p>
<p>当空闲内存的数量增加了，就停止交换。</p>
<p>另一变种是交换进程的部分（而不是整个进程），以降低交换时间。</p>
<p>移动系统不支持交换，Flash memory based：</p>
<ul>
<li><p>小空间</p>
</li>
<li><p>闪存写次数限制</p>
</li>
<li><p>在移动平台上闪存和 CPU 之间的吞吐量很低</p>
</li>
</ul>
<p>iOS要求应用程序自愿放弃分配的内存</p>
<ul>
<li><p>只读数据从系统中直接删除，已修改数据不会被删除</p>
</li>
<li><p>OS可以终止任何未能释放足够空间的应用</p>
</li>
</ul>
<p>Android如果空闲内存不足，会终止应用程序，但首先会将应用程序状态写入闪存，以便快速重启</p>
<h2 id="8-3-连续内存分配"><a href="#8-3-连续内存分配" class="headerlink" title="8.3 连续内存分配"></a>8.3 连续内存分配</h2><p>内存通常分为两个区域：一个用于驻留操作系统，另一个用于用户进程。</p>
<p>操作系统可以放在低内存，也可放在高内存。影响这一决定的主要因素是中断向量的位置。由于中断向量通常位于低内存，因此程序员通常将操作系统也放在低内存</p>
<p>在采用连续内存分配 (contiguous memory allocation) 时， 每个进程位于一个连续的内存区域，与包含下一个进程的内存相连</p>
<h3 id="8-3-1-内存保护"><a href="#8-3-1-内存保护" class="headerlink" title="8.3.1 内存保护"></a>8.3.1 内存保护</h3><p>重定位寄存器、界限寄存器</p>
<p> MMU 通过动态地将逻辑地址加上重定位寄存器的值，来进行映射。 映射后的地址再发送到内存</p>
<p><img src="../images/image-20210210145915125.png" alt="image-20210210145915125"></p>
<h3 id="8-3-2-内存分配"><a href="#8-3-2-内存分配" class="headerlink" title="8.3.2 内存分配"></a>8.3.2 内存分配</h3><p>多分区分配</p>
<p>分区式管理的基本思想是将内存划分成若干个连续区域，称为分区。每个分区只能存放一个进程。 </p>
<ul>
<li><p>fixed partitioning（固定分区）：分区大小固定</p>
</li>
<li><p>Dynamic Partitions（动态分区）：在程序装入内存时把可用内存“切出”一个连续的区域分配给该进程，且分区大小正好适合进程的需要。操作系统维护已分配分区和空闲分区的信息</p>
</li>
</ul>
<p>动态存储分区问题（Dynamic Storage-Allocation Problem）</p>
<p>1、首次适应（First-fit）：分配首个足够大的孔。查找可以从头开始，也可以从上次首次适应结束时开始。一旦找到足够大的空闲孔，就可以停止。 </p>
<p>2、最优适应（Best-fit）：分配最小的足够大的孔。 应查找整个列表</p>
<p>3、最差适应（Worst-fit）：分配最大的孔。 应查找整个列表</p>
<p>4、Next-fit：类似首次适应，每次分区时，查找都从上次结束的地方开始</p>
<p>首次适应和最优适应在执行时间和利用空间方面都好于最差适应。 </p>
<p>首次适应和最优适应在利用空间方面难分伯仲，但是首次适应要更快些。</p>
<h3 id="8-3-3-碎片（Fragmentation）"><a href="#8-3-3-碎片（Fragmentation）" class="headerlink" title="8.3.3 碎片（Fragmentation）"></a>8.3.3 碎片（Fragmentation）</h3><p>首次适应和最优适应算法都有外部碎片 </p>
<p>外部碎片问题的一种解决方法是紧缩 ( compaction) 。 它的目的是移动内存内容，以便将所有空闲空间合并成一整块。 </p>
<p>外部碎片化问题的另一个可能的解决方案是：允许进程的逻辑地址空间是不连续的；这样，只要有物理内存可用，就允许为进程分配内存。 有两种互补的技术可以实现这个解决方 案：分段和分页</p>
<p>内部碎片 (internal fragmentation)，这部分内存在分区内部，但又不能用</p>
<h2 id="8-4-分段"><a href="#8-4-分段" class="headerlink" title="8.4 分段"></a>8.4 分段</h2><p>逻辑地址空间是由一组段构成。每个段都有名称和长度。</p>
<p>地址指定了段名称和段内偏移。因此用户通过两个量来指定地址：段名称和段偏移。</p>
<p>为了实现简单起见，段是编号的，是通过段号而不是段名称来引用。因此，逻辑地址由有序对组成：</p>
<p><code>＜段号s，段偏移d＞</code></p>
<p>通常，在编译用户程序时，编译器会根据输入程序来自动构造段。</p>
<p> 段表的每个条目都有段基地址 (segment base) 和段界限 (segment limit) 。 段基地址包含该段在内存中的开始物理地址，而 段界限指定该段的长度。</p>
<h2 id="8-5-分页"><a href="#8-5-分页" class="headerlink" title="8.5 分页"></a>8.5 分页</h2><p>物理内存分为固定大小的块，称为帧(size is power of 2, between 512 bytes and 8,192 bytes)</p>
<ul>
<li>Linux 、Windows for x86: 4K</li>
<li>查看命令 <code>getconf PAGESIZE</code></li>
</ul>
<p>逻辑内存也分为同样大小的块，称为页</p>
<p>跟踪所有的空闲帧</p>
<p>设置一个页表来将逻辑地址转换为物理地址</p>
<p>页码作为页表的索引 。 页表包含每页所在物理内存的基地址。 这个基地址与页偏移的组合就形成了物理内存地址，可发送到物理单元</p>
<p>有内碎片（可能用不完）</p>
<p>如果进程大小与页大小无关，那么每个进程的内部碎片的均值为半页 。 </p>
<p>分页允许我们使用的物理内存大于 CPU 地址指针可访问的空间 。</p>
<p>TLB 与页表一起使用的方法如下： </p>
<p>TLB 只包含少数的页表条目 。 当 CPU 产生一个逻辑 地址后，它的页码就发送到 TLB。 如果找到这个页码，它的帧码也就立即可用，可用于访 问内存。 </p>
<p>如果页码不在 TLB 中（称为 TLB 未命中 (TLB miss ) ），那么就需访问页表。 取决于 CPU,，这可能由硬件自动处理或通过操作系统的中断来处理。</p>
<p>当得到帧码后，就可以用它们来访间内存。 另外，将页码和帧码添加到 TLB,，这样下次再用时就可很快查找到；如果 TLB 内的条目已满，那么会选择一个来替换</p>
<h1 id="第九章：虚拟内存管理"><a href="#第九章：虚拟内存管理" class="headerlink" title="第九章：虚拟内存管理"></a>第九章：虚拟内存管理</h1><h2 id="9-1-Demand-paging-（请求调页，按需调页，请求页式管理）"><a href="#9-1-Demand-paging-（请求调页，按需调页，请求页式管理）" class="headerlink" title="9.1 Demand paging （请求调页，按需调页，请求页式管理）"></a>9.1 Demand paging （请求调页，按需调页，请求页式管理）</h2><p>仅在需要时才加载页面</p>
<p>有效-无效位方案：当该位被设置为“有效”时，相关联的 页面是合法的，并且在内存中 。 当该位被设置为“无效”时，页面无效（ 即不在进程的逻辑 地址空间中），或有效但只在磁盘上。 对千已调入内存的页面，它的页表条目是照常设置的； 但是对于不在内存的页面，它的页表条目可简单标记为无效，或者包含磁盘上的页面地址。 </p>
<p><img src="../images/image-20210210154135243.png" alt="image-20210210154135243"></p>
<p>对标记为无效的页面访问会产生缺页错误(page fault)。</p>
<p>分页硬件在通过页表转换地址时会注意到无效位被设置，从而陷入操作系统。这种陷阱是由于操作系统未能将所需的页面调入内存引起的。处理这种缺页错误的程序很简单：</p>
<p>1．检查这个进程的内部表，以确定该引用是有效的还是无效的内存访问。</p>
<p>2．如果引用无效，那么终止进程。如果引用有效但是尚未调入页面，那么现在就应调入。</p>
<p>3．找到一个空闲帧（例如，从空闲帧链表上得到一个）。</p>
<p>4．调度一个磁盘操作，以将所需页面读到刚分配的帧。</p>
<p>5．当磁盘读取完成时，修改进程的内部表和页表，以指示该页现在处于内存中。</p>
<p>6．重新启动被陷阱中断的指令。</p>
<p>该进程现在能访问所需的页面，就好像它总是在内存中。</p>
<p>在任何情况下，缺页错误的处理时间有三个主要组成部分：</p>
<p>1、处理缺页错误中断。</p>
<p>2、读入页面。</p>
<p>3、重新启动进程</p>
<h2 id="9-2-写时复制-copy-on-write"><a href="#9-2-写时复制-copy-on-write" class="headerlink" title="9.2 写时复制 (copy-on-write)"></a>9.2 写时复制 (copy-on-write)</h2><p>允许父进程和子进程最初共享相同的页面来工作。</p>
<p> 这些共享页面标记为写时复制，这意味着如果任何一个进程<strong>写入共享页面</strong>，那么就创建共享页面的副本</p>
<p>当使用写时复制技术时，仅复制任何一进程修改的页面，所有未修改的页面可以由父进程和子进程共享。</p>
<p>还要注意，只有可以修改的页面才需要标记为写时复制。不能修改的页面（包含可执行代码的页面）可以由父进程和子进程共享。</p>
<p><img src="../images/image-20210210154730349.png" alt="image-20210210154730349"></p>
<p>可以使用池化技术</p>
<h2 id="9-3-页面置换"><a href="#9-3-页面置换" class="headerlink" title="9.3 页面置换"></a>9.3 页面置换</h2><p>步骤：</p>
<p>1、找到所需页面的磁盘位置。</p>
<p>2、找到一个空闲帧：</p>
<p>​    a．如果有空闲帧，那么就使用它。</p>
<p>​    b．如果没有空闲帧，那么就使用页面置换算法来选择一个牺牲帧(victim frame)。</p>
<p>​    c.     将牺牲帧的内容写到磁盘上，修改对应的页表和帧表。</p>
<p>3、将所需页面读入（新的）空闲帧，修改页表和帧表。</p>
<p>4、从发生缺页错误位置，继续用户进程。</p>
<p><strong>有关算法：</strong></p>
<ul>
<li><p>First-In-First-Out Algorithm (FIFO，先进先出算法) </p>
</li>
<li><p>Optimal Algorithm （OPT，最佳页面置换算法）：置换最长时间不会使用的页面</p>
</li>
<li><p>Least Recently Used (LRU) Algorithm (最近最久使用算法) </p>
</li>
<li><p>LRU Approximation Algorithms （近似LRU算法） ：</p>
<ul>
<li><p>Additional-Reference-Bits Algorithm</p>
</li>
<li><p>Second-Chance（clock） Algorithm</p>
</li>
<li><p>Enhanced Second-Chance  Algorithm</p>
</li>
</ul>
</li>
<li><p>Counting-Base Page Replacement：</p>
<ul>
<li><p>Least Frequently Used Algorithm (LFU，最不经常使用算法）</p>
</li>
<li><p>Most Frequently Used Algorithm (MFU，最经常使用算法)</p>
</li>
</ul>
</li>
</ul>
<p>Page Buffering Algorithm（页面缓冲算法）</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/archives/8eda3648.html</url>
    <content><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote>
<ul>
<li>  [1] 狂神B站视频：<a href="https://www.bilibili.com/video/BV1S54y1R7SB">https://www.bilibili.com/video/BV1S54y1R7SB</a></li>
<li>  [2]菜鸟论坛</li>
</ul>
</blockquote>
<p>一定要逼着自己学习</p>
<span id="more"></span>

<h1 id="NoSQL概述"><a href="#NoSQL概述" class="headerlink" title="NoSQL概述"></a>NoSQL概述</h1><h2 id="网站演进"><a href="#网站演进" class="headerlink" title="网站演进"></a>网站演进</h2><blockquote>
<p>  1、单机 mysql 时代</p>
</blockquote>
<p><img src="../images/image-20210129103812924.png" alt="image-20210129103812924"></p>
<p>网站访问量不会太大，单个数据库基本足够用。更多使用静态 html</p>
<p>思考：网站瓶颈是什么？</p>
<p>1、数据量太大，一个机器放不下</p>
<p>2、数据的索引，一个机器的内存也放不下</p>
<p>3、访问量过大，一个服务器承受不了</p>
<blockquote>
<p>  2、Memcached（缓存）+ MySQL + 垂直拆分（读写分离）</p>
</blockquote>
<p>网站80%的情况都是在读，如果每次都从数据库读，太麻烦，不如放到缓存里面，可以减轻数据库的压力。</p>
<p>发展过程：</p>
<p>优化数据结构和索引 –&gt; 文件缓存（IO）–&gt; Memcached（当时的热门）</p>
<p><img src="../images/image-20210129104453727.png" alt="image-20210129104453727"></p>
<p>数据库读写分离</p>
<blockquote>
<p>  3、分库分表+水平拆分</p>
</blockquote>
<p>每个集群放 ${ 1/3 }$ 的数据，查数据的时候通过一些技术定位数据在那个集群</p>
<p>分库分表减轻压力</p>
<p><img src="../images/image-20210129105111010.png" alt="image-20210129105111010"></p>
<blockquote>
<p>  4、如今</p>
</blockquote>
<p>世界变化很快，技术革新也很快</p>
<p>数据量大，变化也很快。MySQL 存数据量比较大的文件，如图片、文件，效率比较低。</p>
<p>大数据的 IO 压力下，表结构基本没法更改。</p>
<blockquote>
<p>  目前基本的互联网项目架构</p>
</blockquote>
<p> <img src="../images/image-20210129110216263.png" alt="image-20210129110216263"></p>
<h2 id="为什么要用-NoSQL"><a href="#为什么要用-NoSQL" class="headerlink" title="为什么要用 NoSQL?"></a>为什么要用 NoSQL?</h2><p>用户个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长。</p>
<p>这个时候，NoSQL 可以很好处理这些数据。</p>
<h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL?"></a>什么是NoSQL?</h2><blockquote>
<p>  NoSQL，泛指非关系型的数据库。随着互联网<a href="https://baike.baidu.com/item/web2.0/97695">web2.0</a>网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的<a href="https://baike.baidu.com/item/SNS/10242">SNS</a>类型的web2.0纯<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E7%BD%91">动态网</a>站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题。</p>
<p>  来源：百度百科</p>
</blockquote>
<p>NoSQL最常见的解释是“non-relational”， “Not Only SQL”也被很多人接受。</p>
<h2 id="四大分类"><a href="#四大分类" class="headerlink" title="四大分类"></a>四大分类</h2><p><strong>Key-Value 型数据库</strong></p>
<p>这一类数据库主要会使用到一个<strong>哈希表</strong>，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署。但是如果数据库管理员(DBA)只对部分值进行查询或更新的时候，Key/value就显得效率低下了。举例如：Tokyo Cabinet/Tyrant， <strong>Redis</strong>， Voldemort， Oracle BDB。</p>
<p><strong>列存储数据库</strong></p>
<p>这部分数据库通常是用来<strong>应对分布式存储的海量数据</strong>。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。如：Cassandra， <strong>HBase</strong>， Riak.</p>
<p><strong>文档型数据库</strong></p>
<ul>
<li>MongoDB<ul>
<li>  基于分布式文件存储的数据库</li>
<li>  介于关系型数据库和非关系型数据库的产品，非关系型数据库中功能最丰富的</li>
</ul>
</li>
</ul>
<p>文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值，在处理网页等复杂数据时，文档型数据库比传统键值数据库的查询效率更高。如：CouchDB， MongoDb. 国内也有文档型数据库SequoiaDB，已经开源。</p>
<p><strong>图形(Graph)数据库</strong></p>
<ul>
<li>  放的是关系，比如社交网络</li>
</ul>
<p>图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。如：Neo4J， InfoGrid， Infinite Graph。</p>
<p><img src="../images/image-20210129115721896.png" alt="image-20210129115721896"></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>  易扩展</li>
<li>  大数据量，高性能</li>
<li>  数据库结构简单。不需要事先设计数据库，随取随用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NoSQL</span><br><span class="line">- 最终一致性</span><br><span class="line">- CAP 定理 和 BASE （异地多活）</span><br><span class="line">- 高性能、高可用、高可拓展</span><br><span class="line">- 。。。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  了解 3V + 3高</p>
</blockquote>
<p>大数据时代的3V:主要是描述问题的</p>
<p>1.海量Volume</p>
<p>2.多样Variety</p>
<p>3.实时Velocity</p>
<p>大数据时代的3高:主要是对程序的要求</p>
<p>1.高并发</p>
<p>2高可扩</p>
<p>3.高性能</p>
<p>真正在公司中的实践:NoSQL + RDBMS</p>
<h2 id="阿里巴巴演进"><a href="#阿里巴巴演进" class="headerlink" title="阿里巴巴演进"></a>阿里巴巴演进</h2><p><img src="../images/image-20210129112505194.png" alt="image-20210129112505194"></p>
<p>技术急不得，越是慢慢学，才能越扎实！</p>
<p>开源才是技术的王道。</p>
<p>没有什么是加一层解决不了的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、商品的基本信息</span></span><br><span class="line">	名称、价格、商品信息。。。</span><br><span class="line">	关系型数据库就可以了</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、商品的描述（文字比较多）</span></span><br><span class="line">	文档型数据库，MongoDB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、图片</span></span><br><span class="line">	分布式文件系统 FastDFS</span><br><span class="line">	- 淘宝自己的 TFS</span><br><span class="line">	- Google 的 GFS</span><br><span class="line">	- Hadoop HDFS</span><br><span class="line">	- 阿里云 oss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、商品的关键字（搜索）</span></span><br><span class="line">	- 搜索引擎 solr es</span><br><span class="line">	- iSearch ：多隆</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、商品热门的波段信息</span></span><br><span class="line">	- 内存数据库</span><br><span class="line">	- Redis Tair</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、商品的交易，外部的支付接口</span></span><br><span class="line">	- 三方应用</span><br></pre></td></tr></table></figure>

<p>王坚：阿里云的这群疯子</p>
<blockquote>
<p>  <a href="https://mp.weixin.qq.com/s?__biz=MzU0NDEwMTc1MA==&amp;mid=2247490379&amp;idx=1&amp;sn=17857e09e980b41bc188e592422c3459&amp;chksm=fb001f52cc7796444cb18e5a483d3ad26e44fc70d543fa03fb2f56ae74d4db7d65e8d5df7b4e&amp;mpshare=1&amp;scene=1&amp;srcid=1016QBaRRz9JrroPgKJ8xXBp#rd">https://mp.weixin.qq.com/s?__biz=MzU0NDEwMTc1MA==&amp;mid=2247490379&amp;idx=1&amp;sn=17857e09e980b41bc188e592422c3459&amp;chksm=fb001f52cc7796444cb18e5a483d3ad26e44fc70d543fa03fb2f56ae74d4db7d65e8d5df7b4e&amp;mpshare=1&amp;scene=1&amp;srcid=1016QBaRRz9JrroPgKJ8xXBp#rd</a></p>
</blockquote>
<p>大型互联网应用问题：</p>
<ul>
<li>  数据类型太多了</li>
<li>  数据源繁多，经常重构</li>
<li>  数据要改造，大面积改造</li>
</ul>
<p>解决方案：</p>
<p><img src="../images/image-20210129114933182.png" alt="image-20210129114933182"></p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>  是什么？</p>
</blockquote>
<p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
<p>免费、开源、也被称为结构化数据库。</p>
<p>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<blockquote>
<p>  redis是一个key-value<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F">存储系统</a>。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(<a href="https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8">链表</a>)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a>都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，<strong>数据都是缓存在内存中</strong>。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<p>  Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了<a href="https://baike.baidu.com/item/memcached">memcached</a>这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。 [1] </p>
<p>  Redis支持<strong>主从同步</strong>。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</p>
</blockquote>
<p><img src="../images/image-20210129120421191.png" alt="image-20210129120421191"></p>
<blockquote>
<p>  能干啥？</p>
</blockquote>
<p>1、内存存储、持久化（rdb, aof）</p>
<p>2、效率高、可用于告诉缓存</p>
<p>3、发布订阅系统</p>
<p>4、地图信息分析</p>
<p>5、计时器、计数器（浏览量）</p>
<p>6、。。。</p>
<blockquote>
<p>  学习中用到的东西</p>
</blockquote>
<p>1、官网：<a href="https://redis.io/">https://redis.io/</a></p>
<p>2、中文网：<a href="http://www.redis.cn/">http://www.redis.cn/</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows安装"><a href="#windows安装" class="headerlink" title="windows安装"></a>windows安装</h3><p>下载地址：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p>
<p>下载解压即可</p>
<p>推荐在 Linux 下使用</p>
<p><img src="../images/image-20210129121906222.png" alt="image-20210129121906222"></p>
<h3 id="Linux-安装"><a href="#Linux-安装" class="headerlink" title="Linux 安装"></a>Linux 安装</h3><p>下载解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make </span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装路径在 /usr/local/bin</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210129125913256.png" alt="image-20210129125913256"></p>
<p><img src="../images/image-20210129132135846.png" alt="image-20210129132135846"></p>
<p>后面我们使用单机多 Redis 启动集群测试</p>
<h2 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h2><blockquote>
<p>  参考文献;<a href="https://www.runoob.com/redis/redis-benchmarks.html">https://www.runoob.com/redis/redis-benchmarks.html</a></p>
</blockquote>
<p>redis 性能测试的基本命令如下：</p>
<p><code>redis-benchmark [option] [option value]</code><br>注意：该命令是在 redis 的目录下执行的，而不是 redis 客户端的内部指令。</p>
<p><img src="../images/image-20210129124738982.png" alt="image-20210129124738982"></p>
<p><img src="../images/image-20210129132630402.png" alt="image-20210129132630402"></p>
<p>默认 16 个数据库，默认使用 0 号数据库，可以使用 select 选择数据库</p>
<p><img src="../images/image-20210129132910143.png" alt="image-20210129132910143"></p>
<h2 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flushdb <span class="comment"># 清空当前数据库</span></span><br><span class="line">keys * <span class="comment"># 查看所有 key</span></span><br><span class="line">SET key value</span><br><span class="line">exists keyname <span class="comment"># 查看 key 是否存在</span></span><br><span class="line">expire keyname 过期时间 <span class="comment"># 设置过期时间</span></span><br><span class="line">ttl keyname <span class="comment"># 查看过期时间</span></span><br><span class="line">MOVE key db <span class="comment"># 移动一个key到另一个数据库</span></span><br><span class="line">DECR key <span class="comment"># 对key对应的数字做减1操作</span></span><br><span class="line">DEL key [key ...] <span class="comment"># 删除指定的key（一个或多个）</span></span><br><span class="line">RENAME key newkey <span class="comment"># 将key重命名为newkey，如果key与newkey相同，将返回一个错误。如果newkey已经存在，则值将被覆盖。</span></span><br><span class="line">APPEND key value <span class="comment"># 追加一个值到key上，如果不存在，就相当于 setkey</span></span><br><span class="line"></span><br><span class="line">INCR key <span class="comment"># 对存储在指定key的数值执行原子的加1操作。如果指定的key不存在，那么在执行incr操作之前，会先将它的值设定为0。如果指定的key中存储的值不是字符串类型（fix：）或者存储的字符串类型不能表示为一个整数，那么执行这个命令时服务器会返回一个错误</span></span><br></pre></td></tr></table></figure>

<p>官网：<a href="http://www.redis.cn/commands.html#">http://www.redis.cn/commands.html#</a></p>
<blockquote>
<p>  Redis 是单线程的</p>
</blockquote>
<p>Redis是很快的，官方表示，Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了!</p>
<blockquote>
<p>  那为什么Redis这么快？</p>
<p>  <strong>首先，采用了多路复用io阻塞机制</strong><br>  <strong>然后，数据结构简单，操作节省时间</strong><br>  <strong>最后，运行在内存中，自然速度快</strong></p>
</blockquote>
<p>首先，高性能的服务器不一定是多线程的</p>
<p>其次，多线程不一定比单线程效率高（比如，单核 CPU，多线程反而有上下文切换的开销）</p>
<p>Redis 把数据都放到内存，单线程不存在上下文切换的开销，cpu利用率会比多线程高</p>
<h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><p>String、list、set、zset、hash</p>
<blockquote>
<p>  Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作<strong>数据库</strong>、<strong>缓存</strong>和<strong>消息中间件</strong>。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。</p>
</blockquote>
<h2 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h2><ul>
<li>  set</li>
<li>  get</li>
<li>  exists</li>
<li>  append</li>
<li>  incr，incrby</li>
<li>  decr，decrby</li>
<li>  getrange：闭区间</li>
<li>  setrange：替换</li>
<li>  setex：如果存在，则设置过期时间 set with expire</li>
<li>  setnx key value # 如果不存在，则设置值，如果存在，则啥也不干，SET if Not eXists</li>
<li>  mset，mget：批量设置、批量获取</li>
<li>  getset：先get后set，如果不存在值，则返回nil；如果存在值，返回原来的值，并设置新的值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 4</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[4]&gt; select 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists key1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; append key1 12345</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v112345&quot;</span></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"><span class="comment"># i++</span></span><br><span class="line"><span class="comment"># 步长 i+=</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> views 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; incrby views 10</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; decrby views 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">#######################################################</span></span><br><span class="line"><span class="comment"># 字符串范围</span></span><br><span class="line"><span class="comment"># GETRANGE key start end</span></span><br><span class="line"><span class="comment"># 这里都是闭区间的，处理超出范围的请求时，都把结果限制在string内</span></span><br><span class="line">redis&gt; SET mykey <span class="string">&quot;This is a string&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; GETRANGE mykey 0 3</span><br><span class="line"><span class="string">&quot;This&quot;</span></span><br><span class="line">redis&gt; GETRANGE mykey -3 -1</span><br><span class="line"><span class="string">&quot;ing&quot;</span></span><br><span class="line">redis&gt; GETRANGE mykey 0 -1</span><br><span class="line"><span class="string">&quot;This is a string&quot;</span></span><br><span class="line">redis&gt; GETRANGE mykey 10 100</span><br><span class="line"><span class="string">&quot;string&quot;</span></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line"><span class="comment"># SETRANGE key offset value</span></span><br><span class="line">redis&gt; SET key1 <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; SETRANGE key1 6 <span class="string">&quot;Redis&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">redis&gt; GET key1</span><br><span class="line"><span class="string">&quot;Hello Redis&quot;</span></span><br><span class="line"><span class="comment">################################</span></span><br><span class="line"><span class="comment"># SETEX key seconds value # 如果存在，则设置过期时间 set with expire</span></span><br><span class="line"><span class="comment"># SETNX key value # 如果不存在，则设置值，如果存在，则啥也不干，SET if Not eXists</span></span><br><span class="line">redis&gt; SETEX mykey 10 <span class="string">&quot;Hello&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">redis&gt; GET mykey</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; SETNX mykey <span class="string">&quot;Hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; SETNX mykey <span class="string">&quot;World&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; GET mykey</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="comment">#################################</span></span><br><span class="line"><span class="comment"># 批量设置</span></span><br><span class="line"><span class="comment"># mset # MSET是原子的</span></span><br><span class="line"><span class="comment"># mget</span></span><br><span class="line">redis&gt; MSET key1 <span class="string">&quot;Hello&quot;</span> key2 <span class="string">&quot;World&quot;</span>	<span class="comment"># 同时设置多个值</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; GET key1</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">redis&gt; GET key2</span><br><span class="line"><span class="string">&quot;World&quot;</span></span><br><span class="line">redis&gt; MGET key1 key2 nonexisting</span><br><span class="line">1) <span class="string">&quot;Hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;World&quot;</span></span><br><span class="line">3) (nil)</span><br><span class="line">127.0.0.1:6379&gt; MSET key1 <span class="string">&quot;Hello&quot;</span> key2 <span class="string">&quot;World&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; MSETNX key1 <span class="string">&quot;Hello&quot;</span> key2 <span class="string">&quot;World&quot;</span> <span class="comment"># 原子性操作</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; MSETNX key1 <span class="string">&quot;Hello&quot;</span> key3 <span class="string">&quot;Redis&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get key3</span><br><span class="line">(nil)</span><br><span class="line"><span class="comment">#####################</span></span><br><span class="line"><span class="comment"># 设置对象</span></span><br><span class="line"><span class="built_in">set</span> user:1&#123;name:zhangsan,age:2&#125;</span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################</span></span><br><span class="line">getset <span class="comment"># 先get后set</span></span><br><span class="line">127.0.0.1:6379&gt; getset db redis <span class="comment"># 如果不存在值，则返回nil</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getset db mongodb <span class="comment"># 如果存在值，返回原来的值，并设置新的值</span></span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line"><span class="string">&quot;mongodb&quot;</span></span><br></pre></td></tr></table></figure>



<p>使用场景：</p>
<p>value 可以是字符串，也可以是数字</p>
<ul>
<li>  计数器</li>
<li>  统计多单位的数量：uid:2393040:follow 0</li>
<li>  粉丝数</li>
<li>  对象缓存存储</li>
</ul>
<h2 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h2><p>可以当队列，可以当栈</p>
<p>可以存在重复的值</p>
<p>所有的 list 命令都是 l 开头的</p>
<ul>
<li>  lpush：头插法插入线性表中</li>
<li>  rpush：尾插</li>
<li>  lrange：获取索引范围内的值</li>
<li>  lpop：弹出表头元素</li>
<li>  rpop：弹出表尾元素</li>
<li>  lindex：根据索引取值</li>
<li>  llen：获取线性表长度</li>
<li>  lrem：移除指定的值</li>
<li>  ltrim：修剪</li>
<li>  rpoplpush：移除表 1 的最后一个值，并把这个值放到表 2 头</li>
<li>  lset key index value ：将列表 key 下标为 index 的元素的值设置为 value ，当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误</li>
<li>  linsert key BEFORE|AFTER pivot value ：将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush list two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush list 2</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1 <span class="comment"># 顺序和放入的顺序相反，也就是每次都放到队列头(头插)</span></span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"><span class="comment"># 尾部添加值</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list 5</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="comment">####################################################</span></span><br><span class="line"><span class="comment"># lpop</span></span><br><span class="line"><span class="comment"># rpop</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lpop list</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpop list</span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment"># lindex 根据索引取值</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 0</span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LLEN 获取队列的长度</span></span><br><span class="line">127.0.0.1:6379&gt; llen list</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>应用场景：</p>
<ul>
<li>  消息队列</li>
</ul>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>值不能重复</p>
<p>命令都以 S 开头</p>
<ul>
<li>  sadd key member [member …] :将一个或多个 member 元素加入到集合 key 当中，已存在于的元素将被忽略。</li>
<li>  srem：移除值</li>
<li>  smembers key：查看所有成员</li>
<li>  sismember key member ：判断 member 元素是否集合 key 的成员</li>
<li>  scard key：返回集合 key 的数量</li>
<li>  smove source destination member：将 member 元素从 source 集合移动到 destination 集合（原子性操作）</li>
<li>  spop：随机移除一个元素</li>
<li>  srandmember key [count]：返回集合中的一个随机元素</li>
<li>  sinter key [key …] ：取交集</li>
<li>  sinterstore destination key [key …]：把交集存到目标集合中</li>
<li>  sunion key [key …]：取并集</li>
<li>  sunionstore destination key [key …]：取并集，并放到目标集合</li>
<li>  sdiff key [key …] ：取差集</li>
<li>  sdiffstore destination key [key …]：取差集，并放到目标集合</li>
</ul>
<p>应用场景：</p>
<ul>
<li>  抽奖</li>
<li>  共同关注（交集）</li>
</ul>
<h2 id="Hash（哈希表）"><a href="#Hash（哈希表）" class="headerlink" title="Hash（哈希表）"></a>Hash（哈希表）</h2><p>以 H 开头</p>
<ul>
<li>  hset key field value ：将哈希表 key 中的域 field 的值设为 value </li>
<li>  hsetnx key field value：不存在，设置值</li>
<li>  hmset：批量设置值</li>
<li>  hget key field：获取值</li>
<li>  hmget：批量获取值</li>
<li>  hgetall key：获取全部数据</li>
<li>  hdel key field [field …] ：删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略</li>
<li>  hlen</li>
<li>  hexists key field</li>
<li>  hincrby key field increment</li>
<li>  hincrbyfloat key field increment：为哈希表 key 中的域 field 加上浮点数增量 increment</li>
<li>  hkeys key：返回哈希表 key 中的所有字段</li>
<li>  hvals key ：返回哈希表 key 中所有字段的值</li>
</ul>
<p>应用场景：</p>
<ul>
<li>  存变更的数据（比如存一个对象）</li>
<li></li>
</ul>
<h2 id="ZSet（有序集合）"><a href="#ZSet（有序集合）" class="headerlink" title="ZSet（有序集合）"></a>ZSet（有序集合）</h2><ul>
<li>  zadd</li>
<li>  zrem</li>
<li>  zcard</li>
<li>  zcount key min max：统计一定范围内的成员数量</li>
<li>  zscore key member ：返回有序集 key 中，成员 member 的 score 值</li>
<li>  zincrby key increment member：为有序集 key 的成员 member 的 score 值加上增量 increment</li>
<li>  zrange：从小到大</li>
<li>  zrevrange：从大到小</li>
<li>  zrangebyscore key min max [WITHSCORES] [LIMIT offset count]：返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。min 和 max 可以是 -inf 和 +inf</li>
<li>  zrevrangebyscore</li>
<li>  zrank key member ：返回有序集 key 中成员 member 的排名</li>
<li>  zrevrank</li>
<li>  ZREMRANGEBYRANK key start stop ：移除有序集 key 中，指定排名(rank)区间内的所有成员</li>
<li>  zremrangebyscore key min max：移除有序集 key 中，所有 score 值介于 min 和 max 之间(闭区间)的成员</li>
<li>  ZINTERSTORE</li>
<li>  ZUNIONSTORE</li>
</ul>
<p>应用场景：</p>
<ul>
<li>  排序</li>
<li>  加权，如排行榜</li>
</ul>
<h1 id="三大特殊数据类型"><a href="#三大特殊数据类型" class="headerlink" title="三大特殊数据类型"></a>三大特殊数据类型</h1><h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><p>应用：定位、附近的人，打车距离计算</p>
<p>相关命令</p>
<ul>
<li>GEOADD：将指定的地理空间位置（纬度、经度、名称）添加到指定的key中。<ul>
<li>  这些数据将会存储到 <strong>sorted set</strong>。这样的目的是为了方便使用 GEORADIUS 或者 GEORADIUSBYMEMBER 命令对数据进行半径查询等操作。</li>
<li>  有效的经度从-180度到180度。</li>
<li>  有效的纬度从-85.05112878度到85.05112878度</li>
</ul>
</li>
<li>  GEODIST：返回两个给定位置之间的距离。</li>
<li>  GEOHASH：返回一个或多个位置元素的 Geohash 表示</li>
<li>  GEOPOS：从<code>key</code>里返回所有给定位置元素的位置（经度和纬度）。</li>
<li>  GEORADIUS：以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素</li>
<li>  GEORADIUSBYMEMBER：找出位于指定范围内的元素， 但是 <code>GEORADIUSBYMEMBER</code> 的中心点是由给定的位置元素决定的</li>
</ul>
<p>【注意点】：由于是用 ZSET 实现的，所以，zset 的所有命令也适用</p>
<p>参考文档：<a href="http://www.redis.cn/commands/geoadd.html">http://www.redis.cn/commands/geoadd.html</a></p>
<h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><blockquote>
<p>  位存储</p>
</blockquote>
<p><img src="../images/874963-20190930154945790-1681218156.png" alt="img"></p>
<p>基本命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setbit key offset value：对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</span><br><span class="line">getbit key offset：对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</span><br><span class="line">bitcount</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<ul>
<li>  统计用户信息，活跃不活跃</li>
<li>  打卡分析</li>
<li>  两种状态的场景都可以使用</li>
</ul>
<h2 id="Hyperloglogs"><a href="#Hyperloglogs" class="headerlink" title="Hyperloglogs"></a>Hyperloglogs</h2><blockquote>
<p>  基数：集合的大小（不重复元素个数）</p>
</blockquote>
<p>HyperLogLog是一种概率数据结构，用于对唯一事物进行计数（从技术上讲，这是指估计集合的基数）。通常，对唯一项目进行计数需要使用与要计数的项目数量成比例的内存量，因为您需要记住过去已经看到的元素，以避免多次对其进行计数。但是，有一组算法会以内存换取精度：在Redis实现的情况下，您得出的带有标准误差的估计度量最终会小于1％。该算法的神奇之处在于，您不再需要使用与所计数项目数量成比例的内存量，而可以使用恒定数量的内存！最坏情况下为12k字节，</p>
<p>Redis中的HLL尽管在技术上是不同的数据结构，但被编码为Redis字符串，因此您可以调用GET以序列化HLL，并将SET 其反序列化回服务器。</p>
<p> HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素</p>
<p>优点：占用内存是固定的，最坏情况下为12k字节</p>
<p><strong>UV（Unique visitor）</strong>：一天内同个访客多次访问仅计算一个UV</p>
<p>传统方式，set 保存用户的 id，然后统计 set 中的元素数量作为判断标准</p>
<p>这种方式保存了大量的用户 id，比较麻烦！而且随着数据量的增长，占用的空间也会越来越大。</p>
<ul>
<li>  pfadd</li>
<li>  pfcount</li>
<li>  pfmerge</li>
</ul>
<p>应用场景：</p>
<ul>
<li>  页面统计（允许 1% 左右的误差）</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>官方文档：<a href="http://www.redis.cn/topics/transactions.html">http://www.redis.cn/topics/transactions.html</a></p>
<p><a href="https://www.redis.net.cn/tutorial/3515.html">https://www.redis.net.cn/tutorial/3515.html</a></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Redis 单条命令保证原子性，但是事务不保证原子性</p>
<p>事务可以理解为一个批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做</p>
<p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p>
<ul>
<li>  批量操作在发送 EXEC 命令前被放入队列缓存。</li>
<li>  收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>
<li>  在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
</ul>
<p><strong>这里的事务没有隔离级别的概念</strong></p>
<h2 id="事务如何执行？"><a href="#事务如何执行？" class="headerlink" title="事务如何执行？"></a>事务如何执行？</h2><ul>
<li>  开始事务。 <strong>multi</strong></li>
<li>  命令入队。</li>
<li>  执行事务。<strong>exec</strong></li>
</ul>
<p>放弃事务：<strong>discard</strong>（由于没有执行 exec 命令，所以命令都不会被执行）</p>
<h2 id="为什么-Redis-不支持回滚（roll-back）"><a href="#为什么-Redis-不支持回滚（roll-back）" class="headerlink" title="为什么 Redis 不支持回滚（roll back）"></a>为什么 Redis 不支持回滚（roll back）</h2><ul>
<li>  Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>  因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p>如果命令本身有错误，那整个事务都不会被执行（类似于编译型异常）</p>
<p>如果命令没问题，但是逻辑有问题，那条错误逻辑的语句不会被执行（类似于运行时异常）</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; getset k2 <span class="comment"># 这里命令是错的，少了一个参数</span></span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;getset&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt;     </span><br></pre></td></tr></table></figure>



<p>逻辑有误示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1QUEUED127.0.0.1:6379&gt; <span class="built_in">set</span> k2 <span class="string">&quot;v2&quot;</span>QUEUED127.0.0.1:6379&gt; incr k2 <span class="comment"># 字符串不能加 1QUEUED127.0.0.1:6379&gt; exec1) OK2) OK3) (error) ERR value is not an integer or out of range127.0.0.1:6379&gt;         </span></span><br></pre></td></tr></table></figure>



<p>其他示例代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1QUEUED127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2QUEUED127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3QUEUED127.0.0.1:6379&gt; discard <span class="comment"># 放弃事务OK127.0.0.1:6379&gt; get k1(nil)127.0.0.1:6379&gt; get k2(nil)127.0.0.1:6379&gt; get k3(nil)127.0.0.1:6379&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>悲观锁：认为什么时候都会有问题，无论做什么都会加锁</p>
<p>乐观锁：认为不会有问题。更新数据的时候判断一下是否有人修改过这个数据，MySQL 使用版本号来处理</p>
<h2 id="Redis-可以实现乐观锁吗？"><a href="#Redis-可以实现乐观锁吗？" class="headerlink" title="Redis 可以实现乐观锁吗？"></a>Redis 可以实现乐观锁吗？</h2><p>Redis 可以实现乐观锁（watch)，使用 check-and-set 操作实现乐观锁</p>
<p>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p>
<p>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。</p>
<p>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WATCH key [key ...]：监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。UNWATCH：取消 WATCH 命令对所有 key 的监视。</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210202120527685.png" alt="image-20210202120527685"></p>
<p>如果发现事务执行失败，就先解锁，然后重新获取锁即可。</p>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>1、导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="comment">&lt;!--fast-json--&gt;</span>    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.75<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、编码测试</p>
<ul>
<li>  连接数据库</li>
<li>  数据库操作</li>
<li>  断开连接</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;<span class="comment">/** * <span class="doctag">@author</span> 徐文祥 * <span class="doctag">@date</span> 2021/2/2 12:45 */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPing</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">// 1、new jedis 对象        Jedis jedis = new Jedis();        String ping = jedis.ping();        System.out.println(ping);        jedis.close();    &#125;&#125;</span></span><br></pre></td></tr></table></figure>



<p>运行结果：</p>
<p><img src="../images/image-20210202131827825.png" alt="image-20210202131827825"></p>
<p><img src="../images/image-20210202131938414.png" alt="image-20210202131938414"></p>
<p>可以看到，各种操作都有。</p>
<p>没啥意思，以前讲过，跳过</p>
<h1 id="SpringBoot-整合"><a href="#SpringBoot-整合" class="headerlink" title="SpringBoot 整合"></a>SpringBoot 整合</h1><p>SpringBoot 操作数据：SpringData</p>
<h2 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h2><p><a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p>
<ul>
<li>  连接包是跨多个Redis驱动程序（<a href="https://github.com/lettuce-io/lettuce-core">Lettuce</a>和<a href="https://github.com/xetorthio/jedis">Jedis</a>）的底层抽象。</li>
<li>  将Redis驱动程序<a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:connectors">异常</a>转换为Spring的可移植数据访问异常层次结构。</li>
<li>  <a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:template">RedisTemplate</a>提供了用于执行各种Redis操作，异常转换和序列化支持的高级抽象。</li>
<li>  <a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#pubsub">Pubsub</a>支持（例如，消息驱动的POJO的MessageListenerContainer）。</li>
<li>  <a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:sentinel">Redis Sentinel</a>和<a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#cluster">Redis Cluster</a>支持。</li>
<li>  使用Lettuce驱动程序的反应性API。</li>
<li>  JDK，String，JSON和Spring Object / XML映射<a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:serializer">序列化器</a>。</li>
<li>  Redis之上的JDK <a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:support">Collection</a>实现。</li>
<li>  原子<a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:support">计数器</a>支持类。</li>
<li>  排序和流水线功能。</li>
<li>  专门支持SORT，SORT / GET模式和返回的批量值。</li>
<li>  Spring 3.1缓存抽象的Redis<a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:support:cache-abstraction">实现</a>。</li>
<li>  <code>Repository</code>接口的自动实现，包括使用的自定义查询方法的支持<code>@EnableRedisRepositories</code>。</li>
<li>  CDI对存储库的支持。</li>
</ul>
<p>Jedis：采用直连的问题，多个线程操作是不安全的，如果想要避免不安全，就要使用连接池，BIO</p>
<p>Lettuce（莱忒丝）：使用 netty ，实例可以在多个线程中共享，不存在不安全的情况</p>
<p>源码分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span><span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><span class="comment">// 这个注解说明我们可以自定义模板public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)    throws UnknownHostException &#123;    // 默认的 RedisTemplate 没有过多的设置， redis 对象都是需要序列化的    // 两个泛型都是 Object，我们使用需要强制转换    RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();    template.setConnectionFactory(redisConnectionFactory);    return template;&#125;@Bean@ConditionalOnMissingBean// 由于 String 类型最常用，所以这个被单独提取出来了public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory)    throws UnknownHostException &#123;    StringRedisTemplate template = new StringRedisTemplate();    template.setConnectionFactory(redisConnectionFactory);    return template;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>1、导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、配置连接</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1spring.redis.port=6379</span></span><br></pre></td></tr></table></figure>

<p>3、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTestclass</span> Redis02SpringbootApplicationTests &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> RedisTemplate redisTemplate;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;        redisTemplate.opsForValue().set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;k1&quot;</span>));        <span class="comment">// 常用的操作被单独提了出来，可以直接使用，比如事务和基本的CRUD        // 获取连接对象        // RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();    &#125;&#125;</span></span><br></pre></td></tr></table></figure>



<p><img src="../images/image-20210202165950083.png" alt="image-20210202165950083"></p>
<p>再观源码：</p>
<p><img src="../images/image-20210202170834366.png" alt="image-20210202170834366"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (defaultSerializer == <span class="keyword">null</span>) &#123;    defaultSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer(        classLoader != <span class="keyword">null</span> ? classLoader : <span class="keyword">this</span>.getClass().getClassLoader());&#125;</span><br></pre></td></tr></table></figure>

<p>默认是 JDK 序列化，这样会使字符串转义，我们可以使用 JSON </p>
<p>如果对象没有序列化，那么对象就无法在 IO 流中传输，那么就会报错</p>
<p>【强制】：所有的 pojo 类必须序列化（声明实现序列化接口即可）</p>
<p><img src="../images/image-20210202172252965.png" alt="image-20210202172252965"></p>
<p>序列化之后</p>
<p><img src="../images/image-20210202172937353.png" alt="image-20210202172937353"></p>
<p>但是数据库里面还不是人看的:dog:</p>
<p><img src="../images/image-20210202173200585.png" alt="image-20210202173200585"></p>
<h2 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h2><p>先看 RedisTemplate 的 set 方法：</p>
<p><img src="../images/image-20210202173148766.png" alt="image-20210202173148766"></p>
<p>查看序列化方式</p>
<p><img src="../images/image-20210202173425648.png" alt="image-20210202173425648"></p>
<p>固定模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configurationpublic</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;    <span class="comment">// 自定义 RedisTemplate    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;                RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(redisConnectionFactory);// 设置连接        // 创建序列化器        Jackson2JsonRedisSerializer&lt;Object&gt; jsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);        ObjectMapper mapper = new ObjectMapper();        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jsonRedisSerializer.setObjectMapper(mapper);        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();        // key 使用 String 的序列化方式        template.setKeySerializer(stringRedisSerializer);        // hash 的 key 同上        template.setHashKeySerializer(stringRedisSerializer);        // hash 的 value 使用 jackson 的        template.setHashValueSerializer(jsonRedisSerializer);        template.afterPropertiesSet();        return template;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210202180229008.png" alt="image-20210202180229008"></p>
<h1 id="redis-conf-详解"><a href="#redis-conf-详解" class="headerlink" title="redis.conf 详解"></a>redis.conf 详解</h1><p><a href="./redis.conf">详细文件</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1 <span class="comment"># 绑定的地址，注释掉就允许所有的主机连接protected-mode no # 保护模式loglevel notice # 日志级别logfile &quot;&quot; # 这里可以自定义文件名databases 16 # 数据库数量# 多长时间保存一次快照（持久化）# save &lt;seconds&gt; &lt;changes&gt;save 900 1 # 900秒内，如果至少有一个 key 发生变动，则自动保存save 300 10save 60 10000rdbcompression yes # rdb 文件压缩rdbchecksum yes # 是否校验dbfilename dump.rdb # rdb 文件名maxclients 10000 # 允许连接的最大客户端数量maxmemory &lt;bytes&gt; # 最大内存容量maxmemory-policy noeviction # 内存达到上限之后的处理策略noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。（默认值）allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。allkeys-random: 所有key通用; 随机删除一部分 key。volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  REPLICATION 复制</p>
</blockquote>
<p>在 redis-cli 中设置密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config get requirepassconfig <span class="built_in">set</span> requirepass</span><br></pre></td></tr></table></figure>

<blockquote>
<p>APPEND ONLY MODE aof配置</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly no <span class="comment"># 默认不开启appendfilename &quot;appendonly.aof&quot; # aof 文件名# 下面三行是同步策略# appendfsync alwaysappendfsync everysec# appendfsync no</span></span><br></pre></td></tr></table></figure>

<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>RDB 和 AOF</p>
<h2 id="为什么要持久化？"><a href="#为什么要持久化？" class="headerlink" title="为什么要持久化？"></a>为什么要持久化？</h2><p>首先 redis 是内存型数据库，一旦断电数据就会消失。持久化功能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件即可实现数 据恢复</p>
<h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><p>默认文件名：dump.rdb</p>
<p>在主从复制中， RDB 是备用的</p>
<p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发</p>
<p>手动触发分别对应save和bgsave命令</p>
<ul>
<li><p>  save 命令：阻塞当前 Redis 服务器，直到 RDB 过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用</p>
</li>
<li><p>  bgsave 命令：执行 fork 操作创建子进程，持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短</p>
</li>
</ul>
<p>自动触发</p>
<ul>
<li>  配置文件中定义的策略</li>
<li>  从节点执行全量复制操作，主节点自动执行 bgsave 生成 RDB 文件并发送给从节点</li>
<li>  执行 flushall 命令</li>
<li>  默认情况下执行 shutdown 命令时，如果没有开启 AOF 持久化功能则自动执行 bgsave</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; saveOK<span class="comment">########## save 输出 #########[11748] 03 Feb 14:05:30.333 * DB saved on disk# 测试 bgsave127.0.0.1:6379&gt; bgsaveBackground saving started######### bgsave 输出 ###########[11748] 03 Feb 14:06:37.973 * Background saving started by pid 11432[11748] 03 Feb 14:06:38.109 # fork operation complete[11748] 03 Feb 14:06:38.126 * Background saving terminated with success</span></span><br></pre></td></tr></table></figure>

<p>如何恢复数据？</p>
<p>将 dump.rdb 文件放在 redis 启动目录即可，程序启动的时候会自动检测，自己恢复数据</p>
<p>那如何获取启动目录呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir1) <span class="string">&quot;dir&quot;</span>2) <span class="string">&quot;D:\\Environment\\Redis\\Redis-5.0.10&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="RDB优点"><a href="#RDB优点" class="headerlink" title="RDB优点"></a>RDB优点</h3><p>（1）RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。</p>
<p>（2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p>
<p>（3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p>
<h3 id="RDB缺点"><a href="#RDB缺点" class="headerlink" title="RDB缺点"></a>RDB缺点</h3><p>（1）在快照持久化期间修改的数据不会被保存，可能丢失数据</p>
<h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>将每一个写操作都通过write函数追加到 <code>appendonly.aof</code> 文件中</p>
<p>默认文件名：<code>appendonly.aof</code></p>
<p>默认不开启，可以自定义 AOF 的策略</p>
<p>如果 <code>appendonly.aof</code> 文件有错误，可以使用 <code>redis-check-aof</code>来修复</p>
<p>【问题来了】：持久化文件会变的越来越大。</p>
<p>为了压缩 aof 的持久化文件。redis 提供了 bgrewriteaof 命令。将内存中的数据以命令的方式保存到临时文件中，同时会 fork 出一条新进程来将文件重写。</p>
<p>重写 aof 文件的操作，并没有读取旧的 aof 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof 文件</p>
<p><img src="../images/09fa513d269759ee28454d2c4cea4b106c22dfd3.jpeg" alt="img"></p>
<blockquote>
<p>  图片来源：<a href="https://baijiahao.baidu.com/s?id=1654694618189745916&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1654694618189745916&amp;wfr=spider&amp;for=pc</a></p>
</blockquote>
<p>同步策略：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面三行是同步策略# appendfsync always # 每次都同步，性能地appendfsync everysec# appendfsync no # 操作系统自己同步数据，效率高</span></span><br></pre></td></tr></table></figure>

<p>（1）always：每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</p>
<p>（2）everysec：异步操作，每秒记录 如果同步的这一秒机器宕机，这一秒的数据会丢失</p>
<p>（3）no：从不同步</p>
<p>缺点：</p>
<p>（1）文件会越来远大</p>
<p>（2）aof 消耗服务器性能</p>
<p>优点：</p>
<p>（1）可以更好的保护数据不丢失</p>
<p>（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。</p>
<p>（3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</p>
<p>（4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p>
<h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p>一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>消息发布者、频道、消息接受者</p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="../images/pubsub1.png" alt="img"></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="../images/pubsub2.png" alt="img"></p>
<blockquote>
<p>  图片来源：菜鸟论坛</p>
</blockquote>
<h2 id="Redis-发布订阅命令"><a href="#Redis-发布订阅命令" class="headerlink" title="Redis 发布订阅命令"></a>Redis 发布订阅命令</h2><p>redis 发布订阅常用命令：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">[PSUBSCRIBE pattern <a href="https://www.runoob.com/redis/pub-sub-psubscribe.html">pattern …]</a> 订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">[PUBSUB subcommand <a href="https://www.runoob.com/redis/pub-sub-pubsub.html">argument [argument …]]</a> 查看订阅与发布系统状态。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/redis/pub-sub-publish.html">PUBLISH channel message</a> 将信息发送到指定的频道。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">[PUNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-punsubscribe.html">pattern [pattern …]]</a> 退订所有给定模式的频道。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">[SUBSCRIBE channel <a href="https://www.runoob.com/redis/pub-sub-subscribe.html">channel …]</a> 订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">[UNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-unsubscribe.html">channel [channel …]]</a> 指退订给定的频道。</td>
</tr>
</tbody></table>
<p>原理：</p>
<p>源码里的pubsub.c</p>
<p>Redis通过PUBLISH、SUBSCRIBE和PSUBSCRIBE等命令实现发布和订阅功能。</p>
<p>通过SUBSCRIBE 命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个个频道!，而字典的值则是一个链表，链表中保存了所有订阅这个channel的客户端。SUBSCRIBE命令的关键，就是将客户端添加到给定channel的订阅链表中。</p>
<p>通过PUBLISH命令向订阅者发送消息，redis-server会使用给定的频道作为键，在它所维护的channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p>
<p>Pub/Sub从字面上理解就是发布( Publish )与订阅(Subscribe )，在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>
<p>使用场景：</p>
<p>（1）实时聊天系统</p>
<p>（2）实时消息系统</p>
<p>（3）订阅关注系统</p>
<p>稍微复杂的场景一般使用消息中间件</p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)。<strong>数据的复制是单向的</strong>，只能由主节点到从节点。Master 以写为主，Slave 以读为主。</p>
<p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p>Slave 启动成功连接到 master 后会发送一个 sync 同步命令</p>
<p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master 将传送整个数据文件到 slave，并完成一次完全同步。</p>
<p>全量复制︰slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
<p>增量复制：Master 继续将新的所有收集到的修改命令依次传给 slave，完成同步</p>
<p>如果 slave 断开之后重新连接 master，自动执行一次全量复制</p>
<h2 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h2><p>1、<strong>数据冗余</strong>∶主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p>
<p>2、<strong>故障恢复</strong>∶当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复;实际上是一种服务的冗余。</p>
<p>3、<strong>负载均衡</strong>∶在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载;尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p>
<p>4、<strong>高可用基石</strong>∶主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p>
<h2 id="为什么要主从复制？"><a href="#为什么要主从复制？" class="headerlink" title="为什么要主从复制？"></a>为什么要主从复制？</h2><p>负载均衡、减缓服务器的压力、数据冗余</p>
<p>一般来说，要将 Redis 运用于工程项目中，只使用一台Redis是万万不能的（宕机)），原因如下:</p>
<p>1、从结构上，单个 Redis 服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大;</p>
<p>2、从容量上，单个 Redis 服务器内存容量有限，就算一台 Redis 服务器内存容量为 256G，也不能将所有内存用作Redis 存储内存，一般来说，单台 Redis 最大使用内存不应该超过 20G。</p>
<p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p>
<h2 id="主从复制的模型"><a href="#主从复制的模型" class="headerlink" title="主从复制的模型"></a>主从复制的模型</h2><p>1、一主多从</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Redis(master)	|--- Redis(slave)	|--- Redis(slave)	|--- Redis(slave)	|--- Redis(slave)</span><br></pre></td></tr></table></figure>

<p>2、链式结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Redis(master)	|--- Redis(slave)	|--- Redis(slave)<span class="comment"># 这个依旧是从机，依旧是只读的			|--- Redis(slave)			...			|--- Redis(slave)	|--- Redis(slave)			|--- Redis(slave)			|--- Redis(slave)					|--- Redis(slave)					|--- Redis(slave)							|--- Redis(slave)			...			|--- Redis(slave)	|--- Redis(slave)</span></span><br></pre></td></tr></table></figure>



<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>只配置从库，不用配置主库</p>
<p>查看配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication<span class="comment"># Replicationrole:masterconnected_slaves:0master_replid:9dec5892ed6e147c01d2f70f6623358384a3082fmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0</span></span><br></pre></td></tr></table></figure>



<p>改配置：</p>
<p>1、修改端口</p>
<p>2、修改进程 PID</p>
<p>3、修改日志和转储文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">port 6380pidfile /var/run/redis_6380.pidlogfile <span class="string">&quot;redis-6380.log&quot;</span>dbfilename dump-6380.rdb</span><br></pre></td></tr></table></figure>

<p>4、测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(redis-server redis-6.0.10/redis80.conf &amp;)(redis-server redis-6.0.10/redis81.conf &amp;)<span class="comment"># ps -ef | grep redisroot     18846     1  0 Feb03 ?        00:04:12 redis-server *:6379root     22738 22375  0 15:55 pts/1    00:00:00 redis-cliroot     25476     1  0 16:13 ?        00:00:00 redis-server *:6380root     25579     1  0 16:14 ?        00:00:00 redis-server *:6381root     25715 23162  0 16:15 pts/2    00:00:00 redis-cli -p 6379root     25757 23417  0 16:16 pts/3    00:00:00 redis-cli -p 6380root     25791 23647  0 16:16 pts/4    00:00:00 redis-cli -p 6381root     26052 25846  0 16:16 pts/5    00:00:00 grep --color=auto redis</span></span><br></pre></td></tr></table></figure>

<p>5、配置从机（找领导）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379OK127.0.0.1:6380&gt; info replication<span class="comment"># Replicationrole:slavemaster_host:127.0.0.1master_port:6379master_link_status:upmaster_last_io_seconds_ago:1master_sync_in_progress:0slave_repl_offset:28slave_priority:100slave_read_only:1connected_slaves:0master_replid:bcb729b30c2165bbffe4f19b2a758559fade937emaster_replid2:0000000000000000000000000000000000000000master_repl_offset:28second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:28</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@iZbp1dmpxvz04ve468b39aZ:~<span class="comment"># redis-cli -p 6381127.0.0.1:6381&gt; info replication# Replicationrole:masterconnected_slaves:0master_replid:fec89a907b5bfe0c58aaeb13bde8bbdca3670163master_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0127.0.0.1:6381&gt; slaveof 127.0.0.1 6379OK127.0.0.1:6381&gt; info replication# Replicationrole:slavemaster_host:127.0.0.1master_port:6379master_link_status:upmaster_last_io_seconds_ago:2master_sync_in_progress:0slave_repl_offset:182slave_priority:100slave_read_only:1connected_slaves:0master_replid:bcb729b30c2165bbffe4f19b2a758559fade937emaster_replid2:0000000000000000000000000000000000000000master_repl_offset:182second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:183repl_backlog_histlen:0127.0.0.1:6381&gt; </span></span><br></pre></td></tr></table></figure>

<p>6、从主机查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication<span class="comment"># Replicationrole:masterconnected_slaves:2slave0:ip=127.0.0.1,port=6380,state=online,offset=280,lag=0slave1:ip=127.0.0.1,port=6381,state=online,offset=280,lag=0master_replid:bcb729b30c2165bbffe4f19b2a758559fade937emaster_replid2:0000000000000000000000000000000000000000master_repl_offset:280second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:280</span></span><br></pre></td></tr></table></figure>



<p>命令行配置的这种是临时的，一旦宕机就没了。</p>
<p>想要永久的，在配置文件中配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>细节</p>
</blockquote>
<p>主机负责写，从机负责读，不能写</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt; <span class="built_in">set</span> k3 v3(error) READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br></pre></td></tr></table></figure>



<p>数据是自动同步的</p>
<h2 id="如果主机断了会发生什么？"><a href="#如果主机断了会发生什么？" class="headerlink" title="如果主机断了会发生什么？"></a>如果主机断了会发生什么？</h2><p>如果没配置哨兵，从机依旧是连接到主机的，但是还是不能写。</p>
<p>如果主机恢复了，从机还是能读主机的数据</p>
<p>但是，如果从机断了，并且我们只是命令行配置的，从机再次重启就不再是从机了（除非写到配置文件里面）</p>
<p>【注意】这就有问题，我们应该让那些没断的从机自己选举出来一个主机，不能让服务停！！</p>
<p>解决方案一：</p>
<p>使用 <code>slaveof no one</code> 让某一台成为主机</p>
<p>解决方案二：</p>
<p>哨兵模式</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>Redis 从 2.8 开始正式提供了 Sentinel (哨兵， /ˈsentɪnl/  ）架构。</p>
<p>能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p>
<p>哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。</p>
<p>原理：哨兵通过发送命令，等待 Redis 服务器响应，从而监控运行的多个 Redis 实例。</p>
<p><img src="../images/image-20210205170617837.png" alt="image-20210205170617837"></p>
<p>哨兵有两个作用</p>
<p>1、通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</p>
<p>2、当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</p>
<p>一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<p><img src="../images/image-20210205171003249.png" alt="image-20210205171003249"></p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failove r操作。切换成功后，就会通过<strong>发布订阅模式</strong>，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p>
<blockquote>
<p>作者：秃头哥编程<br>链接：<a href="https://www.jianshu.com/p/06ab9daf921d">https://www.jianshu.com/p/06ab9daf921d</a></p>
</blockquote>
<h2 id="哨兵模式怎么投票的？"><a href="#哨兵模式怎么投票的？" class="headerlink" title="哨兵模式怎么投票的？"></a>哨兵模式怎么投票的？</h2><h1 id="缓存穿透和雪崩"><a href="#缓存穿透和雪崩" class="headerlink" title="缓存穿透和雪崩"></a>缓存穿透和雪崩</h1><p>服务的高可用问题</p>
<h2 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h2><p>缓存穿透是指在缓存系统中<strong>没有查询到</strong>数据，而不得不将请求打到数据库上查询的情况</p>
<p><img src="../images/image-20210210173853890.png" alt="image-20210210173853890"></p>
<p>如果是一般查询，没有什么问题，但是遇到高并发状态，比如秒杀，这会给数据库带来极大的压力。</p>
<p>解决缓存穿透，目前一般有两种方案：缓存空值和使用布隆过滤器。</p>
<blockquote>
<p>布隆过滤器：存在一定的误判，不支持删除</p>
</blockquote>
<p>其实就是加一层</p>
<blockquote>
<p>1970年布隆提出了一种布隆过滤器的算法，用来判断一个元素是否在一个集合中。布隆过滤器底层是一个超级大的 bit 数组，默认值都是 0 ，一个元素通过多个hash函数映射到这个 bit 数组上，并且将 0 改成 1。</p>
</blockquote>
<p>步骤：</p>
<p><strong>在服务启动的时候先把数据的查询条件，例如数据的 ID 映射到布隆过滤器上，当然如果新增数据时，除了写入到数据库中之外，也需要将数据的ID存入到布隆过滤器中</strong>。</p>
<p><strong>我们在查询某条数据时，先判断这个查询的 ID 是否存在布隆过滤器中，如果不存在就直接返回空值，而不需要继续查询数据库和缓存，存在布隆过滤器中才继续查询数据库和缓存，这样就解决缓存穿透的问题。</strong></p>
<img src="../images/image-20210210174149449.png" alt="image-20210210174149449" style="zoom:67%;" />

<blockquote>
<p>缓存空值</p>
</blockquote>
<p>如果我们系统是遇到攻击的话，那么很有可能查询的值是伪造的，必然大概率不存在我们的系统中，这样无论查询多少次，在缓存中一直不存在，这样缓存穿透就一直存在。</p>
<p>在这种情况下，我们可以在缓存系统中缓存一个空值，防止穿透一直存在，但是因为空值并不是准确的业务数据，并且会占用缓存的空间，所以我们会给这个空值加一个比较短的过期时间，让空值在短时间之内能够快速过期淘汰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object nullValue = <span class="keyword">new</span> Object();<span class="keyword">try</span> &#123;  Object valueFromDB = getFromDB(uid);<span class="comment">// 从数据库中查询数据  if (valueFromDB == null) &#123;    cache.set(uid, nullValue, 10);// 如果从数据库中查询到空值，就把空值写入缓存，设置较短的超时时间  &#125;   else &#123;    cache.set(uid, valueFromDB, 1000);  &#125;&#125; catch(Exception e) &#123;  cache.set(uid, nullValue, 10);&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>弊端:</strong></p>
<p>1、因为在缓存系统中存了大量的空值，浪费缓存的存储空间，如果缓存空间被占满了，还会还会剔除掉一些已经被缓存的用户信息反而会造成缓存命中率的下降。</p>
<p>2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
<h2 id="什么是缓存击穿？"><a href="#什么是缓存击穿？" class="headerlink" title="什么是缓存击穿？"></a>什么是缓存击穿？</h2><p>缓存击穿，是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<p>当某个 key 在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p>
<p><strong>解决方案</strong></p>
<p>1、设置热点数据永不过期</p>
<p>2、加互斥锁</p>
<p>分布式锁∶使用分布式锁，保证对于每个 key 同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<h2 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h2><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大</p>
<p>当然，服务器宕机重启之后也可能发生。</p>
<p><strong>解决方案</strong></p>
<p>1、<strong>Redis 高可用</strong></p>
<p>既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活!)</p>
<p>2、<strong>限流降级</strong></p>
<p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p>3、<strong>数据预热</strong></p>
<p>在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
<blockquote>
<p>  下面的来自知乎：<a href="https://zhuanlan.zhihu.com/p/81195864">https://zhuanlan.zhihu.com/p/81195864</a></p>
</blockquote>
<blockquote>
<p>  **String **<br>  <strong>Set 集合</strong><br>  <strong>Zset 有序集合</strong><br>  <strong>Hash 散列表</strong><br>  <strong>List 列表</strong></p>
</blockquote>
<p><strong>请列举几个用得到Redis的常用使用场景?</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">缓存，毫无疑问这是Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效；排行榜，在使用传统的关系型数据库（mysql oracle 等）来做这个事儿，非常的麻烦，而利用Redis的SortSet(有序集合)数据结构能够简单的搞定；计算器/限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；简单消息队列，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；Session共享，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。一些频繁被访问的数据，经常被访问的数据如果放在关系型数据库，每次查询的开销都会很大，而放在redis中，因为redis 是放在内存中的可以很高效的访问</span><br></pre></td></tr></table></figure>

<p><strong>简述Redis的数据淘汰机制</strong></p>
<blockquote>
<p>  volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰<br>  volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰<br>  volatile-random从已设置过期时间的数据集中任意选择数据淘汰<br>  allkeys-lru从所有数据集中挑选最近最少使用的数据淘汰<br>  allkeys-random从所有数据集中任意选择数据进行淘汰<br>  noeviction禁止驱逐数据</p>
</blockquote>
<p><strong>Redis怎样防止异常数据不丢失？</strong></p>
<blockquote>
<p>  <strong>RDB 持久化</strong><br>  将某个时间点的所有数据都存放到硬盘上。<br>  可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。<br>  如果系统发生故障，将会丢失最后一次创建快照之后的数据。<br>  如果数据量很大，保存快照的时间会很长。<br>  <strong>AOF 持久化</strong><br>  将写命令添加到 AOF 文件（Append Only File）的末尾。<br>  使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：<br>  选项同步频率always每个写命令都同步everysec每秒同步一次no让操作系统来决定何时同步<br>  <strong>always</strong> 选项会严重减低服务器的性能；<br>  <strong>everysec</strong> 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；<br>  <strong>no</strong> 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量<br>  随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>
</blockquote>
<p><strong>讲一讲缓存穿透，缓存雪崩以及缓存击穿吧</strong></p>
<blockquote>
<p>  <strong>缓存穿透：就是客户持续向服务器发起对不存在服务器中数据的请求。客户先在Redis中查询，查询不到后去数据库中查询。</strong><br>  <strong>缓存击穿：就是一个很热门的数据，突然失效，大量请求到服务器数据库中</strong><br>  <strong>缓存雪崩：就是大量数据同一时间失效。</strong><br>  <strong>打个比方，你是个很有钱的人，开满了百度云，腾讯视频各种杂七杂八的会员，但是你就是没有netflix的会员，然后你把这些账号和密码发布到一个你自己做的网站上，然后你有一个朋友每过十秒钟就查询你的网站，发现你的网站没有Netflix的会员后打电话向你要。你就相当于是个数据库，网站就是Redis。这就是缓存穿透。</strong><br>  <strong>大家都喜欢看腾讯视频上的《水果传》，但是你的会员突然到期了，大家在你的网站上看不到腾讯视频的账号，纷纷打电话向你询问，这就是缓存击穿</strong><br>  <strong>你的各种会员突然同一时间都失效了，那这就是缓存雪崩了。</strong></p>
<p>  <strong>放心，肯定有办法解决的。</strong><br>  <strong>缓存穿透：</strong><br>  <strong>1.接口层增加校验，对传参进行个校验，比如说我们的id是从1开始的，那么id&lt;=0的直接拦截；</strong><br>  <strong>2.缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，这样可以防止攻击用户反复用同一个id暴力攻击</strong><br>  <strong>缓存击穿：</strong><br>  <strong>最好的办法就是设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员</strong><br>  <strong>缓存雪崩：</strong><br>  <strong>1.缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</strong><br>  <strong>2.如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</strong></p>
</blockquote>
<p><strong>说一下Redis中的Master-Slave模式</strong></p>
<p>连接过程</p>
<ol>
<li> 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li>
<li> 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li>
<li> 主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li>
</ol>
<p>主从链</p>
<p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p>
<p><img src="../images/v2-81034e4168e0b70f60caac6619e48bfb_720w.jpg" alt="img"></p>
<p><strong>Sentinel</strong>（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<p>分片</p>
<blockquote>
<p>  分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。<br>  假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中。</p>
<p>  最简单的方式是范围分片，例如用户 id 从 0<del>1000 的存储到实例 R0 中，用户 id 从 1001</del>2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。<br>  还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</p>
<p>  根据执行分片的位置，可以分为三种分片方式：<br>  客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。<br>  代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。<br>  服务器分片：Redis Cluster</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>运行时数据区概述、线程和程序计数器</title>
    <url>/archives/e39549de.html</url>
    <content><![CDATA[<h2 id="概述图"><a href="#概述图" class="headerlink" title="概述图"></a>概述图</h2><p><img src="../images/image-20210711144505791.png" alt="image-20210711144505791"></p>
<span id="more"></span>

<p>具体一点：</p>
<p><img src="../images/image-20210711144716697.png" alt="image-20210711144716697"></p>
<p>线程私有的：虚拟机栈、本地方法栈、程序计数器</p>
<p>线程共享的：堆、堆外内存（永久代或元空间，代码缓存）</p>
<p><img src="../images/image-20210711145124719.png" alt="image-20210711145124719"></p>
<p>JVM 调优优化的是堆空间（95%）和方法区（5%）</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p>
<p>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>JVM 中的 PC 是对物理 PC 寄存器的一种抽象模拟</p>
<p>PC寄存器用来存储指向下一条指令的地址,也即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p><img src="../images/image-20210711150254992.png" alt="image-20210711150254992"></p>
<p>如果执行的是本地方法，PC 的值就未定了。</p>
<blockquote>
<p>唯一一个在 JVM 规范中没有规定 OOM 的区域，同时没有 GC</p>
</blockquote>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><img src="../images/image-20210711151339030.png" alt="image-20210711151339030"></p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h4 id="为什么要PC-？"><a href="#为什么要PC-？" class="headerlink" title="为什么要PC ？"></a>为什么要PC ？</h4><p>上下文切换之后，CPU 需要知道我下面要执行什么指令，PC存的就是指令的地址</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
