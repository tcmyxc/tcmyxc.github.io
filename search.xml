<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Effective C++学习笔记</title>
    <url>/archives/8675909c.html</url>
    <content><![CDATA[<h1 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h1><p>1、优先使用 auto，而非显式类型声明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;<span class="comment">// 存在未初始化的风险，但是编译不会报错</span></span><br><span class="line"><span class="keyword">auto</span> y;<span class="comment">// 如果不初始化，编译就会报错</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>2、如果 auto 推导的类型不符合要求，改用传统的</p>
<blockquote>
<p>详见 Effective Modern C++ 条款6</p>
</blockquote>
<p>3、使用 nullptr，不使用 NULL 或 0</p>
<p>4、用 using 不用 typedef</p>
<p>别名声明 <code>using</code>，起别名可以这样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Integer = <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个不算好的示例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> Integer = <span class="keyword">int</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">	Integer x = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C++</category>
        <category>代码优化</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch</title>
    <url>/archives/d32d37e5.html</url>
    <content><![CDATA[<h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><blockquote>
<p>  百度百科：</p>
<p>  是一个基于<a href="https://baike.baidu.com/item/Lucene/6753302">Lucene</a>的搜索服务器。提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。</p>
<p>  是一种流行的企业级搜索引擎。用于<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353">云计算</a>，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p>
<p>  与名为Logstash的数据收集和日志解析引擎以及名为Kibana的分析和可视化平台一起开发。这三个产品被设计成一个集成解决方案，称为“Elastic Stack”</p>
<p>  支持实时GET请求，适合作为NoSQL数据存储，但缺少<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F/7316617">分布式</a>事务</p>
<p>  写入和查询对资源的消耗都很大，如何合理有效地控制资源，既能满足写入和查询的需求，又能满足资源充分利用，这个问题需要考虑</p>
<p>  官方介绍：</p>
<p>  Elasticsearch 是一个分布式的开源搜索和分析引擎，适用于所有类型的数据，包括文本、数字、地理空间、结构化和非结构化数据。Elasticsearch 在 Apache Lucene 的基础上开发而成，由 Elasticsearch N.V.（即现在的 Elastic）于 2010 年首次发布。Elasticsearch 以其简单的 REST 风格 API、分布式特性、速度和可扩展性而闻名，是 Elastic Stack 的核心组件；Elastic Stack 是适用于数据采集、充实、存储、分析和可视化的一组开源工具。人们通常将 Elastic Stack 称为 ELK Stack（代指 Elasticsearch、Logstash 和 Kibana），目前 Elastic Stack 包括一系列丰富的轻量型数据采集代理，这些代理统称为 Beats，可用来向 Elasticsearch 发送数据。</p>
</blockquote>
<span id="more"></span>

<p>分布式、高扩展、高实时的搜索与<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/6577123">数据分析</a>引擎</p>
<p><img src="../images/image-20210103202906338.png" alt="image-20210103202906338"></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>1、将数据提交到Elasticsearch 数据库中</p>
<p>2、通过分词控制器去将对应的语句分词，将其权重和分词结果一并存入数据</p>
<p>3、当用户搜索数据时候，再根据权重将结果排名，打分，再将返回结果呈现给用户</p>
<p>Solr是一个高性能，采用<a href="https://baike.baidu.com/item/Java/85979">Java</a>开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的<a href="https://baike.baidu.com/item/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">全文搜索引擎</a>。</p>
<p>主要特性包括：高效、灵活的缓存功能，垂直搜索功能，高亮显示搜索结果，通过索引复制来提高可用性，提供一套强大Data Schema来定义字段，类型和设置<a href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90">文本分析</a>，提供基于Web的管理界面等。</p>
<h2 id="ES和solr的差别"><a href="#ES和solr的差别" class="headerlink" title="ES和solr的差别"></a>ES和solr的差别</h2><p>1、当单纯对已有数据进行检索，solr更快；ES建索引快，可用于实时查询</p>
<p>2、当实时建立索引的时候，solr会IO阻塞，查询性能较差，ES这时候优势明显</p>
<p>3、随着数据量的增加，solr的搜索效率会变得更低，es基本无变化</p>
<p>4、solr利用zookeeper进行分布式管理，ES自带分布式协调功能</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="../images/image-20210104195316906.png" alt="image-20210104195316906"></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">bin  启动文件</span><br><span class="line">config  配置文件</span><br><span class="line">	log4j2  日志配置文件</span><br><span class="line">	jvm.options  jvm相关配置</span><br><span class="line">	elasticsearch.yml  es配置文件</span><br><span class="line">lib  相关jar包</span><br><span class="line">modules  功能模块</span><br><span class="line">plugins  插件</span><br></pre></td></tr></table></figure>

<p>localhost:9200</p>
<p><img src="../images/image-20210104211345453.png" alt="image-20210104211345453"></p>
<p>可视化插件：head（需要解决跨域问题）</p>
<h3 id="head安装"><a href="#head安装" class="headerlink" title="head安装"></a>head安装</h3><p>1、下载解压</p>
<p>2、</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure>

<p>3、解决跨域访问问题</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#es配置文件中修改</span></span><br><span class="line"><span class="comment">#开启跨域</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#允许所有人访问</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<p>4、127.0.0.1:9100</p>
<p>中文网址：<a href="http://127.0.0.1:9100/?lang=zh">http://127.0.0.1:9100/?lang=zh</a></p>
<p><img src="../images/image-20210104210851589.png" alt="image-20210104210851589"></p>
<blockquote>
<p>  head当做数据展示工具。查询用Kibana</p>
</blockquote>
<h3 id="Kibana（port-5601"><a href="#Kibana（port-5601" class="headerlink" title="Kibana（port: 5601)"></a>Kibana（port: 5601)</h3><p>Kibana 是一个为 <a href="http://www.oschina.net/p/logstash">Logstash</a> 和 <a href="http://www.oschina.net/p/elasticsearch">ElasticSearch</a> 提供的日志分析的 Web 接口。可使用它对日志进行高效的搜索、可视化、分析等各种操作。</p>
<p>版本要和ES一致</p>
<p>我们使用Kibana开发工具进行数据操作</p>
<p><img src="../images/image-20210104204746447.png" alt="image-20210104204746447"></p>
<h3 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h3><p>Kibana配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">i18n.locale:</span> <span class="string">&quot;zh-CN&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="1、Node-与-Cluster"><a href="#1、Node-与-Cluster" class="headerlink" title="1、Node 与 Cluster"></a>1、Node 与 Cluster</h3><p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。</p>
<p>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p>
<h3 id="2、-Index"><a href="#2、-Index" class="headerlink" title="2、 Index"></a>2、 Index</h3><p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</p>
<p>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</p>
<p>查看当前节点的所有 Index</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://localhost:9200/_cat/indices?v</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210104213128327.png" alt="image-20210104213128327"></p>
<h3 id="3、Document"><a href="#3、Document" class="headerlink" title="3、Document"></a>3、Document</h3><p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。</p>
<p>Document 使用 JSON 格式表示，下面是一个例子。</p>
   <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;user&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;数据库管理&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p>
<h3 id="4、Type（移除）"><a href="#4、Type（移除）" class="headerlink" title="4、Type（移除）"></a>4、Type（移除）</h3><p>Document 可以分组，比如<code>weather</code>这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。</p>
<p>不同的 Type 应该有相似的结构（schema），举例来说，<code>id</code>字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的<a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/mapping.html">一个区别</a>。性质完全不同的数据（比如<code>products</code>和<code>logs</code>）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p>
<p>列出每个 Index 所包含的 Type。</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">localhost:9200/_mapping?pretty=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>根据<a href="https://www.elastic.co/blog/index-type-parent-child-join-now-future-in-elasticsearch">规划</a>，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。</p>
<h1 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h1><p>两种分词策略：</p>
<ul>
<li>  ik_max_word：会将文本做最细粒度的拆分</li>
<li>  ik_smart：会将文本做最粗粒度的拆分</li>
</ul>
<p>直接放在ES的插件目录下即可，然后重启ES</p>
<p>使用Kibana查看分词结果：</p>
<p><img src="../images/image-20210104215913849.png" alt="image-20210104215913849"></p>
<p><img src="../images/image-20210104215940169.png" alt="image-20210104215940169"></p>
<blockquote>
<p>  有些词汇被过度拆分，需要我们手动加到词典里面，在配置文件中自己加</p>
</blockquote>
<h1 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a>REST风格</h1><p>REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/7485920">软件架构</a>风格。它是一种针对<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/2196523">网络应用</a>的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。</p>
<p>REST是设计风格而不是标准</p>
<p><img src="../images/image-20210104221641139.png" alt="image-20210104221641139"></p>
<p>1、创建一个索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /索引/类型名/id</span><br><span class="line">&#123;</span><br><span class="line">	请求体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>1、找官方文档</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p>
<p><img src="../images/image-20210104225442026.png" alt="image-20210104225442026"></p>
<p>2、找依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span>    <span class="tag">&lt;<span class="name">repository</span>&gt;</span>        <span class="tag">&lt;<span class="name">id</span>&gt;</span>es-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>        <span class="tag">&lt;<span class="name">name</span>&gt;</span>elasticsearch snapshot repo<span class="tag">&lt;/<span class="name">name</span>&gt;</span>        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://snapshots.elastic.co/maven/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、找对象</p>
<p><img src="../images/image-20210104225711505.png" alt="image-20210104225711505"></p>
<p>高级客户端调低级的，低级的维护线程池</p>
<p>！！！用完一定要关闭</p>
<p>4、分析类中的方法</p>
<blockquote>
<p>  创建项目</p>
</blockquote>
<p>1、创建一个空项目</p>
<p>2、新建一个模块，添加相应的依赖</p>
<p>3、配置JDK的版本</p>
<p><img src="../images/image-20210104230630801.png" alt="image-20210104230630801"></p>
<p><img src="../images/image-20210104230710933.png" alt="image-20210104230710933"></p>
<p><img src="../images/image-20210105071956199.png" alt="image-20210105071956199"></p>
<blockquote>
<p>  分析</p>
</blockquote>
<p><img src="../images/image-20210104231753274.png" alt="image-20210104231753274"></p>
<blockquote>
<p>  自定义版本依赖，保证和本地一致</p>
</blockquote>
<p><img src="../images/image-20210104232717397.png" alt="image-20210104232717397"></p>
<p><img src="../images/image-20210104232736307.png" alt="image-20210104232736307"></p>
<p><img src="../images/image-20210104232754643.png" alt="image-20210104232754643"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>    <span class="comment">&lt;!--自定义版本依赖，和自己电脑上的一致--&gt;</span>    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.10.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="../images/image-20210105070050309.png" alt="image-20210105070050309"></p>
<p><img src="../images/image-20210105070350055.png" alt="image-20210105070350055"></p>
<blockquote>
<p>  具体API测试</p>
</blockquote>
<h1 id="官方说明"><a href="#官方说明" class="headerlink" title="官方说明"></a>官方说明</h1><h2 id="Elasticsearch-的用途是什么？"><a href="#Elasticsearch-的用途是什么？" class="headerlink" title="Elasticsearch 的用途是什么？"></a>Elasticsearch 的用途是什么？</h2><p>Elasticsearch 在速度和可扩展性方面都表现出色，而且还能够索引多种类型的内容，这意味着其可用于多种用例：</p>
<ul>
<li>  应用程序搜索</li>
<li>  网站搜索</li>
<li>  企业搜索</li>
<li>  日志处理和分析</li>
<li>  基础设施指标和容器监测</li>
<li>  应用程序性能监测</li>
<li>  地理空间数据分析和可视化</li>
<li>  安全分析</li>
<li>  业务分析</li>
</ul>
<h2 id="Elasticsearch-的工作原理是什么？"><a href="#Elasticsearch-的工作原理是什么？" class="headerlink" title="Elasticsearch 的工作原理是什么？"></a>Elasticsearch 的工作原理是什么？</h2><p>原始数据会从多个来源（包括日志、系统指标和网络应用程序）输入到 Elasticsearch 中。<em>数据采集</em>指在 Elasticsearch 中进行<em>索引</em>之前解析、标准化并充实这些原始数据的过程。这些数据在 Elasticsearch 中索引完成之后，用户便可针对他们的数据运行复杂的查询，并使用聚合来检索自身数据的复杂汇总。在 Kibana 中，用户可以基于自己的数据创建强大的可视化，分享仪表板，并对 Elastic Stack 进行管理。</p>
<h2 id="Elasticsearch-索引是什么？"><a href="#Elasticsearch-索引是什么？" class="headerlink" title="Elasticsearch 索引是什么？"></a>Elasticsearch 索引是什么？</h2><p>Elasticsearch <em>索引</em>指相互关联的文档集合。Elasticsearch 会以 <strong>JSON 文档的形式存储数据</strong>。每个文档都会在一组<em>键</em>（字段或属性的名称）和它们对应的值（字符串、数字、布尔值、日期、<em>数值</em>组、地理位置或其他类型的数据）之间建立联系。</p>
<p>Elasticsearch 使用的是一种名为<em>倒排索引</em>的数据结构，这一结构的设计可以允许十分快速地进行全文本搜索。倒排索引会列出在所有文档中出现的每个特有词汇，并且可以找到包含每个词汇的全部文档。</p>
<p>在索引过程中，Elasticsearch 会存储文档并构建倒排索引，这样用户便可以近实时地对文档数据进行搜索。索引过程是在索引 API 中启动的，通过此 API 您既可向特定索引中添加 JSON 文档，也可更改特定索引中的 JSON 文档。</p>
<h2 id="Logstash-的用途是什么？"><a href="#Logstash-的用途是什么？" class="headerlink" title="Logstash 的用途是什么？"></a>Logstash 的用途是什么？</h2><p>Logstash 是 Elastic Stack 的核心产品之一，可用来对数据进行聚合和处理，并将数据发送到 Elasticsearch。Logstash 是一个开源的服务器端<strong>数据处理管道</strong>，允许您在将数据索引到 Elasticsearch 之前同时从多个来源采集数据，并对数据进行充实和转换。</p>
<h2 id="Kibana-的用途是什么？"><a href="#Kibana-的用途是什么？" class="headerlink" title="Kibana 的用途是什么？"></a>Kibana 的用途是什么？</h2><p>Kibana 是一款适用于 Elasticsearch 的<strong>数据可视化和管理工具</strong>，可以提供实时的直方图、线形图、饼状图和地图。Kibana 同时还包括诸如 Canvas 和 Elastic Maps 等高级应用程序；Canvas 允许用户基于自身数据创建定制的动态信息图表，而 Elastic Maps 则可用来对地理空间数据进行可视化。</p>
<h2 id="为何使用-Elasticsearch？"><a href="#为何使用-Elasticsearch？" class="headerlink" title="为何使用 Elasticsearch？"></a>为何使用 Elasticsearch？</h2><p><strong>Elasticsearch 很快。</strong> 由于 Elasticsearch 是在 Lucene 基础上构建而成的，所以在全文本搜索方面表现十分出色。Elasticsearch 同时还是一个<strong>近实时的搜索平台</strong>，这意味着从文档索引操作到文档变为可搜索状态之间的延时很短，一般只有一秒。因此，Elasticsearch 非常适用于对时间有严苛要求的用例，例如安全分析和基础设施监测。</p>
<p><strong>Elasticsearch 具有分布式的本质特征。</strong> Elasticsearch 中存储的文档分布在不同的容器中，这些容器称为<em>分片</em>，可以进行复制以提供数据冗余副本，以防发生硬件故障。Elasticsearch 的分布式特性使得它可以扩展至数百台（甚至数千台）服务器，并处理 PB 量级的数据。</p>
<p><strong>Elasticsearch 包含一系列广泛的功能。</strong> 除了速度、可扩展性和弹性等优势以外，Elasticsearch 还有大量强大的内置功能（例如数据汇总和索引生命周期管理），可以方便用户更加高效地存储和搜索数据。</p>
<p><strong>Elastic Stack 简化了数据采集、可视化和报告过程。</strong> 通过与 Beats 和 Logstash 进行集成，用户能够在向 Elasticsearch 中索引数据之前轻松地处理数据。同时，Kibana 不仅可针对 Elasticsearch 数据提供实时可视化，同时还提供 UI 以便用户快速访问应用程序性能监测 (APM)、日志和基础设施指标等数据。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb-Servlet</title>
    <url>/archives/3dd30874.html</url>
    <content><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Servlet（Server Applet）是<a href="https://baike.baidu.com/item/Java/85979">Java</a> Servlet的简称，称为小服务程序或服务连接器，用Java编写的<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>端程序，具有独立于平台和<a href="https://baike.baidu.com/item/%E5%8D%8F%E8%AE%AE/13020269">协议</a>的特性，主要功能在于交互式地浏览和生成数据，生成动态<a href="https://baike.baidu.com/item/Web/150564">Web</a>内容。</p>
<p>广义的Servlet是指任何实现了Servlet接口的类</p>
<p>Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p>
<p>【总结】实现了servlet接口的java程序，就是servlet</p>
<span id="more"></span>

<h2 id="HelloServlet"><a href="#HelloServlet" class="headerlink" title="HelloServlet"></a>HelloServlet</h2><p>Servlet接口Sun公司有两个默认的实现类：HttpServlet，GenericServlet</p>
<ol>
<li><p>maven模板，webapp，修改web.xml（这部分看自己tomcat服务器web.xml是啥，然后复制个头文件过来就行）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">metadata-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>将项目的结构补充完整，java和resources</p>
<p><img src="../images/image-20210620151553413.png" alt="image-20210620151553413"></p>
</li>
<li><p>编写一个Servlet程序</p>
<ul>
<li><p>编写一个普通的类</p>
</li>
<li><p>实现Servlet接口，这里我们直接继承HttpServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于get或者post只是实现方式不同，可以互相调用，业务逻辑都一样</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">&quot;Hello Servlet!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>编写Servlet的映射</p>
<ul>
<li><p>为什么需要映射？</p>
<ul>
<li><p>因为我们写的是java程序，但是要通过浏览器访问，浏览器访问需要连接服务器，所以我们需要在web服务中注册我们写的Servlet，还需要给个URL路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.tcmyxc.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet请求路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello&lt;<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>配置Tomcat</p>
<ul>
<li>注意配置项目发布的路径</li>
</ul>
<p><img src="../images/image-20210620153251176.png" alt="image-20210620153251176"></p>
</li>
<li><p>启动测试</p>
</li>
</ol>
<p>从 Servlet3 开始，也可以使用注解开发</p>
<p>1、修改 web.xml 根标签的属性 metadata-complete 为 false</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">metadata-complete</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、使用注解开发，不需要在 web.xml 中配置这个 servlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;hello-servlet&quot;, value = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter writer = resp.getWriter();<span class="comment">// 响应流</span></span><br><span class="line">        writer.write(<span class="string">&quot;Hello Servlet&quot;</span>);</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Servlet原理"><a href="#Servlet原理" class="headerlink" title="Servlet原理"></a>Servlet原理</h2><p>Servlet由Web服务器调用</p>
<p><img src="../images/image-20210620150127559.png" alt="image-20210620150127559"></p>
<h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><ol>
<li><p>一个 Servlet 可以指定一个路径</p>
</li>
<li><p>一个 Servlet 可以指定多个路径</p>
</li>
<li><p>一个 Servlet 可以指定通用路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello-servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>可以自定义后缀，但是 <code>*</code> 前面不能加任何东西</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello-servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>每个 web 程序都有一个 ServletContext 对象，代表当前的 web 应用</p>
<h3 id="1、共享数据"><a href="#1、共享数据" class="headerlink" title="1、共享数据"></a>1、共享数据</h3><p>（方便不同 servlet 之间共享数据），一个设置属性的 k, v，另外一个根据属性的 k 获取 v</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;helloServlet&quot;, value = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;徐文祥&quot;</span>);<span class="comment">// 设置值</span></span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;getHelloMsgServlet&quot;, value = &quot;/getMsg&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetHelloMsgServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        String name = (String) servletContext.getAttribute(<span class="string">&quot;name&quot;</span>);<span class="comment">// 取值</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;名字是&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、获取初始化参数"><a href="#2、获取初始化参数" class="headerlink" title="2、获取初始化参数"></a>2、获取初始化参数</h3><p>首先在 <code>web.xml</code> 中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置初始化的参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>jdbcUrl<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/mybatis<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;getInitparameterServlet&quot;, value = &quot;/jdbcUrl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetInitparameterServlet</span> <span class="keyword">extends</span> <span class="title">HelloServlet</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        String jdbcUrl = servletContext.getInitParameter(<span class="string">&quot;jdbcUrl&quot;</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;jdbcUrl: &quot;</span> + jdbcUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="../images/image-20210621001815177.png" alt="image-20210621001815177"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaWeb</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代理断言和日志</title>
    <url>/archives/51911571.html</url>
    <content><![CDATA[<h1 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h1><p>作用：运行时创建一个实现了一个给定接口的新类</p>
<span id="more"></span>

<h2 id="1、何时使用代理"><a href="#1、何时使用代理" class="headerlink" title="1、何时使用代理"></a>1、何时使用代理</h2><p>编译时无法确定需要实现哪个接口时</p>
<p>代理类可以在运行时创建全新的类，代理类能够实现指定的接口，并且具有下列方法：</p>
<ul>
<li>  指定接口所需要的全部方法。</li>
<li>  Object 类中的全部方法，例如，toString、equals等。</li>
</ul>
<p>然而，不能在运行时定义这些方法的新代码。而是要提供一个调用处理器（invocation handler）。调用处理器是实现了 InvocationHandler 接口的类对象。在这个接口中只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, </span></span></span><br><span class="line"><span class="params"><span class="function">                     	Method method, </span></span></span><br><span class="line"><span class="params"><span class="function">                     	Object[] args)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure>

<p>无论何时调用代理对象的方法，调用处理器的 invoke 方法都会被调用，并向其传递 Method 对象和原始的调用参数。调用处理器必须给出处理调用的方式。</p>
<h2 id="2、如何创建代理对象"><a href="#2、如何创建代理对象" class="headerlink" title="2、如何创建代理对象"></a>2、如何创建代理对象</h2><p>要想创建一个代理对象，需要使用 Proxy 类的 newProxyInstance 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,//类加载器，用<span class="keyword">null</span>表示使用默认的类加载器。</span></span></span><br><span class="line"><span class="params"><span class="function">                                          Class&lt;?&gt;[] interfaces,//Class对象数组，每个元素都是需要实现的接口</span></span></span><br><span class="line"><span class="params"><span class="function">                                          InvocationHandler h)</span><span class="comment">//调用处理器</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>



<h2 id="3、使用代理的原因："><a href="#3、使用代理的原因：" class="headerlink" title="3、使用代理的原因："></a>3、使用代理的原因：</h2><ol>
<li> 路由对远程服务器的方法调用。</li>
<li> 在程序运行期间，将用户接口事件与动作关联起来。</li>
<li> 为调试，跟踪方法调用。</li>
</ol>
<h2 id="4、代理类的特性"><a href="#4、代理类的特性" class="headerlink" title="4、代理类的特性"></a>4、代理类的特性</h2><p><strong>代理类是在程序运行过程中创建出来的，一旦被创建，就变成了常规类</strong></p>
<ul>
<li><p>  <strong>所有的代理类都扩展于 Proxy 类</strong>。</p>
</li>
<li><p>  一<strong>个代理类只有一个实例域——调用处理器</strong>，它定义在 Proxy 类中。为了履行代理对象的职责，所需要的任何附加数据都必须存储在调用处理器中。</p>
</li>
<li><p>  <strong>对于特定的类加载器和预设的一组接口来说，只能有一个代理类</strong>。也就是说，如果使用同一个类加载器和接口数组调用两次<code>newProxyInstance</code>方法的话，那么只能够得到同一个类的两个对象，也可以利用<code>getProxyClass</code>方法获得这个类</p>
</li>
<li><p><strong>代理类一定是 public 和 final</strong>。如果代理类实现的所有接口都是 public，代理类就不属于某个特定的包；否则，所有非公有的接口都必须属于同一个包，同时，代理类也属于这个包。<br>  可以通过调用Proxy类中的<code>isProxyClass</code>方法检测一个特定的Class对象是否代表一个代理类。</p>
</li>
<li><p>  所有的代理类都覆盖了Object类中的方法<code>toString</code>、<code>equals</code>和<code>hashCode</code>。如同所有的代理方法一样，这些方法仅仅调用了调用处理器的invoke。Object类中的其他方法（如<code>clone</code>和<code>getClass</code>）没有被重新定义。</p>
</li>
<li><p>  没有定义代理类的名字，Sun虚拟机中的Proxy类将生成一个以字符串$Proxy开头的类名。</p>
</li>
</ul>
<h1 id="断言（assert）"><a href="#断言（assert）" class="headerlink" title="断言（assert）"></a>断言（assert）</h1><h2 id="1、什么是断言？"><a href="#1、什么是断言？" class="headerlink" title="1、什么是断言？"></a>1、什么是断言？</h2><p>在测试期间向代码中插入一些检查语句。当代码发布时，这些插入的检测语句将会被<strong>自动移除</strong></p>
<h2 id="2、如何使用"><a href="#2、如何使用" class="headerlink" title="2、如何使用"></a>2、如何使用</h2><p>1）<code>assert 条件;</code></p>
<p>2）<code>assert 条件 : 表达式;</code>//表达式将被传入AssertionError的构造器，并转换成一个消息字符串</p>
<p>当条件不对时，抛出一个 AssertionError 异常</p>
<p>在默认情况下，断言被禁用。</p>
<ul>
<li>  可以在运行程序时用<code>-enableassertions</code>或<code>-ea</code>选项启用，可以在某个类或整个包中使用断言</li>
<li>  可以用选项<code>-disableassertions</code>或<code>-da</code>禁用某个特定类和包的断言</li>
</ul>
<p>在启用或禁用断言时不必重新编译程序。启用或禁用断言是类加载器（class loader）的功能。当断言被禁用时，类加载器将跳过断言代码，因此，不会降低程序运行的速度。</p>
<p>有些类不是由类加载器加载，而是直接由虚拟机加载。可以使用这些开关有选择地启用或禁用那些类中的断言。</p>
<p>启用和禁用所有断言的<code>-ea</code>和<code>-da</code>开关不能应用到那些没有类加载器的“系统类”上。对于这些系统类来说，需要使用<code>-enablesystemassertions</code> / <code>-esa</code>开关启用断言。</p>
<p><strong>3种处理系统错误的机制：</strong></p>
<ul>
<li>  抛异常</li>
<li>  日志</li>
<li>  使用断言</li>
</ul>
<p><strong>断言是一种测试和调试阶段所使用的战术性工具；而日志记录是一种在程序的整个生命周期都可以使用的策略性工具</strong></p>
<h2 id="3、什么时候应该选择使用断言呢"><a href="#3、什么时候应该选择使用断言呢" class="headerlink" title="3、什么时候应该选择使用断言呢?"></a>3、什么时候应该选择使用断言呢?</h2><ul>
<li>  断言失败是致命的、不可恢复的错误，不应该使用断言向程序的其他部分通告发生了可恢复性的错误</li>
<li>  断言检查只用于开发和测阶段，应该用于在测试阶段确定程序内部的错误位置</li>
</ul>
<p>由于可以使用断言，当方法被非法调用时，将会出现难以预料的结果</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="1、场景再现："><a href="#1、场景再现：" class="headerlink" title="1、场景再现："></a>1、场景再现：</h2><p>每个Java程序员都很熟悉在有问题的代码中插入一些<code>System.out.println</code>方法调用来帮助观察程序运行的操作过程。当然，一旦发现问题的根源，就要将这些语句从代码中删去。如果接下来又出现了问题，就需要再插入几个调用<code>System.out.println</code>方法的语句。</p>
<p><strong>记录日志API就是为了解决这个问题而设计的。</strong></p>
<p>记录日志的常见用途是记录那些不可预料的异常</p>
<p>日志记录并不将消息发送到控制台上，如果想在控制台显示，则需要设置配置文件（位于 jre/lib 目录下）</p>
<p>所有级别为<code>INFO、WARNING和SEVERE</code>的消息都将显示到控制台上。因此，最好只将对程序用户有意义的消息设置为这几个级别。<strong>将程序员想要的日志记录，设定为<code>FINE</code>是一个很好的选择。</strong></p>
<h2 id="2、记录日志-API-的优点"><a href="#2、记录日志-API-的优点" class="headerlink" title="2、记录日志 API 的优点"></a>2、记录日志 API 的优点</h2><ul>
<li>  可以很容易地取消全部日志记录，或者仅仅取消某个级别的日志，而且打开和关闭这个操作也很容易。</li>
<li>  可以很简单地禁止日志记录的输出，因此，将这些日志代码留在程序中的开销很小。</li>
<li>  日志记录可以被定向到不同的处理器，用于在控制台中显示，用于存储在文件中等。</li>
<li>  日志记录器和处理器都可以对记录进行过滤。过滤器可以根据过滤实现器制定的标准丢弃那些无用的记录项</li>
<li>  日志记录可以采用不同的方式格式化，例如，纯文本或XML。</li>
<li>  应用程序可以使用多个日志记录器，它们使用类似包名的这种具有层次结构的名字，例如，com.mycompany.myapp。</li>
<li>  在默认情况下，日志系统的配置由配置文件控制。如果需要的话，应用程序可以替换这个配置。</li>
</ul>
<h2 id="3、简单使用"><a href="#3、简单使用" class="headerlink" title="3、简单使用"></a>3、简单使用</h2><p>要生成简单的日志记录，可以使用全局日志记录器（global logger）并调用其info方法</p>
<p>不要将所有的日志都记录到一个全局日志记录器中，而是自定义日志记录器。可以调用getLogger方法创建或获取记录器，未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况发生，一个静态变量存储日志记录器的一个引用</p>
<h2 id="4、过滤器"><a href="#4、过滤器" class="headerlink" title="4、过滤器"></a>4、过滤器</h2><p>在默认情况下，过滤器根据日志记录的级别进行过滤。每个日志记录器和处理器都可以有一个可选的过滤器来完成附加的过滤。另外，可以通过实现Filter接口并定义<code>isLoggable</code>方法来自定义过滤器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLoggable</span><span class="params">(LogRecord record)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，可以利用自己喜欢的标准，对日志记录进行分析，返回true表示这些记录应该包含在日志中。</p>
<p>要想将一个过滤器安装到一个日志记录器或处理器中，只需要调用setFilter方法就可以了。注意，同一时刻最多只能有一个过滤器。</p>
<h2 id="5、格式化器"><a href="#5、格式化器" class="headerlink" title="5、格式化器"></a>5、格式化器</h2><p>ConsoleHandler类和FileHandler类可以生成文本和XML格式的日志记录。也可以自定义格式，只需要扩展Formatter类并覆盖下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">format</span><span class="params">(LogRecord record)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用setFormatter方法将格式化器安装到处理器中</p>
<h1 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h1><p>1、打印或记录任意变量的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">print一下;</span><br><span class="line">或者</span><br><span class="line">Logger.getGlobai().info(<span class="string">&quot;x=&quot;</span> + x);</span><br><span class="line">Logger.getGlobai().info(<span class="string">&quot;this=&quot;</span> + <span class="keyword">this</span>);<span class="comment">//查看隐式参数对象的状态</span></span><br></pre></td></tr></table></figure>

<p>2、在每一个类中放置一个单独的main方法，这样可以对每一个类进行单元测试。</p>
<p>3、使用JUnit</p>
<p>4、日志代理（logging proxy），截获方法调用，并进行日志记录，然后调用超类中的方法</p>
<p>5、利用Throwable类提供的printStackTrace方法</p>
<p>6、将一个程序中的错误信息保存在一个文件中</p>
<p>7、要想观察类的加载过程，可以用-verbose标志启动Java虚拟机</p>
<p>8、-Xlint选项告诉编译器对一些普遍容易出现的代码问题进行检查</p>
<p>9、jmap实用工具</p>
<p>参考文献：</p>
<blockquote>
<p>  《Java核心技术》</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>代理、断言和日志</category>
      </categories>
      <tags>
        <tag>Java代理、断言和日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射</title>
    <url>/archives/adc18de0.html</url>
    <content><![CDATA[<h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><h2 id="反射定义"><a href="#反射定义" class="headerlink" title="反射定义"></a>反射定义</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>
<span id="more"></span>

<h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><ul>
<li>  运行时分析类</li>
<li>  运行时查看对象</li>
<li>  编写泛型数组代码</li>
<li>利用<code>Method</code>对象的<code>invoke</code>方法调用任意方法<ul>
<li>  <code>Method</code>对象是你想要的调用的方法的对象</li>
<li>  <code>invoke</code>方法调用包装在当前<code>Method</code>对象中的方法</li>
</ul>
</li>
</ul>
<h2 id="反射相关类"><a href="#反射相关类" class="headerlink" title="反射相关类"></a>反射相关类</h2><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a><code>Class</code>类</h3><ul>
<li><p>  <strong>所有反射 API 的入口点</strong></p>
</li>
<li><p>  保存类的所有信息</p>
</li>
<li><p>  没有 public 类型的构造器。</p>
</li>
<li><p>  每个类都有一个 Class 类型的对象，当类被加载时，由 Java 虚拟机调用类加载器的 defineClass 方法构造</p>
</li>
<li><p>  一个 Class 对象实际上表示的是一个类型，而这个类型不一定是类，比如 int 等基本类型不是类，但是 int.class 是一个 Class 类型的对象</p>
</li>
</ul>
<h4 id="获取-Class类对象的三种方法"><a href="#获取-Class类对象的三种方法" class="headerlink" title="获取 Class类对象的三种方法"></a>获取 Class类对象的三种方法</h4><p>1、 <code>对象名.getClass()</code></p>
<p>2、<code>Class.forName(className)</code>：调用 Class 类的 forName 静态方法</p>
<p>3、<code>T.class</code>：T 是任意的 Java 类型或 void 关键字</p>
<p>Class类常用方法</p>
<ul>
<li><p>  <code>getName()</code>：返回类的全限定名</p>
</li>
<li><p>静态方法 <code>forName(className)</code>：获取类名对应的 Class 对象</p>
<ul>
<li>  className 必须是类名或者接口名，而且必须是全限定名</li>
</ul>
</li>
<li><p>  <code>newInstance()</code>：创建一个类的实例，调用的是无参构造函数，如果没有无参构造，会抛异常</p>
</li>
<li><p>  <code>getFields</code>、<code>getMethods</code>、<code>getConstructors</code>：返回类的 publis 域，方法和构造器数组，包括父类的</p>
</li>
<li><p>  <code>getDeclareFields</code>、<code>getDeclareMethods</code>、<code>getDeclareConstructors</code>：返回类的全部域，方法和构造器数组，但是不包括父类的</p>
</li>
</ul>
<h3 id="Field、Method、Constructor类"><a href="#Field、Method、Constructor类" class="headerlink" title="Field、Method、Constructor类"></a><code>Field</code>、<code>Method</code>、<code>Constructor</code>类</h3><p>查看对象域的关键方法是 <code>Field</code>类的各种 get 方法</p>
<p>设置域的值是<code>Field</code>类各种 set 方法，最常用的是<code>set(obj, value)</code></p>
<p><strong>几个共有的方法：</strong></p>
<p><code>getName()</code> 方法：返回项目的名称</p>
<p><code>getModifier()</code>：返回一个整数值，代表不同的修饰符，结合<code>Modifier</code>类的静态方法<code>isPublic</code>等可以判断修饰符类型</p>
<p><code>setAccessible()</code>：只需在括号里给个 true，就可以为所以为，想拿到哪个属性就拿哪个 </p>
<h3 id="Modifier类"><a href="#Modifier类" class="headerlink" title="Modifier类"></a><code>Modifier</code>类</h3><p>有检测各种修饰符的方法，如<code>isPublic</code>等</p>
<h2 id="使用反射编写泛型数组代码（扩展任意类型的数组）"><a href="#使用反射编写泛型数组代码（扩展任意类型的数组）" class="headerlink" title="使用反射编写泛型数组代码（扩展任意类型的数组）"></a>使用反射编写泛型数组代码（扩展任意类型的数组）</h2><p>1、获取数组的类对象</p>
<p>2、确认它是个数组</p>
<p>3、确定数组类型和长度</p>
<p>4、复制数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodArrayCopyOf</span><span class="params">(Object a, <span class="keyword">int</span> newLength)</span></span>&#123;</span><br><span class="line">    Class cl = a.getClass();</span><br><span class="line">    <span class="keyword">if</span>(!cl.isArray())  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Class componentType = cl.getComponentType();</span><br><span class="line">    <span class="keyword">int</span> length = Array.getLength(a);</span><br><span class="line">    Object newArray = Array.newInstance(componentType, newLength);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>Java反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua 编译</title>
    <url>/archives/41ff62c0.html</url>
    <content><![CDATA[<h1 id="一、环境以及安装包"><a href="#一、环境以及安装包" class="headerlink" title="一、环境以及安装包"></a>一、环境以及安装包</h1><h2 id="1-1-环境以及安装包"><a href="#1-1-环境以及安装包" class="headerlink" title="1.1 环境以及安装包"></a>1.1 环境以及安装包</h2><ul>
<li>gcc 编译环境（本人选择TDM-GCC9.2.0，<a href="https://jmeubank.github.io/tdm-gcc/">下载链接</a>）</li>
<li>Lua 源代码（本人选择 <a href="http://www.lua.org/ftp/">lua-5.3.6</a>）</li>
</ul>
<span id="more"></span>

<h2 id="1-2-安装前的准备工作"><a href="#1-2-安装前的准备工作" class="headerlink" title="1.2 安装前的准备工作"></a>1.2 安装前的准备工作</h2><ul>
<li>将 TDM-GCC 的 bin 目录添加到环境变量</li>
<li>进入 TDM-GCC 的 bin 目录，将 <code>把 mingw32-make.exe</code> 复制一份并修改为改为 <code>make.exe</code>，如下图：<br><img src="../images/20210219211832365.png" alt="在这里插入图片描述"></li>
<li>验证 GCC 环境，输出如下<br><img src="../images/20210219212048248.png" alt="在这里插入图片描述"></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=C:/TDM-GCC-64/bin/../libexec/gcc/x86_64-w64-mingw32/9.2.0/lto-wrapper.exe</span><br><span class="line">Target: x86_64-w64-mingw32</span><br><span class="line">Configured with: ../../../src/gcc-git-9.2.0/configure --build=x86_64-w64-mingw32 --enable-targets=all --enable-languages=ada,c,c++,fortran,lto,objc,obj-c++ --enable-libgomp --enable-lto --enable-graphite --enable-cxx-flags=-DWINPTHREAD_STATIC --disable-build-with-cxx --disable-build-poststage1-with-cxx --enable-libstdcxx-debug --enable-threads=posix --enable-version-specific-runtime-libs --enable-fully-dynamic-string --enable-libstdcxx-threads --enable-libstdcxx-time --with-gnu-ld --disable-werror --disable-nls --disable-win32-registry --enable-large-address-aware --disable-rpath --disable-symvers --prefix=/mingw64tdm --with-local-prefix=/mingw64tdm --with-pkgversion=tdm64-1 --with-bugurl=http://tdm-gcc.tdragon.net/bugs</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 9.2.0 (tdm64-1)</span><br><span class="line"></span><br><span class="line">&gt;g++ -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=g++</span><br><span class="line">COLLECT_LTO_WRAPPER=C:/TDM-GCC-64/bin/../libexec/gcc/x86_64-w64-mingw32/9.2.0/lto-wrapper.exe</span><br><span class="line">Target: x86_64-w64-mingw32</span><br><span class="line">Configured with: ../../../src/gcc-git-9.2.0/configure --build=x86_64-w64-mingw32 --enable-targets=all --enable-languages=ada,c,c++,fortran,lto,objc,obj-c++ --enable-libgomp --enable-lto --enable-graphite --enable-cxx-flags=-DWINPTHREAD_STATIC --disable-build-with-cxx --disable-build-poststage1-with-cxx --enable-libstdcxx-debug --enable-threads=posix --enable-version-specific-runtime-libs --enable-fully-dynamic-string --enable-libstdcxx-threads --enable-libstdcxx-time --with-gnu-ld --disable-werror --disable-nls --disable-win32-registry --enable-large-address-aware --disable-rpath --disable-symvers --prefix=/mingw64tdm --with-local-prefix=/mingw64tdm --with-pkgversion=tdm64-1 --with-bugurl=http://tdm-gcc.tdragon.net/bugs</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 9.2.0 (tdm64-1)</span><br><span class="line"></span><br><span class="line">&gt;make -v</span><br><span class="line">GNU Make 3.82.90</span><br><span class="line">Built <span class="keyword">for</span> i686-pc-mingw32</span><br><span class="line">Copyright (C) 1988-2012 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br></pre></td></tr></table></figure>

<h1 id="二、编译"><a href="#二、编译" class="headerlink" title="二、编译"></a>二、编译</h1><ul>
<li><p>将下载的源代码解压</p>
</li>
<li><p>进入源代码根目录，也就是 <code>lua-5.3.6</code> 目录下</p>
</li>
<li><p>按住 <code>shift</code> 键的同时点击鼠标右键，选择 <code>在此处打开 PowerShell 窗口</code></p>
</li>
<li><p>输入 <code>make mingw</code><br><img src="../images/2021021921314179.png" alt="在这里插入图片描述"><br><img src="../images/20210219213212429.png" alt="在这里插入图片描述"></p>
</li>
<li><p>编译完成，生成的目标文件共有三个 <code>lua.exe</code>，<code>luac.exe</code>，<code>lua53.dll</code>，在 <code>src</code> 目录下<br><img src="../images/20210219213307215.png" alt="在这里插入图片描述"></p>
</li>
<li><p>可以直接将 <code>src</code> 添加到环境变量，或者将上述三个文件保存在某个目录，然后将这个目录添加到环境变量</p>
</li>
<li><p>验证，在命令行窗口输入 <code>lua</code>，或者输入 <code>lua -v</code><br><img src="../images/20210219213357495.png" alt="在这里插入图片描述"><br><img src="../images/20210219213454730.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h1><p>我们通过有关的环境变量配置即可自己手动编译一个自己的 Lua 环境，但是这里也有一个注意点，本人在 <code>TDM-GCC</code> 以及 <code>Mingw</code> 的 GCC 编译环境下编译出来的不需要再依赖其他的库，但是在 <code>cygwin64</code> 平台下编译的 Lua 解释器还需要依赖 <code>cygwin64</code> 的有关库（也就是说编译好的文件不能共享给其他人使用）</p>
<h1 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h1><ul>
<li>[1] Lua 官方文档</li>
<li>[2] <a href="https://github.com/joedf/LuaBuilds">https://github.com/joedf/LuaBuilds</a> </li>
</ul>
]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua编译</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL on和where的区别</title>
    <url>/archives/13ea1464.html</url>
    <content><![CDATA[<p>在多表查询时，ON和where都表示筛选条件，on先执行，where后执行。<br>区别：<br>外连接时，on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。而where条件是在临时表生成好后，再对临时表进行过滤的条件。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/archives/7273cdc.html</url>
    <content><![CDATA[<h1 id="Maven学习笔记"><a href="#Maven学习笔记" class="headerlink" title="Maven学习笔记"></a>Maven学习笔记</h1><h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p>服务于Java平台的自动化构建工具</p>
<span id="more"></span>

<h2 id="何为构建？"><a href="#何为构建？" class="headerlink" title="何为构建？"></a>何为构建？</h2><ul>
<li>编译</li>
<li>部署</li>
<li>搭建</li>
</ul>
<p>BS项目最终运行的是动态 Web 工程编译的结果，不是这个工程本身</p>
<p>构建过程的各个环节：</p>
<ol>
<li>清理：清理旧的字节码文件</li>
<li>编译：编译成字节码文件</li>
<li>测试：自动测试</li>
<li>报告：测试程序执行的结果</li>
<li>打包</li>
<li>安装：Maven的特定概念——将打包得到的文件复制到仓库中的指定位置</li>
<li>部署：部署工程到服务器</li>
</ol>
<h2 id="如何安装？"><a href="#如何安装？" class="headerlink" title="如何安装？"></a>如何安装？</h2><p>1、检测<code>JAVA_HOME</code>环境变量</p>
<p><img src="../images/image-20210604190837057.png" alt="image-20210604190837057"></p>
<p>2、解压Maven压缩包</p>
<ul>
<li>路径需要非中文、无空格</li>
</ul>
<p>3、配置Maven环境变量</p>
<ul>
<li>MAVNE_HOME或者M2_HOME</li>
</ul>
<p>4、查看</p>
<p><img src="../images/image-20210604191237178.png" alt="image-20210604191237178"></p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><ol>
<li>约定的目录结构</li>
<li>POM</li>
<li>坐标</li>
<li>依赖（最重要）</li>
<li>仓库</li>
<li>生命周期/插件/目标</li>
<li>继承</li>
<li>聚合</li>
</ol>
<h2 id="1、目录结构"><a href="#1、目录结构" class="headerlink" title="1、目录结构"></a>1、目录结构</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">|---src</span><br><span class="line">|	|---main 存放主程序</span><br><span class="line">|	|	|---java 存放Java源文件</span><br><span class="line">|	|	|---resources 存放框架或者其他工具的配置文件</span><br><span class="line">|	|---test 存放测试程序</span><br><span class="line">|   	|---java</span><br><span class="line">|		|---resources</span><br><span class="line">|---pom.xml 核心配置文件</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210604191940635.png" alt="image-20210604191940635"></p>
<p><strong>为什么要约定目录结构？</strong></p>
<p>约定大于配置</p>
<p>配置大于编码</p>
<blockquote>
<p>静态导入声明从类中导入静态成员，并允许它们在没有类引用的情况下使用。</p>
</blockquote>
<h2 id="2、常用命令"><a href="#2、常用命令" class="headerlink" title="2、常用命令"></a>2、常用命令</h2><p>必须进入 <code>pom.xml</code> 的所在目录执行命令</p>
<ul>
<li><p>mvn clean</p>
</li>
<li><p>mvn compile</p>
</li>
<li><p>mvn test-compile</p>
</li>
<li><p>mvn test</p>
</li>
<li><p>mvn package</p>
</li>
<li><p>mvn install：安装编译好的工程到Maven仓库</p>
</li>
<li><p>mvn site：生成站点</p>
</li>
</ul>
<p>编译结果在 <code>target</code> 目录</p>
<h2 id="3、POM"><a href="#3、POM" class="headerlink" title="3、POM"></a>3、POM</h2><p>Project Object Model：项目对象模型</p>
<blockquote>
<p>核心配置文件</p>
</blockquote>
<h2 id="4、坐标"><a href="#4、坐标" class="headerlink" title="4、坐标"></a>4、坐标</h2><p>可以使用三个坐标在仓库中唯一定位一个项目</p>
<ol>
<li>groupid：公司或组织域名倒叙+项目名</li>
<li>artifactid：模块名</li>
<li>version：版本</li>
</ol>
<h2 id="5、仓库"><a href="#5、仓库" class="headerlink" title="5、仓库"></a>5、仓库</h2><p><strong>分类：</strong></p>
<p>本地仓库</p>
<p>远程仓库</p>
<ul>
<li>私服：搭建在局域网里的，为局域网范围内的所有Maven工程服务</li>
<li>中央仓库</li>
<li>中央仓库的镜像</li>
</ul>
<p><strong>仓库的内容：</strong></p>
<ol>
<li>Maven自身需要的插件</li>
<li>第三方框架或者工具的jar包</li>
<li>我们自己开发的Maven工程（mvn install）</li>
</ol>
<blockquote>
<p>第一方：JDK</p>
<p>第二方：我们自己</p>
</blockquote>
<h2 id="6、依赖"><a href="#6、依赖" class="headerlink" title="6、依赖"></a>6、依赖</h2><p>Maven解析依赖的时候会到本地仓库找那些项目依赖的包</p>
<h3 id="依赖的范围："><a href="#依赖的范围：" class="headerlink" title="依赖的范围："></a><strong>依赖的范围</strong>：</h3><ul>
<li>compile：对主程序、测试程序都有效，参与打包</li>
<li>test：只对测试环境有效，不参与打包</li>
<li>provided：对主程序、测试程序都有效，不参与打包</li>
</ul>
<p><img src="../images/image-20210604200023747.png" alt="image-20210604200023747"></p>
<h3 id="依赖的传递性："><a href="#依赖的传递性：" class="headerlink" title="依赖的传递性："></a><strong>依赖的传递性：</strong></h3><p>直接依赖的依赖也会被传到本项目（也不一定都能进来，test 和 provided 不能进来）</p>
<p>好处：不需要在每个模块都声明依赖，可以从别的导入</p>
<h3 id="依赖的排除："><a href="#依赖的排除：" class="headerlink" title="依赖的排除："></a><strong>依赖的排除：</strong></h3><p>不想要的可以排除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="依赖的原则："><a href="#依赖的原则：" class="headerlink" title="依赖的原则："></a><strong>依赖的原则：</strong></h3><p>作用：解决模块工程之间依赖冲突问题</p>
<p><img src="../images/image-20210604211303681.png" alt="image-20210604211303681"></p>
<p>路径最短优先（选1.2.14）</p>
<p><img src="../images/image-20210604211457031.png" alt="image-20210604211457031"></p>
<p>如果路径相同（先声明的优先）</p>
<h3 id="统一管理依赖的版本："><a href="#统一管理依赖的版本：" class="headerlink" title="统一管理依赖的版本："></a><strong>统一管理依赖的版本：</strong></h3><p>手动一个个改太麻烦</p>
<p>建议方式：</p>
<ul>
<li>使用 <code>properties</code> 标签，标签内使用自定义标签统一声明版本号</li>
<li>在需要依赖版本的地方，使用 <code>$&#123;自定义标签名&#125;</code> 对版本号进行引用</li>
</ul>
<blockquote>
<p><code>properties</code> 标签，只要需要统一声明的场合，都可以自定义</p>
</blockquote>
<h3 id="依赖的继承"><a href="#依赖的继承" class="headerlink" title="依赖的继承"></a>依赖的继承</h3><p>在父工程中声明依赖，子工程就会继承父工程的依赖</p>
<p>1、创建一个Maven工程，打包的方式为 pom</p>
<p>2、在子工程中声明对父工程的引用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--父工程 坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>...<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>从当前目录到父项目的 pom.xml 文件的相对路径<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、在子工程中删除重复内容</p>
<p>4、只需在父工程中声明依赖版本</p>
<p>将父项目中的 dependencies 标签，用 dependencyManagement 标签括起来</p>
<blockquote>
<p>其实用IDEA，添加子模块也行</p>
</blockquote>
<h3 id="依赖的聚合"><a href="#依赖的聚合" class="headerlink" title="依赖的聚合"></a>依赖的聚合</h3><p>作用：一键安装各个模块工程</p>
<p>配置：把某个工程作为聚合工程，在总的聚合工程中 使用 modules /module 标签组合，指定模块工程的相对路径即可</p>
<p><img src="../images/image-20210606130230024.png" alt="image-20210606130230024"></p>
<p>使用：在聚合工程上使用 <code>mvn install</code></p>
<h2 id="7、生命周期"><a href="#7、生命周期" class="headerlink" title="7、生命周期"></a>7、生命周期</h2><ol>
<li>构建环节的顺序不能打乱</li>
<li>每一个生命周期都会从最初的阶段执行</li>
</ol>
<p><img src="../images/image-20210604200930229.png" alt="image-20210604200930229"></p>
<h1 id="Web工程的自动部署"><a href="#Web工程的自动部署" class="headerlink" title="Web工程的自动部署"></a>Web工程的自动部署</h1><p>使用 <code>build</code> 标签，里面进行配置，可以使用 cargo</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote>
<p>[1]<a href="https://www.bilibili.com/video/BV1TW411g7hP">https://www.bilibili.com/video/BV1TW411g7hP</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10环境下编译openjdk15</title>
    <url>/archives/66c016fb.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章写于2021年1月份。</p>
<p>我在Windows 和 Linux 平台上都试着编译过 openjdk，Linux 平台上的一般按照周大大的步骤来，不会有什么问题，不过还是给个建议：<strong>使用 Ubuntu18 最佳</strong>，因为这样你不需要手动更改 GCC 的版本（Ubuntu18 的 GCC 版本是 7.x，刚好和官方的要求符合），给自己省了点麻烦。当然，如果你是 Linux 使用高手，可以忽略我这一点建议。</p>
<span id="more"></span>

<p>在 Windows 平台的建议是：直接编译 openjdk15，原因如下：</p>
<ol>
<li>自身实践。我尝试编译了 openjdk8 到 openjdk15，只有 openjdk15 的编译不需要修改官方的脚本，openjdk13 ，12 都需要修改 <code>make\autoconf\toolchain_windows.m4</code>这个文件，具体可参考<a href="https://blog.csdn.net/weixin_45040801/article/details/102612042">这篇文章</a></li>
<li>不需要安装过多的依赖或者软件。只需要 vs2017 英文版（注意是英文版）和 cygwin64，具体原因看<a href="https://blog.csdn.net/weixin_45040801/article/details/102542213?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control">这篇文章</a>。很多博客会说需要 <code>freetype</code> 这个依赖，但是我在编译的时候并没有用过，在这里供大家参考。</li>
</ol>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="软件以及源代码"><a href="#软件以及源代码" class="headerlink" title="软件以及源代码"></a>软件以及源代码</h2><ul>
<li>openjdk14（下载解压即可，不需要配置环境变量）</li>
<li>openjdk15 源代码</li>
<li>vs2017 英文版</li>
<li>cygwin64</li>
</ul>
<p>具体下载地址我不再给出，请自行下载</p>
<h2 id="依赖包安装"><a href="#依赖包安装" class="headerlink" title="依赖包安装"></a>依赖包安装</h2><p>cygwin64 安装的时候选择即可，至少需要安装：</p>
<ul>
<li>autoconf</li>
<li>zip</li>
<li>unzip</li>
<li>make</li>
<li>tar</li>
</ul>
<p>其他的依赖可以参考源码下的 <code>doc/building.html</code> 文档</p>
<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><ol>
<li>可以把 cygwin64 加入环境变量，这样可以在 Windows 的 CMD 窗口直接使用 Linux 命令，不过要放在 <code>C:\WINDOWS\system32</code> 之前。如下图：<br><img src="../images/20210112110038781.png" alt="cygwin64 环境配置"></li>
<li>把自己电脑的语言设置成英文，这样你会少看到一些 warning，有强迫症的同志甚至可以把国家和地区改一下</li>
</ol>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>如果你在上文和我一下配置了 cygwin64 的环境变量，那你可以直接在源代码目录下这么干<br><img src="../images/20210112110722405.png" alt="在这里插入图片描述"><br>这样你就直接进入了命令行窗口</p>
<h2 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash ./configure --enable-debug --disable-warnings-as-errors --with-ucrt-dll-dir=<span class="string">&quot;/cygdrive/c/Program Files (x86)/Windows Kits/10/Redist/10.0.17763.0/ucrt/DLLs/x64&quot;</span> --with-boot-jdk=/cygdrive/d/Environment/Java/openjdk-14</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>–enable-debug 等价于 –with-debug-level=fastdebug，此外还有 release、slowdebug 两个参数，他们是编译级别，默认是 release（发布版）</li>
<li>–with-ucrt-dll-dir 是指定 DLL 目录，具体为：<code>&quot;/cygdrive/c/Program Files (x86)/Windows Kits/10/Redist/10.0.17763.0/ucrt/DLLs/x64&quot;</code>，这里是一个映射，<code>/cygdrive/c/Program Files (x86)</code> 就是 Windows 的 <code>C:\Program Files (x86)</code>目录，具体的目录是我们安装好 VS2017 之后产生的目录，版本号<code> 10.0.17763.0</code> 可能会有不同，大家自行修改成自己的</li>
<li>–with-boot-jdk 指定引导 jdk 的安装目录，改成自己的目录即可</li>
</ul>
<p>截图如下：<br><img src="../images/2021011211160042.png" alt="在这里插入图片描述"><br>如果一切良好，会看到类似于这样的：<br><img src="../images/20210112112147474.png" alt="在这里插入图片描述"><br>如果出现了其他问题，可以参考错误信息，结合官方文档以及合理度娘来解决问题。</p>
<h2 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h2><p>按需编译，或者 <code>make all</code>，编译时间在半个小时到一个小时之间</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>等于学习了《深入理解 Java 虚拟机》第一章，希望不要努力了两天的成果在硬盘里面吃灰。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li>  [1] <a href="https://blog.csdn.net/weixin_45040801/article/details/102542213?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control">https://blog.csdn.net/weixin_45040801/article/details/102542213?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control</a></li>
<li>  [2] <a href="https://blog.csdn.net/weixin_45040801/article/details/102612042">https://blog.csdn.net/weixin_45040801/article/details/102612042</a></li>
<li>  [3] <a href="https://www.cnblogs.com/zhoujun007/archive/2004/01/13/13406716.html">https://www.cnblogs.com/zhoujun007/archive/2004/01/13/13406716.html</a></li>
<li>  [4] 深入理解 Java 虚拟机（第三版）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
        <category>编译OpenJDK15</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate学习笔记</title>
    <url>/archives/9ec6fc96.html</url>
    <content><![CDATA[<h2 id="一、是什么？"><a href="#一、是什么？" class="headerlink" title="一、是什么？"></a>一、是什么？</h2><p>hibernate框架应用在javaee三层结构中 dao层框架</p>
<p>hibernate底层代码就是jdbc，hibernate对jdbc进行封装，使用hibernate好处，不需要写复杂jdbc代码了，<br>不需要写sql语句实现</p>
<p>开源的轻量级的框架</p>
<span id="more"></span>



<h2 id="ORM思想"><a href="#ORM思想" class="headerlink" title="ORM思想"></a>ORM思想</h2><p>orm：object relational mapping，对象关系映射<br>文字描述：<br>（1）让实体类和数据库表进行一一对应关系<br>让实体类首先和数据库表对应<br>让实体类属性 和 表里面字段对应<br>（2）不需要直接操作数据库表，而操作表对应实体类对象</p>
<p><img src="../images/clip_image002.jpg" alt="img"></p>
<p><img src="../images/clip_image002-1623322622876.jpg" alt="img"></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="搭建一个demo"><a href="#搭建一个demo" class="headerlink" title="搭建一个demo"></a>搭建一个demo</h3><h4 id="1、使用IDEA创建一个Maven工程"><a href="#1、使用IDEA创建一个Maven工程" class="headerlink" title="1、使用IDEA创建一个Maven工程"></a>1、使用IDEA创建一个Maven工程</h4><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>解决编译时资源文件不生效的问题：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认打包资源文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、写个实体类"><a href="#2、写个实体类" class="headerlink" title="2、写个实体类"></a>2、写个实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> uid;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> uid, String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、写实体类对应的配置文件"><a href="#3、写实体类对应的配置文件" class="headerlink" title="3、写实体类对应的配置文件"></a>3、写实体类对应的配置文件</h4><p>建议：在实体类所在包里面创建，<code>实体类名称.hbm.xml</code></p>
<p><img src="../images/image-20210610190546796.png" alt="image-20210610190546796"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  ~ Hibernate, Relational Persistence for Idiomatic Java</span></span><br><span class="line"><span class="comment">  ~</span></span><br><span class="line"><span class="comment">  ~ License: GNU Lesser General Public License (LGPL), version 2.1 or later.</span></span><br><span class="line"><span class="comment">  ~ See the lgpl.txt file in the root directory or &lt;http://www.gnu.org/licenses/lgpl-2.1.html&gt;.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;com.tcmyxc.dao&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置类名和表名的映射关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;User&quot;</span> <span class="attr">table</span>=<span class="string">&quot;t_user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置主键自增长--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置类属性和表结构中列名的对应关系，不填就一模一样--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4、创建hibernate的核心配置文件"><a href="#4、创建hibernate的核心配置文件" class="headerlink" title="4、创建hibernate的核心配置文件"></a>4、创建hibernate的核心配置文件</h4><p>名字是固定的：<code>hibernate.cfg.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  ~ Hibernate, Relational Persistence for Idiomatic Java</span></span><br><span class="line"><span class="comment">  ~</span></span><br><span class="line"><span class="comment">  ~ License: GNU Lesser General Public License (LGPL), version 2.1 or later.</span></span><br><span class="line"><span class="comment">  ~ See the lgpl.txt file in the root directory or &lt;http://www.gnu.org/licenses/lgpl-2.1.html&gt;.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-configuration</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Database connection settings --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.driver_class&quot;</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.url&quot;</span>&gt;</span>jdbc:mysql:///mytest?serverTimezone=UTC<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--可选配置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- JDBC connection pool (use the built-in) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.pool_size&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- SQL dialect --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL8Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 输出 sql 语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--sql 语句格式化--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;format_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自动创建表</span></span><br><span class="line"><span class="comment">            update: 没有则创建，有则更新</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hbm2ddl.auto&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;com/tcmyxc/dao/User.hbm.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h4><p>第一步 加载hibernate核心配置文件</p>
<p>第二步 创建SessionFactory对象</p>
<p>第三步 使用SessionFactory创建session对象</p>
<p>第四步 开启事务</p>
<p>第五步 写具体逻辑 crud操作</p>
<p>第六步 提交事务</p>
<p>第七步 关闭资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Configuration cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">    cfg.configure();</span><br><span class="line"></span><br><span class="line">    SessionFactory sessionFactory = cfg.buildSessionFactory();</span><br><span class="line">    Session session = sessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    Transaction transaction = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">&quot;xwx&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    session.save(user);</span><br><span class="line"></span><br><span class="line">    transaction.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hibernate核心api"><a href="#Hibernate核心api" class="headerlink" title="Hibernate核心api"></a>Hibernate核心api</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><p>找到名称hibernate.cfg.xml配置文件，创建对象，把配置文件放到对象里面（加载核心配置文件）</p>
<h4 id="SessionFactory"><a href="#SessionFactory" class="headerlink" title="SessionFactory"></a>SessionFactory</h4><p>1 使用configuration对象创建sessionFactory对象<br>（1）创建sessionfactory过程中做事情：</p>
<ul>
<li>根据核心配置文件中，有数据库配置，有映射文件部分，到数据库里面根据映射关系把表创建</li>
</ul>
<p>2 创建sessionFactory过程中，这个过程特别耗资源的<br>（1）在hibernate操作中，建议一个项目一般创建一个sessionFactory对象</p>
<p>3 具体实现<br>（1）写工具类，写静态代码块实现</p>
<ul>
<li>静态代码块在类加载时候执行，执行一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionFactoryUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Configuration cfg = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sessionFactory = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态代码块保证只被加载一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">        cfg.configure();</span><br><span class="line">        sessionFactory = cfg.buildSessionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SessionFactory <span class="title">getSessionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>1 session类似于jdbc中connection</p>
<p>2 调用session里面不同的方法实现crud操作<br>（1）添加 save方法<br>（2）修改 update方法<br>（3）删除 delete方法<br>（4）根据id查询 get方法</p>
<p>3 session对象单线程对象<br>（1）session对象不能共用，只能自己使用</p>
<h3 id="增删改查那些事"><a href="#增删改查那些事" class="headerlink" title="增删改查那些事"></a>增删改查那些事</h3><h4 id="Hibernate实体类编写规则"><a href="#Hibernate实体类编写规则" class="headerlink" title="Hibernate实体类编写规则"></a>Hibernate实体类编写规则</h4><p>1 实体类里面属性私有的</p>
<p>2 私有属性使用公开的set和get方法操作</p>
<p>3 要求实体类有属性作为唯一值（一般使用id值）</p>
<p>4 实体类属性建议不使用基本数据类型，使用基本数据类型对应的包装类<br>（1）八个基本数据类型对应的包装类</p>
<ul>
<li>int – Integer</li>
<li>char—Character、</li>
<li>其他的都是首字母大写 比如 double – Double<br>（2）比如 表示学生的分数，假如 int score;</li>
<li>比如学生得了0分 ，int score = 0;</li>
<li>如果表示学生没有参加考试，int score = 0;不能准确表示学生是否参加考试<ul>
<li>解决：使用包装类可以了， Integer score = 0，表示学生得了0分，表示学生没有参加考试，Integer score = null;</li>
</ul>
</li>
</ul>
<h4 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h4><p><img src="../images/clip_image002-1623324391800.jpg" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置主键自增长--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><p>根据 id 查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210610193221935.png" alt="image-20210610193221935"></p>
<h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line">user.setPassword(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">session.update(user);</span><br><span class="line">User user2 = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user2);</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210610193536590.png" alt="image-20210610193536590"></p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line"><span class="comment">// 测试删除操作</span></span><br><span class="line">session.delete(user);</span><br><span class="line">User user2 = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user2);</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210610193824545.png" alt="image-20210610193824545"></p>
<h2 id="其他的概念"><a href="#其他的概念" class="headerlink" title="其他的概念"></a>其他的概念</h2><h3 id="实体类对象状态"><a href="#实体类对象状态" class="headerlink" title="实体类对象状态"></a>实体类对象状态</h3><p>实体类状态有三种</p>
<p>（1）瞬时态：对象里面没有id值，对象与session没有关联</p>
<p><img src="../images/clip_image002-1623325203474.jpg" alt="img"></p>
<p>（2）持久态：对象里面有id值，对象与session关联</p>
<p><img src="../images/clip_image004.jpg" alt="img"></p>
<p>（3）托管态：对象有id值，对象与session没有关联</p>
<p><img src="../images/clip_image006.jpg" alt="img"></p>
<p>saveOrUpdate方法：实现添加、实现修改</p>
<p><img src="../images/clip_image002-1623325258642.jpg" alt="img"></p>
<p><img src="../images/clip_image004-1623325258643.jpg" alt="img"></p>
<p><img src="../images/clip_image006-1623325258643.jpg" alt="img"></p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>hibernate缓存特点：</p>
<p>第一类 hibernate的一级缓存</p>
<p>（1）hibernate的一级缓存默认打开的</p>
<p>（2）hibernate的一级缓存使用范围，是session范围，从session创建到session关闭范围</p>
<p>（3）hibernate的一级缓存中，存储数据必须 持久态数据</p>
<p>第二类 hibernate的二级缓存</p>
<p>（1）目前已经不使用了，替代技术 redis</p>
<p>（2）二级缓存默认不是打开的，需要配置</p>
<p>（3）二级缓存使用范围，是sessionFactory范围</p>
<p><img src="../images/clip_image002-1623325371492.jpg" alt="img"></p>
<h3 id="事务代码规范写法"><a href="#事务代码规范写法" class="headerlink" title="事务代码规范写法"></a>事务代码规范写法</h3><p>代码结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; 开启事务 提交事务&#125;</span><br><span class="line"><span class="keyword">catch</span>() &#123; 回滚事务&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123; 关闭&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTx</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    SessionFactory sessionFactory = <span class="keyword">null</span>;    </span><br><span class="line">    Session session = <span class="keyword">null</span>;    </span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;    </span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">        sessionFactory = HibernateUtils.getSessionFactory();        </span><br><span class="line">        session = sessionFactory.openSession();        </span><br><span class="line">        <span class="comment">//开启事务        </span></span><br><span class="line">        tx = session.beginTransaction();        </span><br><span class="line">        <span class="comment">//添加        </span></span><br><span class="line">        User user = <span class="keyword">new</span> User();        </span><br><span class="line">        user.setUsername(<span class="string">&quot;小马&quot;</span>);        </span><br><span class="line">        user.setPassword(<span class="string">&quot;250&quot;</span>);        </span><br><span class="line">        user.setAddress(<span class="string">&quot;美国&quot;</span>);        </span><br><span class="line">        session.save(user);        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;        </span><br><span class="line">        <span class="comment">//提交事务        </span></span><br><span class="line">        tx.commit();    </span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e) &#123;        </span><br><span class="line">    	e.printStackTrace();        </span><br><span class="line">        <span class="comment">//回滚事务        </span></span><br><span class="line">        tx.rollback();    </span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;        </span><br><span class="line">        <span class="comment">//关闭操作        </span></span><br><span class="line">        session.close();        </span><br><span class="line">        sessionFactory.close();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210610194600591.png" alt="image-20210610194600591"></p>
<h2 id="回顾表和表之间的关系"><a href="#回顾表和表之间的关系" class="headerlink" title="回顾表和表之间的关系"></a>回顾表和表之间的关系</h2><p>一对多：分类和商品关系，一个分类里面有多个商品，一个商品只能属于一个分类</p>
<p>多对多：订单和商品关系，一个订单里面有多个商品，一个商品属于多个订单</p>
<p>多对多建表：创建第三张表维护关系</p>
<p><img src="../images/clip_image002-1623910791593.jpg" alt="img"></p>
<h2 id="查询方式介绍"><a href="#查询方式介绍" class="headerlink" title="查询方式介绍"></a>查询方式介绍</h2><h3 id="对象导航查询"><a href="#对象导航查询" class="headerlink" title="对象导航查询"></a>对象导航查询</h3><p>（1）根据id查询某个客户，再查询这个客户里面所有的联系人</p>
<p><img src="../images/clip_image002-1623913387871.jpg" alt="img"></p>
<h3 id="OID查询"><a href="#OID查询" class="headerlink" title="OID查询"></a>OID查询</h3><p>（1）根据id查询某一条记录，返回对象</p>
<p><img src="../images/clip_image002-1623913455625.jpg" alt="img"></p>
<h3 id="HQL查询"><a href="#HQL查询" class="headerlink" title="HQL查询"></a>HQL查询</h3><p>HQL，即hibernate query language，hibernate提供一种查询语言，hql语言和普通sql很相似</p>
<p>区别：普通sql操作数据库表和字段，hql操作实体类和属性</p>
<p>常用的hql语句</p>
<p>（1）查询所有： from 实体类名称</p>
<p>（2）条件查询： from 实体类名称 where 属性名称=? </p>
<p>（3）排序查询： from 实体类名称 order by 实体类属性名称 asc/desc</p>
<p>使用hql查询操作时候，使用Query对象</p>
<p>（1）创建Query对象，写hql语句</p>
<p>（2）调用query对象里面的方法得到结果</p>
<h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><p><img src="../images/clip_image002-1623913606053.jpg" alt="img"></p>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p><img src="../images/clip_image002-1623913667053.jpg" alt="img"></p>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>在hql操作中，在语句里面不能写limit，hibernate的Query对象封装两个方法实现分页操作</p>
<p><img src="../images/clip_image002-1623913727409.jpg" alt="img"></p>
<h4 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h4><p> 投影查询：查询不是所有字段值，而是部分字段的值</p>
<p>投影查询hql语句写法：</p>
<p>（1）select 实体类属性名称1, 实体类属性名称2  from 实体类名称</p>
<p>（2）select 后面不能写 <code>* </code>，不支持的</p>
<p>具体实现：</p>
<p><img src="../images/clip_image002-1623914156308.jpg" alt="img"></p>
<h3 id="QBC查询"><a href="#QBC查询" class="headerlink" title="QBC查询"></a>QBC查询</h3><p>1、使用hql查询需要写hql语句实现，但是使用qbc时候，不需要写语句了，使用方法实现</p>
<p>2、使用qbc时候，操作实体类和属性</p>
<p>3、使用qbc，使用Criteria对象实现</p>
<h4 id="查询所有-1"><a href="#查询所有-1" class="headerlink" title="查询所有"></a>查询所有</h4><p><img src="../images/clip_image002-1623914241737.jpg" alt="img"></p>
<h4 id="条件查询-1"><a href="#条件查询-1" class="headerlink" title="条件查询"></a>条件查询</h4><p><img src="../images/clip_image002-1623914264974.jpg" alt="img"></p>
<h4 id="分页查询-1"><a href="#分页查询-1" class="headerlink" title="分页查询"></a>分页查询</h4><p><img src="../images/clip_image002-1623914337716.jpg" alt="img"></p>
<h4 id="统计查询"><a href="#统计查询" class="headerlink" title="统计查询"></a>统计查询</h4><p><img src="../images/clip_image002-1623914367144.jpg" alt="img"></p>
<h4 id="本地sql查询"><a href="#本地sql查询" class="headerlink" title="本地sql查询"></a>本地sql查询</h4><p>SQLQuery对象，使用普通sql实现查询</p>
<p>servlet调用service，service调用dao</p>
<p>（1）在dao里面对数据库crud操作<br>（2）在dao里面使用hibernate框架，使用hibernate框架时候，调用session里面的方法实现功能</p>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>迫切内连接</p>
<p>（1）迫切内连接和内连接底层实现一样的</p>
<p>（2）区别：使用内连接返回list中每部分是数组，迫切内连接返回list每部分是对象</p>
<p>（3）hql语句写法：from  Customer  c  inner  join  fetch  c.setLinkMan</p>
<h2 id="检索策略"><a href="#检索策略" class="headerlink" title="检索策略"></a>检索策略</h2><p>检索策略分为两类：</p>
<p>（1）立即查询：根据id查询，调用get方法，一调用get方法马上发送语句查询数据库</p>
<p>（2）延迟查询：根据id查询，还有load方法，调用load方法不会马上发送语句查询数据，只有得到对象里面的值时候才会发送语句查询数据库</p>
<p>延迟查询分成两类：</p>
<p>（1）类级别延迟：根据id查询返回实体类对象，调用load方法不会马上发送语句</p>
<p>（2）关联级别延迟：查询某个客户，再查询这个客户的所有联系人，查询客户的所有联系人的过程是否需要延迟，这个过程称为关联级别延迟</p>
<p>批量抓取</p>
<p>查询所有的客户，返回list集合，遍历list集合，得到每个客户，得到每个客户的所有联系人</p>
<p><img src="../images/clip_image002-1623914745666.jpg" alt="img"></p>
<p>在客户的映射文件中，set标签配置 batch-size值，值越大发送语句越少</p>
<p><img src="../images/clip_image002-1623914783979.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/archives/e255a10a.html</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><blockquote>
<p>  参考文献：</p>
<ul>
<li>  [1]王道计算机网络复习书</li>
<li>  [2]计算机网络（第五版）- 潘爱民等译</li>
</ul>
</blockquote>
<span id="more"></span>



<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h3 id="对称秘钥算法"><a href="#对称秘钥算法" class="headerlink" title="对称秘钥算法"></a>对称秘钥算法</h3><p><strong>使用相同的秘钥加解密</strong></p>
<p><img src="../images/image-20210112143721721.png" alt="image-20210112143721721"></p>
<h4 id="DES-数据加密标准"><a href="#DES-数据加密标准" class="headerlink" title="DES 数据加密标准"></a>DES 数据加密标准</h4><p>三重 DES</p>
<p>1、使用秘钥 1 执行 DES 加密</p>
<p>2、使用秘钥 2 解密</p>
<p>3、使用秘钥 1 加密</p>
<h4 id="AES-高级加密标准"><a href="#AES-高级加密标准" class="headerlink" title="AES 高级加密标准"></a>AES 高级加密标准</h4><h3 id="公开秘钥算法"><a href="#公开秘钥算法" class="headerlink" title="公开秘钥算法"></a>公开秘钥算法</h3><p>加密算法 E，解密算法 D</p>
<p>1、$\ D(E(P))=P$</p>
<p>2、从 E 很难推出 D</p>
<p>3、加密算法不可能被选择明文攻击破解</p>
<p>使用公钥加密信息，私钥解密信息 </p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>1、接收方可以验证发送方的身份</p>
<p>2、发送方不能说我没发过</p>
<p>3、接收方不可能伪造发送的信息</p>
<h4 id="对称秘钥签名"><a href="#对称秘钥签名" class="headerlink" title="对称秘钥签名"></a>对称秘钥签名</h4><p><strong>使用同一秘钥</strong></p>
<p>找一个权威机构，自己的私钥自己知道，机构也知道</p>
<p>发送消息：</p>
<p>1、Alice 使用私钥加密，并标识要发送给 Bob</p>
<p>2、机构看到消息，解密该消息，然后发给 Bob</p>
<p>3、Bob 接收消息</p>
<h4 id="公开秘钥签名"><a href="#公开秘钥签名" class="headerlink" title="公开秘钥签名"></a>公开秘钥签名</h4><p><img src="../images/image-20210112150440539.png" alt="image-20210112150440539"></p>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>认证中心 CA</p>
<p>证书：将一个公钥和一个实体绑定</p>
<h3 id="SSL-安全套接字层"><a href="#SSL-安全套接字层" class="headerlink" title="SSL 安全套接字层"></a>SSL 安全套接字层</h3><p>HTTPS 443端口</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><h4 id="C-S-模型"><a href="#C-S-模型" class="headerlink" title="C/S 模型"></a>C/S 模型</h4><p>服务器总是打开，总是处于接收请求的状态，如果收到请求，则解析请求，进行必要的处理，并将处理结果发送给客户端</p>
<p>特点：</p>
<ul>
<li>  客户机地位不均等，服务器可以通过用户权限控制管理客户机</li>
<li>  客户机不直接通信</li>
<li>  单个服务器支持的客户机有限</li>
</ul>
<h4 id="P2P-模型"><a href="#P2P-模型" class="headerlink" title="P2P 模型"></a>P2P 模型</h4><p>各节点既是客户端又是服务器，都可以上传下载，相互之间直接通信</p>
<p>优点：</p>
<ul>
<li>  减轻了服务器的压力</li>
<li>  消除对某个服务器的完全依赖，可以把任务放到多个节点上</li>
<li>  可直接共享文档</li>
<li>  拓展性好</li>
<li>  网络健壮性强</li>
</ul>
<p>缺点：</p>
<ul>
<li>  由于既获取服务也提供服务，内存占用较大，会影响整机速度</li>
</ul>
<h3 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h3><p>C/S 模型，协议运行在 UDP 之上，53 号端口</p>
<p>域名是层次结构，级别高的在右边</p>
<p>域名系统：联机分布式的数据库系统</p>
<p>四种 DNS 服务器：根（13个）、顶级、授权、本地</p>
<p>每台主机都必须在授权域名服务器登记</p>
<h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><p>两种方式：</p>
<ul>
<li>  递归查询（根 DNS 服务器是中继节点，压力大）</li>
<li>  递归和迭代相结合</li>
</ul>
<p>递归查询示意图：</p>
<p><img src="../images/image-20210112131956527.png" alt="image-20210112131956527"></p>
<p>递归和迭代结合：</p>
<p><img src="../images/image-20210112132617854.png" alt="image-20210112132617854"></p>
<p>主机向本地 DNS 服务器查询是递归，本地 DNS 向其他 DNS 查询是迭代</p>
<p>域名解析过程如下：</p>
<p>1、客户机发送 DNS 请求报文，以 UDP 数据报的形式发送到本地 DNS 服务器</p>
<p>2、本地 DNS 收到后，先查缓存，如果没有，自己扮演 DNS 客户，向根域名服务器发送解析请求</p>
<p>3、根 DNS 服务器收到后，判断一下属于哪个顶级域名服务器，将对应的 IP 地址发来，说，你去找他，他知道</p>
<p>4、本地 DNS 服务器向顶级域名服务器发送解析请求</p>
<p>5、顶级收到后，判断一下属于哪个授权域名服务器，将对应的 IP 地址发来，说，你去找他，他知道</p>
<p>6、本地向授权发送请解析请求</p>
<p>7、授权收到之后会将解析结果发回本地域名服务器</p>
<p>8、本地把查询结果存到缓存，并发给客户端</p>
<h3 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议 FTP"></a>文件传输协议 FTP</h3><p>21 端口，C/S 模型，使用 TCP，有两个并行的 TCP 连接，一个控制连接进程（21），一个数据连接进程（20）</p>
<p>客户端有传输请求的时候才会创建数据连接进程 </p>
<p>功能：</p>
<p>1、在不同种类操作系统之家传输文件（屏蔽了操作系统的细节）</p>
<p>2、通过用户权限控制管理用户行为</p>
<p>3、可以用匿名 FTP 方式提供公用文件的共享能力</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>80 端口、无状态</p>
<p>使用 TCP进行可靠的传输</p>
<p>输入 URL 之后发生的事情：</p>
<p>1、浏览器分析 URL ，然后请求域名解析获得 IP 地址</p>
<p>2、与服务器建立 TCP 连接，然后发送 HTTP 请求</p>
<p>3、服务器对浏览请求进行处理，通过 HTTP 响应返回信息给浏览器</p>
<p>4、关闭连接</p>
<p>5、浏览器渲染页面</p>
<p>HTTP/1.1 支持长连接，分两种：</p>
<p>1、非流水线。收到前一个的响应之后才能发请求</p>
<p>2、流水线。发现对象引用就发请求</p>
<h4 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h4><ul>
<li>  请求报文</li>
<li>  响应报文</li>
</ul>
<p>组成：开始行、首部行、实体主体</p>
<p>请求报文和响应报文仅开始行不同</p>
<ul>
<li>  开始行：有三个字段，请求行是请求的方法、URL 以及 HTTP 版本号；响应行是版本、状态码、短语</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>为运行在不同主机上的进程之间提供逻辑通信，屏蔽了低层网络核心的细节，让两个进程认为咱们两个是直接在通信</p>
<h3 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h3><p>让各种应用层的进程把要传输的数据通过端口号向下交付给传输层，以及让传输层（一般指另外一个主机）知道把要传输的数据通过端口号向上交付给应用层的有关进程。</p>
<p>其实就是一个标识作用，让应用层知道该把数据通过哪个端口给传输层，传输层根据这个端口号把数据给应用层的相关进程。</p>
<p>端口号有 16 位，所以最大是 65536 - 1 = 65535</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>实际上是一个通信端点，即 套接字 = (主机 IP 地址, 端口号)，它可以唯一标识一台主机的一个应用（进程）</p>
<p>通常用C/S架构</p>
<p>只允许交换无结构的字节流</p>
<h4 id="面向连接和无连接"><a href="#面向连接和无连接" class="headerlink" title="面向连接和无连接"></a>面向连接和无连接</h4><p>面向连接：就是要求通信双方在通信之前必须要建立连接，也就是 <code>建立连接 -&gt; 开始通信 -&gt; 通信结束，关闭连接</code></p>
<p>无连接：通信双方不需要事先建立连接，如果需要通信，直接将信息发送到网络，让该信息的传递在网上尽力而为地往目的地传送。</p>
<p>TCP</p>
<ul>
<li>  面向连接（传送数据前需要建立连接）</li>
<li>  全双工</li>
<li>  没有广播和组播</li>
<li>  用于可靠性更重要的场合，如 FTP，HTTP，Telnet远程登录</li>
</ul>
<p>UDP</p>
<ul>
<li>  无连接，不可靠</li>
<li>  收到 UDP 数据报之后不需要给出确认报文</li>
<li>  执行速度快，实时性好，如 DNS，RTP（实时传输协议）</li>
</ul>
<h3 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h3><h4 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h4><p><strong>优点：</strong></p>
<p>1、无需建立连接，不会引入建立连接的时延</p>
<p>2、无连接。不需要维护连接状态，一般可以支持更多的活动客户机</p>
<p>3、分组首部开销小。仅有 8B 的开销（TCP 有 20B）</p>
<p>4、可以更好地控制发送的数据和发送时间。没有拥塞控制，网络中的拥塞不会影响主机的发送效率。</p>
<p><strong>常用场景</strong></p>
<ul>
<li>  一次性传输较少数据的网络应用，如 DNS，SNMP</li>
<li>  多媒体应用（IP 电话，实时视频会议，流媒体等）</li>
</ul>
<p>不保证可靠交换，所以维护传输可靠性的工作需要用户在<strong>应用层</strong>完成</p>
<p>面向报文。发送方 UDP 对应用层传下来的报文，仅仅是添加一个首部就交给 IP 层，别的啥也不干</p>
<p><strong>首部格式</strong></p>
<p>UDP 数据报包括：UDP 首部和用户数据</p>
<p>首部有四个字段：源端口、目的端口、数据报长度（包含首部和数据）、校验和</p>
<h4 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h4><p>在不可靠的 IP 层之上实现的可靠的数据传输协议</p>
<p>解决的问题：传输的可靠、有序、无重复和不丢失问题</p>
<p><strong>特点</strong></p>
<p>1、面向连接的</p>
<p>2、一个 TCP 连接只能有两个端点，每条 TCP 连接只能是点对点的</p>
<p>3、提供可靠的交付，保证数据无差错、不丢失、不重复、有序</p>
<p>4、全双工通信。TCP 两端都有缓存，用来临时存放通信数据</p>
<ul>
<li>  发送缓存：发送应用程序传送给发送放 TCP要发送的数据、TCP 已发送但是未收到确认的数据</li>
<li>  接收缓存：按序到达但未被接收方应用程序读取的数据、不按序到达的数据</li>
</ul>
<p>5、面向字节的。</p>
<p><strong>首部格式</strong></p>
<p>一个 TCP 报文段分为 TCP 首部和 TCP 数据两部分，整个报文段被封装在 IP 数据报的数据部分</p>
<p>TCP 报文段用途：</p>
<ul>
<li>  运载数据</li>
<li>  建立连接</li>
<li>  释放连接</li>
<li>  应答</li>
</ul>
<p><strong>结构示意图</strong></p>
<p><img src="../images/6-19110Q62344I5.gif" alt="img"></p>
<p><img src="../images/image-20210128212948575.png" alt="image-20210128212948575"></p>
<blockquote>
<p>  图片来源：<a href="http://c.biancheng.net/view/6441.html">http://c.biancheng.net/view/6441.html</a></p>
<p>  <a href="https://blog.csdn.net/lqglqglqg/article/details/48850029">https://blog.csdn.net/lqglqglqg/article/details/48850029</a></p>
</blockquote>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>每个 TCP 连接都有三个阶段：建立连接、数据传送、连接释放</p>
<p>TCP 连接需要解决三个问题：</p>
<p>1、要使发送双方都知道对方的存在</p>
<p>2、要允许双方协议一些参数（如最大窗口值，是否使用窗口扩大选项，时间戳服务及服务质量）</p>
<p>3、能够对运输实体资源进行分配</p>
<p>TCP 连接的端口是套接字（IP 地址 + 端口）</p>
<p>每条 TCP 连接可以由通信两端的两个端点确定。</p>
<p>TCP 连接的建立采用 C/S 模式</p>
<p><img src="../images/d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpeg" alt="img"></p>
<p>服务端的资源是在第二次握手时分配的（容易遭到 SYN 泛红攻击）</p>
<p>客户端的资源是在第三次握手的时候建立的</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>当 FIN 段被另 一方确认后，这个方向上的连接就被关闭，不再发送任何数据。然而，另一个方向上或许还在继续着无限的数据流。当两个方向都关闭后，连接才算被彻底释放</p>
<p>为了避免两军对垒问题，需要使用计时器。如果在两倍于最大数据包生存期内，针对 FIN 的响应没有出现，那么 FIN 的发送端直接释放连接</p>
<p><img src="../images/48540923dd54564e5260495ce0006487d0584fb6.jpeg" alt="img"></p>
<p>TCP 有限状态机的状态：</p>
<p><img src="../images/image-20210128212137505.png" alt="image-20210128212137505"></p>
<h4 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h4><p>保证接收方进程从缓存区读出的字节流与发送方发出的字节流完全一致</p>
<p>使用的机制：校验、序号、确认、重传</p>
<p>1、序号</p>
<p>TCP 首部的序号字段保证数据能有序提交给应用层，序号值是本报文要发送的第一个字节的序号</p>
<p>2、确认</p>
<p>确认号是希望收到对方的下一个报文段的数据的第一个字节的序号。</p>
<p>3、重传</p>
<p>重传条件：超时和冗余 ACK</p>
<p>（1）超时</p>
<p>每发送一个报文段，就对这个报文设置一次计时器。如果计时器设置的重传时间到期但还没有收到确认，就必须重传。（RTT：报文往返一趟的时间）</p>
<p>（2）冗余确认</p>
<p>当收到三个 ACK 的时候，必须重传该报文。</p>
<p>比如，1、2、3、4、5，五个报文发出去，但是2号丢了。<strong>TCP 规定每当比期望序号大的失序报文到达时，就要发送一个冗余 ACK，指明期待收到的下一个报文序号。</strong>所以会发送3个1号报文的冗余ACK，必须重传。</p>
<h4 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h4><p>避免发送方发送的数据大于接收方缓存，从而导致数据丢失。</p>
<p>滑动窗口协议</p>
<p><img src="../images/image-20210128214226394.png" alt="image-20210128214226394"></p>
<blockquote>
<p>例如，假设接收端有一个 4096 字节的缓冲区，如图 6-40 所示。如果发送端传送了一个2048字节的数据段，并且该数据段已被正确地接收，那么接收方将确认该数据段；然而，由于接收端现在只剩下2048字节的缓冲区空间（在应用程序从缓存区取走数据之前），所以它将宣告下一个期望字节开始窗口为 2048。</p>
</blockquote>
<p>接收方根据自己接收缓存的大小，动态调整发送方的发送窗口大小，这是接收窗口 rwnd</p>
<p>发送方根据自己对当前网络拥塞程度估计而确定的窗口值，这是拥塞窗口 cwnd。</p>
<h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h4><p>防止过多的数据注入网络，保证网络中的路由器或者链路不至于过载。</p>
<p>4种算法：慢开始、拥塞避免、快重传、快恢复</p>
<p>1、慢开始算法</p>
<p>拥塞窗口指数级别增长，最开始是1，然后是2、4、8……</p>
<p>达到规定的慢开始阈值之后，改用拥塞避免算法</p>
<p>2、拥塞避免算法</p>
<p>每次增加1，线性增长</p>
<p>如果出现拥塞，把慢开始的阈值设置为发生拥塞时的发送方的 cwnd 的一半，然后把拥塞窗口设置成1，重新慢开始（这样做是为了迅速减少主机发送到网络中的分组数，使发生拥塞的路由器把积压的分组处理完）</p>
<p><img src="../images/image-20210128220140738.png" alt="image-20210128220140738"></p>
<p>3、快重传</p>
<p>收到三个冗余 ACK 就必须重传</p>
<p>4、快恢复（因为跳过了慢开始阶段）</p>
<p>收到三个冗余 ACK，把慢开始的阈值设置为发生拥塞时的发送方的 cwnd 的一半，然后把拥塞窗口设置成这个阈值，然后执行拥塞避免算法</p>
<p><img src="../images/image-20210128220441976.png" alt="image-20210128220441976"></p>
<p>在流量控制中，发送方发送数据的量由接收方决定，而在拥塞控制中，则由发送方自己通过检测网络状况来决定。</p>
<p>实际上，慢开始、拥塞避免、快重传和快恢复几种算法应是同时应用在拥塞控制机制之中的，当发送方检测到超时的时候，就采用慢开始和拥塞避免，当发送方按收到冗余 ACK 时,就采用快重传和快恢复。</p>
<p>发送方发送窗口的实际大小由流量控制和拥塞控制共同决定。因此，当同时出现接收端窗口（rwnd）和拥塞窗口(cwnd）时，发送方实际的发送窗口大小是由 rwnd 和 cwnd 中较小的那一个确定的。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/archives/364ea8cc.html</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h2><ul>
<li>  <strong>开闭原则</strong>：对修改封闭，对扩展开放。</li>
<li>  <strong>单一职责原则</strong>：一个类只做一件事，一个类应该只有一个引起它修改的原因。</li>
<li>  <strong>里氏替换原则</strong>：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。</li>
<li><strong>依赖倒置原则</strong>：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。<ul>
<li>  变量不可以持有具体类的引用</li>
<li>  不要让类派生自具体类</li>
<li>  不要覆盖基类中已实现的方法</li>
</ul>
</li>
<li>  <strong>迪米特法则</strong>：又名“最少知道原则”，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。</li>
<li>  <strong>接口隔离原则</strong>：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。</li>
</ul>
<span id="more"></span>

<p>接口：接口是一个概念，是超类型，比如抽象类和接口。这样我们声明的时候不需要管以后执行时的真实对象类型。</p>
<h2 id="Head-First-设计原则"><a href="#Head-First-设计原则" class="headerlink" title="Head First 设计原则"></a>Head First 设计原则</h2><ul>
<li>  找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起</li>
<li>  针对接口编程，而不是针对实现编程</li>
<li>  多用组合，少用继承</li>
<li>  l类应该对修改封闭，对扩展开放</li>
<li>  要依赖抽象，不要依赖具体类</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>创建型、结构型、行为型</p>
<h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a><strong>饿汉式</strong></h4><p>变量在声明时便初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a><strong>懒汉式</strong></h4><p>先声明一个空变量，需要用时才初始化。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单锁"><a href="#单锁" class="headerlink" title="单锁"></a><strong>单锁</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双锁"><a href="#双锁" class="headerlink" title="双锁"></a><strong>双锁</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM 底层为了优化程序运行效率，可能会对我们的代码进行指令重排序，在一些特殊情况下会导致出现空指针，为了防止这个问题，更进一步的优化是给 instance 变量加上 <strong>volatile</strong> 关键字。</p>
<p>问：双检锁单例模式中，volatile 主要用来防止哪几条指令重排序？如果发生了重排序，会导致什么样的错误？</p>
<p>答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure>

<p>这一行代码中，执行了三条重要的指令：</p>
<ul>
<li>  分配对象的内存空间</li>
<li>  初始化对象</li>
<li>  将变量 instance 指向刚分配的内存空间</li>
</ul>
<p>在这个过程中，如果第二条指令和第三条指令发生了重排序，可能导致 instance 还未初始化时，其他线程提前通过双检锁外层的 null 检查，获取到“不为 null，但还没有执行初始化”的 instance 对象，发生空指针异常。</p>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a><strong>内部类</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h3><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p>定义一个类，类里面有个 <code>create</code> 静态方法，根据传递的参数不同来创建不同的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">create</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;苹果&quot;</span>: <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;梨子&quot;</span>: <span class="keyword">return</span> <span class="keyword">new</span> Pear();</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;暂时没有这种水果&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><blockquote>
<p>  <strong>定义</strong>：工厂方法定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p>
<p>  让子类决定该创建什么样的对象，以此达到将对象的创建过程封装的目的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Fruit <span class="title">create</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">FruitFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Fruit <span class="title">create</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实，水果本身也是抽象的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="comment">// 一些代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用继承</p>
<p>工厂方法声明为抽象的，让子类去实现</p>
<h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><blockquote>
<p>  抽象工厂提供一个接口，用于创建相关或依赖对象的家族，而不需要指明具体的类</p>
</blockquote>
<p>抽象工厂的方法经常以工厂方法的方式实现。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><blockquote>
<p>  原型模式：<strong>复制现有的实例来创建新的实例</strong></p>
</blockquote>
<p>Java 里重写 clone 方法即可，或者反序列化</p>
<p>Java 自带的 clone 方法是浅拷贝的。就是说只有基本类型的参数会被拷贝一份，非基本类型的对象不会被拷贝一份，而是继续使用传递引用的方式。如果需要实现深拷贝，必须要自己手动修改 clone 方法才行。</p>
<p>优点：</p>
<ul>
<li>  客户不需要知道对象内部的复杂性</li>
<li>  部分时候，复制比创建一个新对象更优秀（但有时也很复杂）</li>
</ul>
<h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><blockquote>
<p>  适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
</blockquote>
<h3 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 Proxy"></a>代理模式 Proxy</h3><blockquote>
<p>  代理模式：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p>
</blockquote>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><blockquote>
<p>  不修改底层代码，赋予对象新的职责。</p>
</blockquote>
<p>特点：</p>
<ul>
<li>  装饰者和被装饰者有相同的超类型</li>
<li>  可以有多个装饰者</li>
<li>  装饰者可以有自己的行为</li>
<li>  对象可以在任何时候被装饰</li>
<li>  把被装饰的对象作为参数传递给装饰者</li>
</ul>
<p>实现：一般使用抽象类继承的方式，但是也可以用 Java 的接口</p>
<p>新建颜值接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBeauty</span> </span>&#123;    <span class="function"><span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<p>新建 Me 类，实现颜值接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Me</span> <span class="keyword">implements</span> <span class="title">IBeauty</span> </span>&#123;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> <span class="number">100</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>戒指装饰类，将 Me 包装起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RingDecorator</span> <span class="keyword">implements</span> <span class="title">IBeauty</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">final</span> IBeauty me;    <span class="function"><span class="keyword">public</span> <span class="title">RingDecorator</span><span class="params">(IBeauty me)</span> </span>&#123;        <span class="keyword">this</span>.me = me;    &#125;        <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> me.getBeautyValue() + <span class="number">20</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>客户端测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;        IBeauty me = <span class="keyword">new</span> Me();        System.out.println(<span class="string">&quot;我原本的颜值：&quot;</span> + me.getBeautyValue());        IBeauty meWithRing = <span class="keyword">new</span> RingDecorator(me);        System.out.println(<span class="string">&quot;戴上了戒指后，我的颜值：&quot;</span> + meWithRing.getBeautyValue());    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，输出如下：</p>
<p>我原本的颜值：100<br>戴上了戒指后，我的颜值：120<br>这就是最简单的增强功能的装饰模式。以后我们可以添加更多的装饰类，比如：</p>
<p>耳环装饰类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EarringDecorator</span> <span class="keyword">implements</span> <span class="title">IBeauty</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">final</span> IBeauty me;    <span class="function"><span class="keyword">public</span> <span class="title">EarringDecorator</span><span class="params">(IBeauty me)</span> </span>&#123;        <span class="keyword">this</span>.me = me;    &#125;        <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> me.getBeautyValue() + <span class="number">50</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>项链装饰类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NecklaceDecorator</span> <span class="keyword">implements</span> <span class="title">IBeauty</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">final</span> IBeauty me;    <span class="function"><span class="keyword">public</span> <span class="title">NecklaceDecorator</span><span class="params">(IBeauty me)</span> </span>&#123;        <span class="keyword">this</span>.me = me;    &#125;        <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeautyValue</span><span class="params">()</span> </span>&#123;        <span class="keyword">return</span> me.getBeautyValue() + <span class="number">80</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>客户端测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;        IBeauty me = <span class="keyword">new</span> Me();        System.out.println(<span class="string">&quot;我原本的颜值：&quot;</span> + me.getBeautyValue());    <span class="comment">// 随意挑选装饰    IBeauty meWithNecklace = new NecklaceDecorator(me);    System.out.println(&quot;戴上了项链后，我的颜值：&quot; + meWithNecklace.getBeautyValue());    // 多次装饰    IBeauty meWithManyDecorators = new NecklaceDecorator(new RingDecorator(new EarringDecorator(me)));    System.out.println(&quot;戴上耳环、戒指、项链后，我的颜值：&quot; + meWithManyDecorators.getBeautyValue());    // 任意搭配装饰    IBeauty meWithNecklaceAndRing = new NecklaceDecorator(new RingDecorator(me));    System.out.println(&quot;戴上戒指、项链后，我的颜值：&quot; + meWithNecklaceAndRing.getBeautyValue());&#125;</span></span><br></pre></td></tr></table></figure>

<p>}<br>运行程序，输出如下：</p>
<p>我原本的颜值：100<br>戴上了项链后，我的颜值：180<br>戴上耳环、戒指、项链后，我的颜值：250<br>戴上戒指、项链后，我的颜值：200</p>
<blockquote>
<p>  作者：力扣 (LeetCode)<br>  链接：<a href="https://leetcode-cn.com/leetbook/read/design-patterns/99j7re/">https://leetcode-cn.com/leetbook/read/design-patterns/99j7re/</a><br>  来源：力扣（LeetCode）</p>
</blockquote>
<h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote>
<p>  策略模式（Strategy Pattern）：定义了一系列算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p>
</blockquote>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><blockquote>
<p>  模板方法模式（Template Method Pattern）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Dropwizard学习笔记</title>
    <url>/archives/8125fdfd.html</url>
    <content><![CDATA[<h1 id="Dropwizard是什么？"><a href="#Dropwizard是什么？" class="headerlink" title="Dropwizard是什么？"></a>Dropwizard是什么？</h1><p>一个用于开发操作友好、高性能、RESTful Web 服务的 <strong>Java 框架</strong></p>
<blockquote>
<p>Dropwizard 将Java 生态系统中稳定、成熟的库整合到一个 简单、轻量级的包中，让您可以专注于完成工作。</p>
<p>Dropwizard对复杂的配置、 应用程序指标、日志记录、操作工具等提供开箱即用的支持，使您和您的团队能够在尽可能短的时间内提供生产质量的Web 服务。</p>
</blockquote>
<p>官网：<a href="https://www.dropwizard.io/en/latest/">https://www.dropwizard.io/en/latest/</a></p>
<span id="more"></span>



<h2 id="几个重要的组件"><a href="#几个重要的组件" class="headerlink" title="几个重要的组件"></a>几个重要的组件</h2><h3 id="Jetty-for-HTTP"><a href="#Jetty-for-HTTP" class="headerlink" title="Jetty for HTTP"></a>Jetty for HTTP</h3><p>使用Jetty HTTP 库将一个经过优化的 HTTP 服务器直接嵌入到项目中</p>
<h3 id="Jersey-for-REST"><a href="#Jersey-for-REST" class="headerlink" title="Jersey for REST"></a>Jersey for REST</h3><p>将 HTTP 请求映射到简单的 Java 对象。</p>
<p>支持流输出、矩阵 URI 参数、条件GET请求等等</p>
<h3 id="Jackson-for-JSON"><a href="#Jackson-for-JSON" class="headerlink" title="Jackson for JSON"></a>Jackson for JSON</h3><h3 id="Metrics-for-metrics"><a href="#Metrics-for-metrics" class="headerlink" title="Metrics for metrics"></a>Metrics for metrics</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>日志：<a href="https://logback.qos.ch/">Logback</a>和<a href="https://www.slf4j.org/">slf4j</a></p>
<p><a href="http://hibernate.org/validator/">Hibernate Validator</a></p>
<p>等等</p>
<h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><h2 id="1、使用Maven生成项目"><a href="#1、使用Maven生成项目" class="headerlink" title="1、使用Maven生成项目"></a>1、使用Maven生成项目</h2><h2 id="2、基本的依赖"><a href="#2、基本的依赖" class="headerlink" title="2、基本的依赖"></a>2、基本的依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dropwizard.version</span>&gt;</span>2.0.22<span class="tag">&lt;/<span class="name">dropwizard.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql-connector.version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">mysql-connector.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.dropwizard/dropwizard-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.dropwizard<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dropwizard-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dropwizard.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- mysql --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3、创建配置类"><a href="#3、创建配置类" class="headerlink" title="3、创建配置类"></a>3、创建配置类</h2><p>每个 Dropwizard 应用程序都有自己的<code>Configuration</code>类，用于指定特定于环境的参数。这些参数在YAML配置文件中指定，该文件会被加载，然后被反序列化为应用程序配置类的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloConfiguration</span> <span class="keyword">extends</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String defaultName = <span class="string">&quot;Stranger&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTemplate</span><span class="params">(String template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDefaultName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defaultName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultName = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个类会从 YAML 文件中反序列化，会去找两个跟级字段：<code>template</code>以及<code>defaultName</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">template:</span> <span class="string">Hello,</span> <span class="string">%s!</span> <span class="comment"># %s 是占位符，这里相当于一个模板字符串</span></span><br><span class="line"><span class="attr">defaultName:</span> <span class="string">Stranger</span></span><br></pre></td></tr></table></figure>

<p>这个文件要放在项目根目录下面</p>
<h2 id="4、创建一个Application类"><a href="#4、创建一个Application类" class="headerlink" title="4、创建一个Application类"></a>4、创建一个Application类</h2><p>必须要重写 <code>run</code> 方法（这个方法是抽象方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApplication</span> <span class="keyword">extends</span> <span class="title">Application</span>&lt;<span class="title">HelloConfiguration</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HelloWorldApplication().run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Bootstrap&lt;HelloConfiguration&gt; bootstrap)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(HelloConfiguration helloConfiguration, Environment environment)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、创建DAO类（pojo"><a href="#5、创建DAO类（pojo" class="headerlink" title="5、创建DAO类（pojo)"></a>5、创建DAO类（pojo)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Saying</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Saying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Saying</span><span class="params">(<span class="keyword">long</span> id, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6、创建Resource类"><a href="#6、创建Resource类" class="headerlink" title="6、创建Resource类"></a>6、创建Resource类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Path(&quot;/get&quot;)</span></span><br><span class="line"><span class="meta">@Produces(MediaType.APPLICATION_JSON)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String tempalte;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String defaultName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloResource</span><span class="params">(String tempalte, String defaultName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tempalte = tempalte;</span><br><span class="line">        <span class="keyword">this</span>.defaultName = defaultName;</span><br><span class="line">        <span class="keyword">this</span>.counter = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Saying <span class="title">sayHello</span><span class="params">(<span class="meta">@QueryParam(&quot;name&quot;)</span>Optional&lt;String&gt; name)</span></span>&#123;</span><br><span class="line">        String value = String.format(tempalte, name.orElse(defaultName));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Saying(counter.incrementAndGet(), value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、注册Resource类使其生效"><a href="#7、注册Resource类使其生效" class="headerlink" title="7、注册Resource类使其生效"></a>7、注册Resource类使其生效</h2><p>在Application类中注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelloWorldApplication</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(HelloConfiguration configuration, Environment env)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// new 一个对象</span></span><br><span class="line">    HelloResource helloResource = <span class="keyword">new</span> HelloResource(configuration.getTemplate(), configuration.getDefaultName());</span><br><span class="line">    <span class="comment">// 注册到应用程序的 Jersey 环境</span></span><br><span class="line">    env.jersey().register(helloResource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8、启动"><a href="#8、启动" class="headerlink" title="8、启动"></a>8、启动</h2><p>命令行启动：</p>
<p>命令行启动的话需要把配置文件放在<strong>子工程</strong>的根目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入子工程根目录</span></span><br><span class="line">java -jar target/01-HelloWorld-1.0-SNAPSHOT.jar server hello.yml</span><br></pre></td></tr></table></figure>



<p>IDEA启动：</p>
<p>需要把配置文件放在<strong>父工程</strong>的根目录</p>
<p><img src="../images/image-20210619134441719.png" alt="image-20210619134441719"></p>
<p>也可以在命令中指定配置文件路径</p>
<p><img src="../images/image-20210619134554883.png" alt="image-20210619134554883"></p>
<h2 id="9、测试"><a href="#9、测试" class="headerlink" title="9、测试"></a>9、测试</h2><p><img src="../images/image-20210619134648237.png" alt="image-20210619134648237"></p>
<h1 id="Dropwizard-Core"><a href="#Dropwizard-Core" class="headerlink" title="Dropwizard Core"></a>Dropwizard Core</h1><h2 id="提供了什么？"><a href="#提供了什么？" class="headerlink" title="提供了什么？"></a>提供了什么？</h2><ul>
<li>Jetty，一个高性能的 HTTP 服务器。</li>
<li>Jersey，一个功能齐全的 RESTful Web 框架。</li>
<li>Jackson，JVM 的最佳 JSON 库。</li>
<li>Metrics，一个优秀的应用程序度量库。</li>
<li>Logback，Log4j 的继承者，Java 使用最广泛的日志框架。</li>
<li>Hibernate Validator，Java Bean 验证标准的参考实现。</li>
</ul>
<p>官方建议把项目分成三个模块：<code>project-api</code>，<code>project-client</code>，和 <code>project-application</code>。</p>
<p>api：简单的Java bean</p>
<p>client：处理HTTP请求</p>
<p>application：应用类</p>
<h2 id="日志功能"><a href="#日志功能" class="headerlink" title="日志功能"></a>日志功能</h2><p>Dropwizard 使用<a href="http://logback.qos.ch/">Logback</a>作为其日志记录后端。它提供了一个<a href="http://www.slf4j.org/">slf4j</a>实现</p>
<p>slf4j 提供以下日志级别：</p>
<ul>
<li><code>ERROR</code>：可能仍允许应用程序继续运行的错误事件。</li>
<li><code>WARN</code>：可能有害的情况。</li>
<li><code>INFO</code>：在粗粒度级别突出显示应用程序进度的信息性消息。</li>
<li><code>DEBUG</code>：对调试应用程序最有用的细粒度信息事件。</li>
<li><code>TRACE</code>：比<code>DEBUG</code>级别更细粒度的信息事件。</li>
</ul>
<p>如果不想使用可以排除，具体参考：<a href="https://www.dropwizard.io/en/latest/manual/core.html">https://www.dropwizard.io/en/latest/manual/core.html</a></p>
<p>日志保存到文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">appenders:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">file</span></span><br><span class="line">      <span class="comment"># The file to which current statements will be logged.</span></span><br><span class="line">      <span class="attr">currentLogFilename:</span> <span class="string">./logs/example.log</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># When the log file rotates, the archived log will be renamed to this and gzipped. The</span></span><br><span class="line">      <span class="comment"># %d is replaced with the previous day (yyyy-MM-dd). Custom rolling windows can be created</span></span><br><span class="line">      <span class="comment"># by passing a SimpleDateFormat-compatible format as an argument: &quot;%d&#123;yyyy-MM-dd-hh&#125;&quot;.</span></span><br><span class="line">      <span class="attr">archivedLogFilenamePattern:</span> <span class="string">./logs/example-%d.log.gz</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># The number of archived files to keep.</span></span><br><span class="line">      <span class="attr">archivedFileCount:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># The timezone used to format dates. HINT: USE THE DEFAULT, UTC.</span></span><br><span class="line">      <span class="attr">timeZone:</span> <span class="string">UTC</span></span><br></pre></td></tr></table></figure>



<h2 id="Jersey"><a href="#Jersey" class="headerlink" title="Jersey"></a>Jersey</h2><p>一个框架，用于将传入 HTTP 请求的各个方面映射到 POJO，然后将 POJO 的各个方面映射到传出 HTTP 响应。</p>
<h2 id="Servlet-过滤器"><a href="#Servlet-过滤器" class="headerlink" title="Servlet 过滤器"></a>Servlet 过滤器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateNotSpecifiedServletFilter</span> <span class="keyword">implements</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Other methods in interface omitted for brevity</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequest) &#123;</span><br><span class="line">            String dateHeader = ((HttpServletRequest) request).getHeader(HttpHeaders.DATE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dateHeader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                chain.doFilter(request, response); <span class="comment">// This signals that the request should pass this filter</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">                httpResponse.setStatus(HttpStatus.BAD_REQUEST_400);</span><br><span class="line">                httpResponse.getWriter().print(<span class="string">&quot;Date Header was not specified&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将这个 servlet 过滤器包装在自己的 Application 类中<code>FilterHolder</code>并将其添加到应用程序上下文中，并与此过滤器将激活哪些路径的规范一起注册到您的 Application 类中。下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">environment.servlets()</span><br><span class="line">    .addFilter(<span class="string">&quot;DateNotSpecifiedServletFilter&quot;</span>, </span><br><span class="line">               <span class="keyword">new</span> DateNotSpecifiedServletFilter()).addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), <span class="keyword">true</span>, <span class="string">&quot;/*&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ol>
<li>Dropwizard 的所有 API 的设计都考虑到了可测试性，即使应用程序也可以进行单元测试</li>
<li>可以自定义 banner，放在<code>src/main/resources</code>目录下即可</li>
<li>每个资源类都必须有一个<code>@Path</code>注解</li>
<li><code>@Timed</code> 测量对资源请求的持续时间（不能和 <code>@Metered</code> 同时使用</li>
<li><code>@Metered</code> 衡量资源被访问的速率</li>
<li><code>@ResponseMetered</code> 测量每类响应代码的速率（1xx/2xx/3xx/4xx/5xx）</li>
<li><code>@ExceptionMetered</code> 测量处理资源的异常发生的频率</li>
<li>JSON 的一个常见问题是<code>camelCase</code>和<code>snake_case</code>字段名称之间的分歧。Java 和 Javascript 的人往往喜欢<code>camelCase</code>；Ruby、Python 和 Perl 的人坚持使用 <code>snake_case</code>. 要使 Dropwizard 自动将字段名称转换为<code>snake_case</code>（并返回），只需在类上面加注解<code>@JsonSnakeCase</code></li>
<li>返回大量信息，使用流式输出可能会大大提高性能和效率。通过返回一个实现 Jersey<code>StreamingOutput</code> 接口的对象，您的方法可以在块编码的输出流中流式传输响应实体</li>
</ol>
<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>依赖注入机制的底层库是 Eclipse 的<a href="https://github.com/eclipse-ee4j/glassfish-hk2">HK2</a>，推荐 Spring</p>
<h1 id="JDBI"><a href="#JDBI" class="headerlink" title="JDBI"></a>JDBI</h1><p>JDBI是Java的SQL连接处理的便利工具库。它试图以Java中使用集合，bean等来映射关系来访问关系数据库，同时保持与JDBC相同的粒度</p>
<p>要创建<a href="https://www.dropwizard.io/en/latest/manual/core.html#man-core-managed">托管的</a>检测<code>Jdbi</code>实例， <a href="https://www.dropwizard.io/en/latest/manual/core.html#man-core-configuration">配置类</a>需要一个<code>DataSourceFactory</code>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConfiguration</span> <span class="keyword">extends</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> DataSourceFactory database = <span class="keyword">new</span> DataSourceFactory();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;database&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceFactory</span><span class="params">(DataSourceFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.database = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;database&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceFactory <span class="title">getDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> database;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在Application类的<code>run</code>方法中，创建一个新的<code>JdbiFactory</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ExampleConfiguration config, Environment environment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> JdbiFactory factory = <span class="keyword">new</span> JdbiFactory();</span><br><span class="line">    <span class="keyword">final</span> Jdbi jdbi = factory.build(environment, config.getDataSourceFactory(), <span class="string">&quot;postgresql&quot;</span>);</span><br><span class="line">    environment.jersey().register(<span class="keyword">new</span> UserResource(jdbi));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将创建一个到数据库的新<a href="https://www.dropwizard.io/en/latest/manual/core.html#man-core-managed">托管</a>连接池、一个用于连接到数据库的 <a href="https://www.dropwizard.io/en/latest/manual/core.html#man-core-healthchecks">运行状况检查</a>以及一个<code>Jdbi</code> 供您使用的新实例。</p>
<p>配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">database:</span></span><br><span class="line">  <span class="comment"># the name of your JDBC driver</span></span><br><span class="line">  <span class="attr">driverClass:</span> <span class="string">org.postgresql.Driver</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the username</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">pg-user</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the password</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">iAMs00perSecrEET</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the JDBC URL</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">jdbc:postgresql://db.example.com/db-prod</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># any properties specific to your JDBC driver:</span></span><br><span class="line">  <span class="attr">properties:</span></span><br><span class="line">    <span class="attr">charSet:</span> <span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the maximum amount of time to wait on an empty pool before throwing an exception</span></span><br><span class="line">  <span class="attr">maxWaitForConnection:</span> <span class="string">1s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the SQL query to run when validating a connection&#x27;s liveness</span></span><br><span class="line">  <span class="attr">validationQuery:</span> <span class="string">&quot;/* MyService Health Check */ SELECT 1&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the timeout before a connection validation queries fail</span></span><br><span class="line">  <span class="attr">validationQueryTimeout:</span> <span class="string">3s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the minimum number of connections to keep open</span></span><br><span class="line">  <span class="attr">minSize:</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the maximum number of connections to keep open</span></span><br><span class="line">  <span class="attr">maxSize:</span> <span class="number">32</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># whether or not idle connections should be validated</span></span><br><span class="line">  <span class="attr">checkConnectionWhileIdle:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the amount of time to sleep between runs of the idle connection validation, abandoned cleaner and idle pool resizing</span></span><br><span class="line">  <span class="attr">evictionInterval:</span> <span class="string">10s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the minimum amount of time an connection must sit idle in the pool before it is eligible for eviction</span></span><br><span class="line">  <span class="attr">minIdleTime:</span> <span class="number">1</span> <span class="string">minute</span></span><br></pre></td></tr></table></figure>



<p>建议使用 JDBI 的<a href="http://jdbi.org/#_sql_objects">SQL Objects API</a>，它允许将 DAO 类编写为接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDAO</span> </span>&#123;</span><br><span class="line">  <span class="meta">@SqlUpdate(&quot;create table something (id int primary key, name varchar(100))&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">createSomethingTable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SqlUpdate(&quot;insert into something (id, name) values (:id, :name)&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="meta">@Bind(&quot;id&quot;)</span> <span class="keyword">int</span> id, <span class="meta">@Bind(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SqlQuery(&quot;select name from something where id = :id&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">findNameById</span><span class="params">(<span class="meta">@Bind(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MyDAO dao = database.onDemand(MyDAO.class);</span><br></pre></td></tr></table></figure>

<h1 id="Dropwizard-Hibernate"><a href="#Dropwizard-Hibernate" class="headerlink" title="Dropwizard Hibernate"></a>Dropwizard Hibernate</h1><h2 id="1、需要一个DataSourceFactory-实例"><a href="#1、需要一个DataSourceFactory-实例" class="headerlink" title="1、需要一个DataSourceFactory 实例"></a>1、需要一个<code>DataSourceFactory</code> 实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hibernate 配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateConfiguration</span> <span class="keyword">extends</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> DataSourceFactory database = <span class="keyword">new</span> DataSourceFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从配置文件中解析 database</span></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;database&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceFactory <span class="title">getDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> database;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;database&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceFactory</span><span class="params">(DataSourceFactory dataSourceFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.database = dataSourceFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、在应用类中注册这个实例"><a href="#2、在应用类中注册这个实例" class="headerlink" title="2、在应用类中注册这个实例"></a>2、在应用类中注册这个实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateApplication</span> <span class="keyword">extends</span> <span class="title">Application</span>&lt;<span class="title">HibernateConfiguration</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须实现 main 方法，声明这是个主类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HibernateApplication().run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个 hibernate 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HibernateBundle&lt;HibernateConfiguration&gt; hibernate = <span class="keyword">new</span> HibernateBundle&lt;HibernateConfiguration&gt;(Person.class) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DataSourceFactory <span class="title">getDataSourceFactory</span><span class="params">(HibernateConfiguration configuration)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> configuration.getDataSourceFactory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Bootstrap&lt;HibernateConfiguration&gt; bootstrap)</span> </span>&#123;</span><br><span class="line">        bootstrap.addBundle(hibernate);<span class="comment">// 在初始化加载器里注册 hibernate</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(HibernateConfiguration hibernateConfiguration, Environment environment)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在上下文环境中注册 resource 和 dao</span></span><br><span class="line">        <span class="keyword">final</span> PersonDAO dao = <span class="keyword">new</span> PersonDAO(hibernate.getSessionFactory());</span><br><span class="line">        environment.jersey().register(<span class="keyword">new</span> PersonResource(dao));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实体类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;person&quot;)</span></span><br><span class="line"><span class="meta">@NamedQueries(&#123;</span></span><br><span class="line"><span class="meta">        @NamedQuery(name = &quot;dao.Person.findAll&quot;, query = &quot;select p from Person p&quot;),</span></span><br><span class="line"><span class="meta">        @NamedQuery(name = &quot;dao.Person.findById&quot;, query = &quot;select p from Person p where p.id = ?1&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实体类对应的 DAO类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDAO</span> <span class="keyword">extends</span> <span class="title">AbstractDAO</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonDAO</span><span class="params">(SessionFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 id 查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">findById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">create</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> persist(person).getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找全部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list((CriteriaQuery&lt;Person&gt;) namedQuery(<span class="string">&quot;dao.Person.findAll&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>AbstractDAO</code>：一个用于特定于实体的 DAO 类的最小模板。它包含用于<code>SessionFactory</code>的常见操作的类型安全包装器</p>
<p>配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">database:</span></span><br><span class="line">  <span class="comment"># the name of the JDBC driver, mysql in our case</span></span><br><span class="line">  <span class="attr">driverClass:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="comment"># the username</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">  <span class="comment"># the password</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="comment"># the JDBC URL; the database is called DWGettingStarted</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/dropwizard?serverTimezone=CST</span></span><br><span class="line">  <span class="comment"># Hibernate properties</span></span><br><span class="line">  <span class="attr">properties:</span></span><br><span class="line">    <span class="attr">hibernate.dialect:</span> <span class="string">org.hibernate.dialect.MySQL5Dialect</span></span><br><span class="line">    <span class="attr">hibernate.hbm2ddl.auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">hibernate.format_sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">hibernate.show_sql:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="comment"># The default level of all loggers. Can be OFF, ERROR, WARN, INFO, DEBUG, TRACE, or ALL.</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">INFO</span></span><br></pre></td></tr></table></figure>

<h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><p>实现 resource 类，在应用类中配置 resource 类（上面配置过了），然后启动服务，打开浏览器在浏览器中请求（先启动应用，会自动生成表，然后插一条数据再请求）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Path(value = &quot;/person&quot;)</span></span><br><span class="line"><span class="meta">@Produces(MediaType.APPLICATION_JSON)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonDAO dao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonResource</span><span class="params">(PersonDAO dao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dao = dao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="meta">@Path(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Timed</span></span><br><span class="line">    <span class="meta">@UnitOfWork</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">findPerson</span><span class="params">(<span class="meta">@PathParam(&quot;id&quot;)</span> LongParam id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao.findById(id.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210630235119575.png" alt="image-20210630235119575"></p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="../images/image-20210701152901517.png" alt="image-20210701152901517"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Dropwizard</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Dropwizard</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA学习笔记</title>
    <url>/archives/4ac63db6.html</url>
    <content><![CDATA[<h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p>JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体<a href="https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96/7316192">对象持久化</a>到数据库中。 </p>
<span id="more"></span>

<p>Sun引入新的JPA ORM规范出于两个原因：其一，简化现有Java EE和Java SE应用开发工作；其二，Sun希望整合ORM技术，实现天下归一。</p>
<p>JPA包括以下3方面的技术：</p>
<p><strong>ORM映射元数据</strong></p>
<p>JPA支持XML和<a href="https://baike.baidu.com/item/JDK">JDK</a>5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体<a href="https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96">对象持久化</a>到数据库表中；</p>
<p><strong>API</strong></p>
<p>用来操作实体对象，执行CRUD操作，框架在后台替代我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。</p>
<p><strong>查询语言</strong></p>
<p>这是持久化操作中很重要的一个方面，通过<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。</p>
<p>JPA是需要Provider来实现其功能的，Hibernate就是JPA Provider中很强的一个，应该说无人能出其右。从功能上来说，JPA就是Hibernate功能的一个子集。</p>
<blockquote>
<p>JPA 是规范</p>
</blockquote>
<h2 id="2、HelloWorld"><a href="#2、HelloWorld" class="headerlink" title="2、HelloWorld"></a>2、HelloWorld</h2><p>（1）创建 persistence.xml, 在这个文件中配置持久化单元</p>
<p>JPA 规范要求在类路径的 META-INF 目录下放置persistence.xml</p>
<ul>
<li><p>需要指定跟哪个数据库进行交互;</p>
</li>
<li><p>需要指定 JPA 使用哪个持久化的框架以及配置该框架的基本属性</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">persistence</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/persistence&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--需要配置persistence-unit节点</span></span><br><span class="line"><span class="comment">    持久化单元:</span></span><br><span class="line"><span class="comment">        name:持久化单元名称</span></span><br><span class="line"><span class="comment">        transaction-type:事务管理的方式</span></span><br><span class="line"><span class="comment">                JTA: 分布式事先管理</span></span><br><span class="line"><span class="comment">                RESOURCE_LOCAL:本地事务管理</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">persistence-unit</span> <span class="attr">name</span>=<span class="string">&quot;myJPA&quot;</span> <span class="attr">transaction-type</span>=<span class="string">&quot;RESOURCE_LOCAL&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        jpa的实现方式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span>&gt;</span>org.hibernate.jpa.HibernatePersistenceProvider<span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 添加持久化类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.tcmyxc.helloworld.Customer<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--        数据库信息</span></span><br><span class="line"><span class="comment">              用户名, javax.persistence.jdbc.user</span></span><br><span class="line"><span class="comment">              密码, javax.persistence.jdbc.password</span></span><br><span class="line"><span class="comment">              驱动, javax.persistence.jdbc.driver</span></span><br><span class="line"><span class="comment">              数据库地址 javax.persistence.jdbc.url</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--            三个/  ///表示本地路径,端口为3306 jdbc:mysql://localhost:3306/test?serverTimezone=UTC--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///jpa_test?serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--        可选配置:配置jpa实现方的配置信息</span></span><br><span class="line"><span class="comment">                    显示sql执行语句</span></span><br><span class="line"><span class="comment">                    自动创建数据库表  hibernate.hbm2ddl.auto</span></span><br><span class="line"><span class="comment">                                        create,程序运行时创建数据库表(如果有表,先删除表再创建表)</span></span><br><span class="line"><span class="comment">                                        update,程序运行时创建表(如果表存在,则不会创建)</span></span><br><span class="line"><span class="comment">                                        none 不会创建表</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.show_sql&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span> <span class="attr">value</span>=<span class="string">&quot;update&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.format_sql&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">persistence-unit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistence</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>（2）创建实体类, 使用 annotation 来描述实体类跟数据库表之间的映射关系.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 持久化类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Table(name = &quot;JPA_CUSTOMERS&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;LAST_NAME&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（3）使用 JPA API 完成数据增加、删除、修改和查询操作</p>
<ul>
<li><p>创建 EntityManagerFactory (对应 Hibernate 中的 SessionFactory);</p>
</li>
<li><p>创建 EntityManager (对应 Hibernate 中的Session);</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建 EntityManagerFactory</span></span><br><span class="line">    String persistenceUnitName = <span class="string">&quot;myJPA&quot;</span>;</span><br><span class="line">    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(persistenceUnitName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、创建 EntityManager</span></span><br><span class="line">    EntityManager entityManager = entityManagerFactory.createEntityManager();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、开启事务</span></span><br><span class="line">    EntityTransaction transaction = entityManager.getTransaction();</span><br><span class="line">    transaction.begin();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、CRUD 操作</span></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setLastName(<span class="string">&quot;xwx&quot;</span>);</span><br><span class="line">    customer.setEmail(<span class="string">&quot;1282494272@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    entityManager.persist(customer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、提交事务</span></span><br><span class="line">    transaction.commit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、关闭 EntityManager</span></span><br><span class="line">    entityManager.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、关闭 EntityManagerFactory</span></span><br><span class="line">    entityManagerFactory.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行截图：</p>
<p><img src="../images/image-20210612173746712.png" alt="image-20210612173746712"></p>
<p><img src="../images/image-20210612173801846.png" alt="image-20210612173801846"></p>
<h2 id="3、注解"><a href="#3、注解" class="headerlink" title="3、注解"></a>3、注解</h2><h3 id="Entity"><a href="#Entity" class="headerlink" title="@Entity"></a>@Entity</h3><p>@Entity 标注用于实体类声明语句之前，指出该Java 类为实体类，将映射到指定的数据库表。</p>
<h3 id="Table"><a href="#Table" class="headerlink" title="@Table"></a>@Table</h3><p>当实体类与其映射的数据库表名不同名时需要使用 @Table 标注说明，该标注与 @Entity 标注并列使用，置于实体类声明语句之前，可写于单独语句行，也可与声明语句同行。</p>
<p>@Table 标注的常用选项是 name，用于指明数据库的表名</p>
<p>@Table标注还有一个两个选项 catalog 和 schema 用于设置表所属的数据库目录或模式，通常为数据库名。</p>
<p>uniqueConstraints 选项用于设置约束条件，通常不须设置。</p>
<h3 id="Id"><a href="#Id" class="headerlink" title="@Id"></a>@Id</h3><p>@Id 标注用于声明一个实体类的属性映射为数据库的主键列。该属性通常置于属性声明语句之前，可与声明语句同行，也可写在单独行上。</p>
<p>@Id标注也可置于属性的getter方法之前。</p>
<h3 id="GeneratedValue"><a href="#GeneratedValue" class="headerlink" title="@GeneratedValue"></a>@GeneratedValue</h3><p>@GeneratedValue  用于标注主键的生成策略，通过 strategy 属性指定。默认情况下，JPA 自动选择一个最适合底层数据库的主键生成策略：SqlServer 对应 identity，MySQL 对应 auto increment。</p>
<p>在 javax.persistence.GenerationType 中定义了以下几种可供选择的策略：</p>
<ul>
<li><p>IDENTITY：采用数据库 ID自增长的方式来自增主键字段，Oracle 不支持这种方式；</p>
</li>
<li><p><strong>AUTO</strong>： JPA自动选择合适的策略，是默认选项；</p>
</li>
<li><p>SEQUENCE：通过序列产生主键，通过 @SequenceGenerator 注解指定序列名，MySql 不支持这种方式</p>
</li>
<li><p>TABLE：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。</p>
</li>
</ul>
<h3 id="Basic"><a href="#Basic" class="headerlink" title="@Basic"></a>@Basic</h3><p>@Basic 表示一个简单的属性到数据库表的字段的映射,对于没有任何标注的 getXxxx() 方法,默认即为@Basic</p>
<p>fetch: 表示该属性的读取策略,有 EAGER 和 LAZY 两种,分别表示主支抓取和延迟加载,默认为 EAGER.</p>
<p>optional:表示该属性是否允许为null, 默认为true</p>
<h3 id="Column"><a href="#Column" class="headerlink" title="@Column"></a>@Column</h3><p>当实体的属性与其映射的数据库表的列不同名时需要使用@Column 标注说明，该属性通常置于实体的属性声明语句之前，还可与 @Id 标注一起使用。</p>
<p>@Column 标注的常用属性是 name，用于设置映射数据库表的列名。此外，该标注还包含其它多个属性，如：unique 、nullable、length 等。</p>
<p>@Column 标注的 columnDefinition 属性: 表示该字段在数据库中的实际类型.通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型,但是对于Date类型仍无法确定数据库中字段类型究竟是DATE,TIME还是TIMESTAMP.此外,String的默认映射类型为VARCHAR, 如果要将 String 类型映射到特定数据库的 BLOB 或TEXT 字段类型.</p>
<p>@Column标注也可置于属性的getter方法之前</p>
<h3 id="Transient"><a href="#Transient" class="headerlink" title="@Transient"></a>@Transient</h3><p>表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性.</p>
<p>如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic</p>
<h3 id="Temporal"><a href="#Temporal" class="headerlink" title="@Temporal"></a>@Temporal</h3><p>在核心的 Java API 中并没有定义 Date 类型的精度(temporal precision).  而在数据库中,表示 Date 类型的数据有 DATE, TIME, 和 TIMESTAMP 三种精度(即单纯的日期,时间,或者两者 兼备). 在进行属性映射时可使用@Temporal注解来调整精度</p>
<p><img src="../images/image-20210612175625699.png" alt="image-20210612175625699"></p>
<p>对应数据库：</p>
<p><img src="../images/image-20210612175607590.png" alt="image-20210612175607590"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create table jpa_customers;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `jpa_customers` (</span><br><span class="line">  `id` int NOT NULL,</span><br><span class="line">  `birth` date DEFAULT NULL,</span><br><span class="line">  `createdTime` datetime(6) DEFAULT NULL,</span><br><span class="line">  `email` varchar(255) DEFAULT NULL,</span><br><span class="line">  `LAST_NAME` varchar(50) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>

<h2 id="4、JPA-API"><a href="#4、JPA-API" class="headerlink" title="4、JPA API"></a>4、JPA API</h2><h3 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h3><p>用于获取 EntityManagerFactory 实例。该类包含一个名为 createEntityManagerFactory 的 静态方法 。</p>
<p>createEntityManagerFactory 方法有如下两个重载版本。</p>
<ul>
<li>带有一个参数的方法以 JPA 配置文件 persistence.xml 中的持久化单元名为参数</li>
<li>带有两个参数的方法：前一个参数含义相同，后一个参数 Map类型，用于设置 JPA 的相关属性，这时将忽略其它地方设置的属性。Map 对象的属性名必须是 JPA 实现库提供商的名字空间约定的属性名。</li>
</ul>
<p><img src="../images/image-20210612184416168.png" alt="image-20210612184416168"></p>
<h3 id="EntityManagerFactory"><a href="#EntityManagerFactory" class="headerlink" title="EntityManagerFactory"></a>EntityManagerFactory</h3><p>EntityManagerFactory 接口主要用来创建 EntityManager 实例。该接口约定了如下4个方法：</p>
<ul>
<li><p>createEntityManager()：用于创建实体管理器对象实例。</p>
</li>
<li><p>createEntityManager(Map map)：用于创建实体管理器对象实例的重载方法，Map 参数用于提供 EntityManager 的属性。</p>
</li>
<li><p>isOpen()：检查 EntityManagerFactory 是否处于打开状态。实体管理器工厂创建后一直处于打开状态，除非调用close()方法将其关闭。</p>
</li>
<li><p>close()：关闭 EntityManagerFactory 。 EntityManagerFactory 关闭后将释放所有资源，isOpen()方法测试将返回 false，其它方法将不能调用，否则将导致IllegalStateException异常。</p>
</li>
</ul>
<h3 id="EntityManager"><a href="#EntityManager" class="headerlink" title="EntityManager"></a>EntityManager</h3><p>是完成持久化操作的核心对象。实体作为普通 Java 对象，只有在调用 EntityManager 将其持久化后才会变成持久化对象。EntityManager 对象在一组实体类与底层数据源之间进行 O/R 映射的管理。它可以用来管理和更新 Entity Bean, 根椐主键查找 Entity Bean, 还可以通过JPQL语句查询实体。</p>
<p> 实体的状态:</p>
<p>新建状态:   新创建的对象，尚未拥有持久性主键。</p>
<p>持久化状态：已经拥有持久性主键并和持久化建立了上下文环境</p>
<p>游离状态：拥有持久化主键，但是没有与持久化建立上下文环境</p>
<p>删除状态:  拥有持久化主键，已经和持久化建立上下文环境，但是从数据库中删除。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">// 返回指定的 OID 对应的实体类对象</span><br><span class="line">find (Class&lt;T&gt; entityClass,Object primaryKey)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getReference (Class&lt;T&gt; entityClass,Object primaryKey)</span><br><span class="line"></span><br><span class="line">// 用于将新创建的 Entity 纳入到 EntityManager 的管理</span><br><span class="line">persist (Object entity)</span><br><span class="line"></span><br><span class="line">remove (Object entity)</span><br><span class="line"></span><br><span class="line">// 用于处理 Entity 的同步。即数据库的插入和更新操作</span><br><span class="line">merge (T entity)</span><br><span class="line"></span><br><span class="line">// 同步持久上下文环境</span><br><span class="line">flush ()</span><br><span class="line"></span><br><span class="line">// 设置持久上下文环境的Flush模式，自动更新或者提交事务才刷新</span><br><span class="line">setFlushMode (FlushModeType flushMode)</span><br><span class="line"></span><br><span class="line">// 获取持久上下文环境的Flush模式</span><br><span class="line">getFlushMode ()</span><br></pre></td></tr></table></figure>

<h3 id="EntityTransaction"><a href="#EntityTransaction" class="headerlink" title="EntityTransaction"></a>EntityTransaction</h3><p><code>begin(), commit(), rollback()</code> 等</p>
<h2 id="5、映射关系"><a href="#5、映射关系" class="headerlink" title="5、映射关系"></a>5、映射关系</h2><h3 id="单向多对一"><a href="#单向多对一" class="headerlink" title="单向多对一"></a>单向多对一</h3><p>例如：多个订单属于一个客户</p>
<p>只需从n的一端可以访问1的一端</p>
<p>1、订单实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;jpa_order&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_name&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderName</span><span class="params">(String orderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射单向多对一关系,，多个订单属于一个客户</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span><span class="comment">// 映射外键，同时声明列名</span></span><br><span class="line">    <span class="meta">@ManyToOne</span><span class="comment">// 这里可以设置懒加载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customer = customer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, orderName=&#x27;&quot;</span> + orderName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, customer=&quot;</span> + customer +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManyToOne</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setLastName(<span class="string">&quot;小华&quot;</span>);</span><br><span class="line">    customer.setEmail(<span class="string">&quot;ff@163.com&quot;</span>);</span><br><span class="line">    customer.setCreatedTime(<span class="keyword">new</span> Date());</span><br><span class="line">    customer.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setOrderName(<span class="string">&quot;O-FF-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setOrderName(<span class="string">&quot;O-FF-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order3 = <span class="keyword">new</span> Order();</span><br><span class="line">    order3.setOrderName(<span class="string">&quot;O-FF-3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联关系</span></span><br><span class="line">    order1.setCustomer(customer);</span><br><span class="line">    order2.setCustomer(customer);</span><br><span class="line">    order3.setCustomer(customer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存</span></span><br><span class="line">    entityManager.persist(customer);</span><br><span class="line">    entityManager.persist(order1);</span><br><span class="line">    entityManager.persist(order2);</span><br><span class="line">    entityManager.persist(order3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果先保存订单，实际上会把订单的<code>customer_id</code>设为<code>null</code>，之后再进行更新操作，开销变大了</p>
<p>【建议】</p>
<p>先保存 1 的一端，再保存多的一端</p>
<p>删除的时候因为有外键关联，不能直接删除 1 的一端</p>
<h3 id="单向一对多"><a href="#单向一对多" class="headerlink" title="单向一对多"></a>单向一对多</h3><p>一个客户有多个订单</p>
<p>1、修改订单类，去掉 Customer 属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;jpa_order&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_name&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderName</span><span class="params">(String orderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、在用户里添加订单属性（是个集合或者列表）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射单向一对多</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line"><span class="meta">@OneToMany</span><span class="comment">// 默认懒加载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Order&gt; <span class="title">getOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrders</span><span class="params">(Set&lt;Order&gt; orders)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orders = orders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOneToMany</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setLastName(<span class="string">&quot;小华&quot;</span>);</span><br><span class="line">    customer.setEmail(<span class="string">&quot;gg@163.com&quot;</span>);</span><br><span class="line">    customer.setCreatedTime(<span class="keyword">new</span> Date());</span><br><span class="line">    customer.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setOrderName(<span class="string">&quot;O-GG-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setOrderName(<span class="string">&quot;O-GG-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order3 = <span class="keyword">new</span> Order();</span><br><span class="line">    order3.setOrderName(<span class="string">&quot;O-GG-3&quot;</span>);</span><br><span class="line">    customer.getOrders().add(order1);</span><br><span class="line">    customer.getOrders().add(order2);</span><br><span class="line">    customer.getOrders().add(order3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存</span></span><br><span class="line">    entityManager.persist(customer);</span><br><span class="line">    entityManager.persist(order1);</span><br><span class="line">    entityManager.persist(order2);</span><br><span class="line">    entityManager.persist(order3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【注意】：单向一对多保存时一定会有更新语句发生，与保存顺序无关。因为多的一端再插入时不会同时插入外键列</p>
<p>删除一的一端，会把关联的多的一端外键置空，然后删除，可以在<code>@OneToMany</code>设置级联删除</p>
<h3 id="双向多对一"><a href="#双向多对一" class="headerlink" title="双向多对一"></a>双向多对一</h3><p>订单属性里面有客户，客户里面有订单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Date createdTime;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Order&gt; <span class="title">getOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orders;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span><span class="comment">// 映射外键</span></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>映射的外键名要一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManyToOne</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setLastName(<span class="string">&quot;小华&quot;</span>);</span><br><span class="line">    customer.setEmail(<span class="string">&quot;ww@163.com&quot;</span>);</span><br><span class="line">    customer.setCreatedTime(<span class="keyword">new</span> Date());</span><br><span class="line">    customer.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setOrderName(<span class="string">&quot;O-ww-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setOrderName(<span class="string">&quot;O-ww-2&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联关系</span></span><br><span class="line">    order1.setCustomer(customer);</span><br><span class="line">    order2.setCustomer(customer);</span><br><span class="line"></span><br><span class="line">    customer.getOrders().add(order1);</span><br><span class="line">    customer.getOrders().add(order2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存</span></span><br><span class="line">    entityManager.persist(customer);<span class="comment">// n条update，写后面就是 2n 条</span></span><br><span class="line">    entityManager.persist(order1);</span><br><span class="line">    entityManager.persist(order2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果先保存多的一端，会有多余的更新语句</p>
<p>让多的一方来维护关联关系，在 @OneToMany 中设置 mapperBy（值为多的一方的 customer 属性）</p>
<p>【注意】</p>
<p>如果在 1 的一端 @OneToMany 中使用 mapperBy，就不能再使用 @JoinColumn</p>
<h3 id="双向一对一"><a href="#双向一对一" class="headerlink" title="双向一对一"></a>双向一对一</h3><p>基于外键的 1-1 关联关系：在双向的一对一关联中，需要在关系被维护端(inverse side)中的 @OneToOne 注释中指定 mappedBy，以指定是这一关联中的被维护端。同时需要在关系维护端(owner side)建立外键列指向关系被维护端的主键列。</p>
<p>设计：一个部门只能有一个经理，一个经理也只能管一个部门</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;jpa_manager&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String mgrName;</span><br><span class="line">    <span class="keyword">private</span> Department dept;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToOne(mappedBy = &quot;mgr&quot;)</span><span class="comment">// 不维护关联关系（等于说是我这张表里面没有这个字段，虽然属性里面有），需要设置 mappedBy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;jpa_department&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String deptName;</span><br><span class="line">    <span class="keyword">private</span> Manager mgr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToOne</span> <span class="comment">// 映射一对一关联关系，维护关联关系</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;mgr_id&quot;, unique = true)</span><span class="comment">// 一对一需要添加 unique=true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Manager <span class="title">getMgr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mgr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOneToOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Manager manager = <span class="keyword">new</span> Manager();</span><br><span class="line">    manager.setMgrName(<span class="string">&quot;M-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Department department = <span class="keyword">new</span> Department();</span><br><span class="line">    department.setDeptName(<span class="string">&quot;D-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联关系</span></span><br><span class="line">    manager.setDept(department);</span><br><span class="line">    department.setMgr(manager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    entityManager.persist(manager);<span class="comment">// 先保存不维护关联关系的（即没有外键的一方）</span></span><br><span class="line">    entityManager.persist(department);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认情况下，若获取维护关联关系的一方，则会通过左外连接获取其关联的对象</span></span><br><span class="line"><span class="comment">// 但是可以设置维护关联关系的一方的 @OneToOne 的 fetch 属性来修改加载策略来实现懒加载</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOneToOneFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Department dept = entityManager.find(Department.class, <span class="number">1</span>);</span><br><span class="line">    System.out.println(dept.getDeptName());</span><br><span class="line">    System.out.println(dept.getMgr().getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        department0<span class="built_in">_</span>.id as id1<span class="built_in">_</span>1<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        department0<span class="built_in">_</span>.deptName as deptname2<span class="built_in">_</span>1<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        department0<span class="built_in">_</span>.mgr<span class="built_in">_</span>id as mgr<span class="built_in">_</span>id3<span class="built_in">_</span>1<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        manager1<span class="built_in">_</span>.id as id1<span class="built_in">_</span>2<span class="built_in">_</span>1<span class="built_in">_</span>,</span><br><span class="line">        manager1<span class="built_in">_</span>.mgr<span class="built_in">_</span>name as mgr<span class="built_in">_</span>name2<span class="built_in">_</span>2<span class="built_in">_</span>1<span class="built_in">_</span> </span><br><span class="line">    from</span><br><span class="line">        jpa<span class="built_in">_</span>department department0<span class="built_in">_</span> </span><br><span class="line">    left outer join</span><br><span class="line">        jpa<span class="built_in">_</span>manager manager1<span class="built_in">_</span> </span><br><span class="line">            on department0<span class="built_in">_</span>.mgr<span class="built_in">_</span>id=manager1<span class="built_in">_</span>.id </span><br><span class="line">    where</span><br><span class="line">        department0<span class="built_in">_</span>.id=?</span><br><span class="line">D-1</span><br><span class="line">com.tcmyxc.helloworld.Manager</span><br></pre></td></tr></table></figure>



<p>【注意】：默认情况下，若获取不维护关联关系的一方，则也会通过左外连接获取其关联的对象，虽然可以改为懒加载，但是会多发 SQL 语句，得不偿失</p>
<h3 id="双向多对多"><a href="#双向多对多" class="headerlink" title="双向多对多"></a>双向多对多</h3><p>在双向多对多关系中，我们必须指定一个关系维护端(owner side),可以通过 @ManyToMany 注释中指定 mappedBy 属性来标识其为关系维护端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;jpa_item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String itemName;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Category&gt; categories = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">// 不写会报空指针，因为不能直接使用接口，接口变量必须引用实现了接口的类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置多对多的关系</span></span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="comment">// 设置中间表</span></span><br><span class="line">    <span class="comment">// 1、joinColumns 映射当前类</span></span><br><span class="line">    <span class="comment">// 2、inverseJoinColumns 映射关联的类</span></span><br><span class="line">    <span class="meta">@JoinTable(joinColumns = &#123;</span></span><br><span class="line"><span class="meta">            @JoinColumn(name = &quot;item_id&quot;, // 中间表的外键名</span></span><br><span class="line"><span class="meta">                    referencedColumnName = &quot;id&quot;)// 外键指向当前表的那个字段</span></span><br><span class="line"><span class="meta">            &#125;,</span></span><br><span class="line"><span class="meta">            inverseJoinColumns = &#123;</span></span><br><span class="line"><span class="meta">            @JoinColumn(name = &quot;category_id&quot;,// 中间表的外键名</span></span><br><span class="line"><span class="meta">                    referencedColumnName = &quot;id&quot;)</span></span><br><span class="line"><span class="meta">            &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Category&gt; <span class="title">getCategories</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> categories;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;jpa_category&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Item&gt; items;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany(mappedBy = &quot;categories&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Item&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化表，可以发现建立了三张表</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    create table jpa<span class="built_in">_</span>category (</span><br><span class="line">       id integer not null auto<span class="built_in">_</span>increment,</span><br><span class="line">        category<span class="built_in">_</span>name varchar(255),</span><br><span class="line">        primary key (id)</span><br><span class="line">    ) engine=InnoDB</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    create table jpa<span class="built_in">_</span>item (</span><br><span class="line">       id integer not null auto<span class="built_in">_</span>increment,</span><br><span class="line">        item<span class="built_in">_</span>name varchar(255),</span><br><span class="line">        primary key (id)</span><br><span class="line">    ) engine=InnoDB</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    create table jpa<span class="built_in">_</span>item<span class="built_in">_</span>jpa<span class="built_in">_</span>category (</span><br><span class="line">       item<span class="built_in">_</span>id integer not null,</span><br><span class="line">        category<span class="built_in">_</span>id integer not null,</span><br><span class="line">        primary key (item<span class="built_in">_</span>id, category<span class="built_in">_</span>id)</span><br><span class="line">    ) engine=InnoDB</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    alter table jpa<span class="built_in">_</span>item<span class="built_in">_</span>jpa<span class="built_in">_</span>category </span><br><span class="line">       add constraint FKedbrfsg4dplyysrucevm258pk </span><br><span class="line">       foreign key (category<span class="built_in">_</span>id) </span><br><span class="line">       references jpa<span class="built_in">_</span>category (id)</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    alter table jpa<span class="built_in">_</span>item<span class="built_in">_</span>jpa<span class="built_in">_</span>category </span><br><span class="line">       add constraint FK7vk3csx9i2cq3etibrkouumid </span><br><span class="line">       foreign key (item<span class="built_in">_</span>id) </span><br><span class="line">       references jpa<span class="built_in">_</span>item (id)</span><br></pre></td></tr></table></figure>



<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManyToMany</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Item i1 = <span class="keyword">new</span> Item();</span><br><span class="line">    Item i2 = <span class="keyword">new</span> Item();</span><br><span class="line"></span><br><span class="line">    i1.setItemName(<span class="string">&quot;item1&quot;</span>);</span><br><span class="line">    i2.setItemName(<span class="string">&quot;item2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Category c1 = <span class="keyword">new</span> Category();</span><br><span class="line">    Category c2 = <span class="keyword">new</span> Category();</span><br><span class="line">    Category c3 = <span class="keyword">new</span> Category();</span><br><span class="line"></span><br><span class="line">    c1.setCategoryName(<span class="string">&quot;C-1&quot;</span>);</span><br><span class="line">    c2.setCategoryName(<span class="string">&quot;C-2&quot;</span>);</span><br><span class="line">    c3.setCategoryName(<span class="string">&quot;C-3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联关系</span></span><br><span class="line">    i1.getCategories().add(c1);</span><br><span class="line">    i1.getCategories().add(c2);</span><br><span class="line">    i1.getCategories().add(c3);</span><br><span class="line"></span><br><span class="line">    i2.getCategories().add(c1);</span><br><span class="line">    i2.getCategories().add(c3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    entityManager.persist(i1);</span><br><span class="line">    entityManager.persist(i2);</span><br><span class="line">    entityManager.persist(c1);</span><br><span class="line">    entityManager.persist(c2);</span><br><span class="line">    entityManager.persist(c3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>很尴尬地失败了</p>
<p><img src="../images/image-20210616165321122.png" alt="image-20210616165321122"></p>
<p>错误原因：不能直接使用接口变量，接口变量必须引用实现了接口的类的实例。</p>
<p>解决方法：在类定义那里把接口变量改为正确的引用。</p>
<p>查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManyToManyFind</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Item item = entityManager.find(Item.class, <span class="number">1</span>);</span><br><span class="line">    System.out.println(item.getItemName());</span><br><span class="line"></span><br><span class="line">    System.out.println(item.getCategories().size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        item0<span class="built_in">_</span>.id as id1<span class="built_in">_</span>4<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        item0<span class="built_in">_</span>.item<span class="built_in">_</span>name as item<span class="built_in">_</span>nam2<span class="built_in">_</span>4<span class="built_in">_</span>0<span class="built_in">_</span> </span><br><span class="line">    from</span><br><span class="line">        jpa<span class="built_in">_</span>item item0<span class="built_in">_</span> </span><br><span class="line">    where</span><br><span class="line">        item0<span class="built_in">_</span>.id=?</span><br><span class="line">I-1</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        categories0<span class="built_in">_</span>.item<span class="built_in">_</span>id as item<span class="built_in">_</span>id1<span class="built_in">_</span>0<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        categories0<span class="built_in">_</span>.category<span class="built_in">_</span>id as category2<span class="built_in">_</span>0<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        category1<span class="built_in">_</span>.id as id1<span class="built_in">_</span>1<span class="built_in">_</span>1<span class="built_in">_</span>,</span><br><span class="line">        category1<span class="built_in">_</span>.category<span class="built_in">_</span>name as category2<span class="built_in">_</span>1<span class="built_in">_</span>1<span class="built_in">_</span> </span><br><span class="line">    from</span><br><span class="line">        item<span class="built_in">_</span>category categories0<span class="built_in">_</span> </span><br><span class="line">    inner join</span><br><span class="line">        jpa<span class="built_in">_</span>category category1<span class="built_in">_</span> </span><br><span class="line">            on categories0<span class="built_in">_</span>.category<span class="built_in">_</span>id=category1<span class="built_in">_</span>.id </span><br><span class="line">    where</span><br><span class="line">        categories0<span class="built_in">_</span>.item<span class="built_in">_</span>id=?</span><br><span class="line">2</span><br></pre></td></tr></table></figure>



<p>可以看出来，这里默认用的是懒加载。其实从分类里面查标签也是懒加载。</p>
<h2 id="6、JQPL"><a href="#6、JQPL" class="headerlink" title="6、JQPL"></a>6、JQPL</h2><p>Java Persistence Query Language 的简称。JPQL 是一种和 SQL 非常类似的中间性和对象化查询语言，它最终会被编译成针对不同底层数据库的 SQL 查询，从而屏蔽不同数据库的差异。</p>
<p>JPQL语言的语句可以是 select 语句、update 语句或delete语句，它们都通过 Query 接口封装执行</p>
<h3 id="Query-接口"><a href="#Query-接口" class="headerlink" title="Query 接口"></a>Query 接口</h3><p>Query接口封装了执行数据库查询的相关方法。调用 EntityManager 的 createQuery、create NamedQuery 及 createNativeQuery 方法可以获得查询对象，进而可调用 Query 接口的相关方法来执行查询操作。</p>
<h3 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h3><p>用于执行查询。其语法可表示为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">select_clause </span><br><span class="line">form_clause </span><br><span class="line">[where_clause] </span><br><span class="line">[groupby_clause] </span><br><span class="line">[having_clause]</span><br><span class="line">[orderby_clause]</span><br></pre></td></tr></table></figure>

<p>select、from 都是 JPQL 的关键字，通常全大写或全小写，建议不要大小写混用。</p>
<p><strong>查询所有</strong>实体的 JPQL 查询字串很简单，例如：</p>
<p>​    select o from Order o 或  select o from Order as o</p>
<p>关键字 as 可以省去。</p>
<p>标识符变量的命名规范与 Java 标识符相同，且区分大小写。</p>
<p>调用 EntityManager 的 createQuery() 方法可创建查询对象，接着调用 Query 接口的 getResultList() 方法就可获得查询结果集。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query query = entityManager.createQuery( <span class="string">&quot;select o from Order o&quot;</span>); </span><br><span class="line">List orders = query.getResultList();</span><br><span class="line">Iterator iterator = orders.iterator();</span><br><span class="line"><span class="keyword">while</span>( iterator.hasNext() ) &#123;</span><br><span class="line">	<span class="comment">// 处理Order</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JPQL也支持<strong>包含参数的查询</strong>，例如：</p>
<p>​    select o from Orders o where o.id = :myId</p>
<p>​    select o from Orders o where o.id = :myId and o.customer = :customerName</p>
<p>注意：参数名前必须冠以冒号(:)，执行查询前须使用Query.setParameter(name, value)方法给参数赋值。</p>
<p>可以<strong>不使用参数名而使用参数的序号</strong>，例如：</p>
<p>select o from Order o where o.id = ?1 and o.customer = ?2</p>
<p>其中 ?1 代表第一个参数，?2 代表第一个参数。在执行查询之前需要使用重载方法Query.setParameter(pos, value) 提供参数值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query query = entityManager.createQuery( <span class="string">&quot;select o from Orders o where o.id = ?1 and o.customer = ?2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 占位符的索引是从 1 开始的</span></span><br><span class="line">query.setParameter( <span class="number">1</span>, <span class="number">2</span> );</span><br><span class="line">query.setParameter( <span class="number">2</span>, <span class="string">&quot;John&quot;</span> );</span><br><span class="line">List orders = query.getResultList();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>JPQL也支持子查询，在 where 或 having 子句中可以包含另一个查询。</p>
<p><strong>查询部分属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询部分属性</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPartlyProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jpql = <span class="string">&quot;select c.email, c.lastName from Customer c where c.id &gt; ?1&quot;</span>;</span><br><span class="line">    Query query = entityManager.createQuery(jpql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 占位符的索引是从 1 开始的</span></span><br><span class="line">    query.setParameter(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    List resultList = query.getResultList();</span><br><span class="line">    System.out.println(resultList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[[Ljava.lang.Object;@c6b2dd9, [Ljava.lang.Object;@73437222]</span><br></pre></td></tr></table></figure>

<p>可以看到是个 Object 数组</p>
<p>如果想返回对应类的对象，需要有对应参数的构造器，同时修改查询语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Customer 类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String lastName, String email)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    <span class="keyword">this</span>.email = email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试语句</span></span><br><span class="line">String jpql = <span class="string">&quot;select new Customer(c.email, c.lastName) from Customer c where c.id &gt; ?1&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[Customer&#123;id=null, lastName=&#x27;ww@163.com&#x27;, email=&#x27;小华&#x27;, createdTime=null, birth=null&#125;, Customer&#123;id=null, lastName=&#x27;ww@163.com&#x27;, email=&#x27;小华&#x27;, createdTime=null, birth=null&#125;]</span><br></pre></td></tr></table></figure>

<p>这里 JQPL 帮我们做了底层的转换，所以数组里面放的是 Customer 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(resultList.get(<span class="number">0</span>).getClass().getName());</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">com.tcmyxc.helloworld.Customer</span><br></pre></td></tr></table></figure>

<p><strong>查询语句也可以放在实体类头上</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NamedQuery(name = &quot;testNamedQuery&quot;, query = &quot;SELECT c FROM Customer c where c.id = ?1&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;JPA_CUSTOMERS&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 指定 name，同时设置参数</span></span><br><span class="line">    Query query = entityManager.createNamedQuery(<span class="string">&quot;testNamedQuerySQL&quot;</span>).setParameter(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    Customer customer = (Customer) query.getSingleResult();</span><br><span class="line">    System.out.println(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Customer&#123;id=1, lastName=&#x27;小华&#x27;, email=&#x27;ww@163.com&#x27;, createdTime=2021-06-13 17:07:17.677, birth=2021-06-13&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Native SQL</strong></p>
<p>指原生的 SQL 语句，不再是 JQPL 的语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativedQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;select birth from JPA_CUSTOMERS c where c.id = 1&quot;</span>;</span><br><span class="line">    Query query = entityManager.createNativeQuery(sql);</span><br><span class="line">    System.out.println(query.getSingleResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        birth </span><br><span class="line">    from</span><br><span class="line">        JPA<span class="built_in">_</span>CUSTOMERS c </span><br><span class="line">    where</span><br><span class="line">        c.id = 1</span><br><span class="line">2021-06-13</span><br></pre></td></tr></table></figure>



<p>JQPL 也支持 order by、group by、having、关联查询、子查询等</p>
<h3 id="update-和-delete"><a href="#update-和-delete" class="headerlink" title="update 和 delete"></a>update 和 delete</h3><p>更新操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;update Customer c set c.lastName = ?1 where c.id = ?2&quot;</span>;</span><br><span class="line">    Query query = entityManager.createQuery(sql);</span><br><span class="line">    query.setParameter(<span class="number">1</span>, <span class="string">&quot;YYY&quot;</span>).setParameter(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    query.executeUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210617115000945.png" alt="image-20210617115000945"></p>
<p>删除操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;delete from Order o where o.id = ?1&quot;</span>;</span><br><span class="line">    Query query = entityManager.createQuery(sql);</span><br><span class="line">    query.setParameter(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    query.executeUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210617120812216.png" alt="image-20210617120812216"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>JQPL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/archives/14ea6df7.html</url>
    <content><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h2><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p>
<p>关系数据库管理系统(Relational Database Management System)的特点：</p>
<ul>
<li>  1.数据以表格的形式出现</li>
<li>  2.每行为各种记录名称</li>
<li>  3.每列为记录名称所对应的数据域</li>
<li>  4.许多的行和列组成一张表单</li>
<li>  5.若干的表单组成database</li>
</ul>
<span id="more"></span>

<h2 id="几个术语"><a href="#几个术语" class="headerlink" title="几个术语"></a>几个术语</h2><ul>
<li>  <strong>主键</strong>：<strong>主键是唯一的</strong>。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>
<li>  <strong>外键：</strong>外键用于关联两个表。</li>
<li>  <strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>
<li>  <strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>
</ul>
<h2 id="create-创建数据库"><a href="#create-创建数据库" class="headerlink" title="create 创建数据库"></a>create 创建数据库</h2><p>我们可以在登陆 MySQL 服务后，使用 <strong>create</strong> 命令创建数据库，语法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名;</span><br></pre></td></tr></table></figure>

<h2 id="drop-删除数据库"><a href="#drop-删除数据库" class="headerlink" title="drop 删除数据库"></a>drop 删除数据库</h2><p>drop 命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="use-选择-MySQL-数据库"><a href="#use-选择-MySQL-数据库" class="headerlink" title="use 选择 MySQL 数据库"></a>use 选择 MySQL 数据库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure>

<h2 id="创建-MySQL-数据表"><a href="#创建-MySQL-数据表" class="headerlink" title="创建 MySQL 数据表"></a>创建 MySQL 数据表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name (column_name column_type);</span><br></pre></td></tr></table></figure>



<p>创建数据表runoob_tbl：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS `runoob_tbl`(</span><br><span class="line">   `runoob_id` INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">   `runoob_title` VARCHAR(100) NOT NULL,</span><br><span class="line">   `runoob_author` VARCHAR(40) NOT NULL,</span><br><span class="line">   `submission_date` DATE,</span><br><span class="line">   PRIMARY KEY ( `runoob_id` )</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<h2 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE 数据表名;</span><br></pre></td></tr></table></figure>

<h2 id="insert-into-插入数据"><a href="#insert-into-插入数据" class="headerlink" title="insert into 插入数据"></a>insert into 插入数据</h2><p>通用的 <strong>INSERT INTO</strong> SQL语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name ( field1, field2,...fieldN )</span><br><span class="line">                       VALUES</span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure>



<p>如果数据是字符型，必须使用单引号或者双引号，如：”value”。</p>
<h2 id="select-查询数据"><a href="#select-查询数据" class="headerlink" title="select 查询数据"></a>select 查询数据</h2><p>通用的 SELECT 语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name,column_name</span><br><span class="line">FROM table_name</span><br><span class="line">[WHERE Clause]</span><br><span class="line">[LIMIT N][ OFFSET M]</span><br></pre></td></tr></table></figure>



<ul>
<li>  查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</li>
<li>  SELECT 命令可以读取一条或者多条记录。</li>
<li>  你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据</li>
<li>  你可以使用 WHERE 语句来包含任何条件。</li>
<li>  你可以使用 LIMIT 属性来设定返回的记录数。</li>
<li>  你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</li>
</ul>
<h2 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h2><ul>
<li>  查询语句中你可以使用一个或者多个表，表之间使用逗号**,** 分割，并使用WHERE语句来设定查询条件。</li>
<li>  你可以在 WHERE 子句中指定任何条件。</li>
<li>  你可以使用 AND 或者 OR 指定一个或多个条件。</li>
<li>  WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。</li>
<li>  WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。</li>
</ul>
<h2 id="UPDATE-更新"><a href="#UPDATE-更新" class="headerlink" title="UPDATE 更新"></a>UPDATE 更新</h2><p>通用 SQL 语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table_name SET field1=new-value1, field2=new-value2[WHERE Clause]</span><br></pre></td></tr></table></figure>



<ul>
<li>  你可以同时更新一个或多个字段。</li>
<li>  你可以在 WHERE 子句中指定任何条件。</li>
<li>  你可以在一个单独表中同时更新数据。</li>
</ul>
<h2 id="DELETE-语句"><a href="#DELETE-语句" class="headerlink" title="DELETE 语句"></a>DELETE 语句</h2><p>通用语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM table_name [WHERE Clause]</span><br></pre></td></tr></table></figure>



<ul>
<li>  如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。</li>
<li>  你可以在 WHERE 子句中指定任何条件</li>
<li>  您可以在单个表中一次性删除记录。</li>
</ul>
<h2 id="LIKE-子句"><a href="#LIKE-子句" class="headerlink" title="LIKE 子句"></a>LIKE 子句</h2><ul>
<li>  在 where 子句中使用</li>
<li>  使用 <strong>%</strong> 字符来表示任意字符</li>
</ul>
<h2 id="ALTER-命令"><a href="#ALTER-命令" class="headerlink" title="ALTER 命令"></a>ALTER 命令</h2><p>修改数据表名或者修改数据表字段</p>
<h3 id="删除，添加或修改表字段"><a href="#删除，添加或修改表字段" class="headerlink" title="删除，添加或修改表字段"></a>删除，添加或修改表字段</h3><p>如下命令使用了 ALTER 命令及 DROP 子句来删除以上创建表的 i 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl  DROP i;</span><br></pre></td></tr></table></figure>

<p>如果数据表中只剩余一个字段则无法使用DROP来删除字段。</p>
<p>MySQL 中使用 ADD 子句来向数据表中添加列，如下实例在表 testalter_tbl 中添加 i 字段，并定义数据类型:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD i INT;</span><br></pre></td></tr></table></figure>

<h3 id="修改字段类型及名称"><a href="#修改字段类型及名称" class="headerlink" title="修改字段类型及名称"></a>修改字段类型及名称</h3><p>如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。</p>
<p>例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl MODIFY c CHAR(10);</span><br></pre></td></tr></table></figure>

<p>使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型。尝试如下实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl CHANGE i j BIGINT;</span><br></pre></td></tr></table></figure>

<p>当你修改字段时，你可以指定是否包含值或者是否设置默认值。</p>
<p>以下实例，指定字段 j 为 NOT NULL 且默认值为100 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl     -&gt; MODIFY j BIGINT NOT NULL DEFAULT 100;</span><br></pre></td></tr></table></figure>

<p>如果你不设置默认值，MySQL会自动设置该字段默认为 NULL。</p>
<p>修改字段默认值</p>
<p>你可以使用 ALTER 来修改字段的默认值，尝试以下实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;</span><br></pre></td></tr></table></figure>



<h2 id="UNION-操作符"><a href="#UNION-操作符" class="headerlink" title="UNION 操作符"></a>UNION 操作符</h2><p>UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。</p>
<p>UNION 操作符语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions];</span><br></pre></td></tr></table></figure>



<ul>
<li>  <strong>DISTINCT:</strong> 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</li>
<li>  <strong>ALL:</strong> 可选，返回所有结果集，包含重复数据。</li>
</ul>
<h2 id="排序（默认升序）"><a href="#排序（默认升序）" class="headerlink" title="排序（默认升序）"></a>排序（默认升序）</h2><p>ORDER BY 子句将查询数据排序后再返回数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN FROM table_name1, table_name2...ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]</span><br></pre></td></tr></table></figure>



<h2 id="分组-GROUP-BY-语句"><a href="#分组-GROUP-BY-语句" class="headerlink" title="分组 GROUP BY 语句"></a>分组 GROUP BY 语句</h2><p>GROUP BY 语句根据一个或多个列对结果集进行分组。</p>
<p>在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。</p>
<h3 id="GROUP-BY-语法"><a href="#GROUP-BY-语法" class="headerlink" title="GROUP BY 语法"></a>GROUP BY 语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name;</span><br></pre></td></tr></table></figure>



<h2 id="多表查询-union"><a href="#多表查询-union" class="headerlink" title="多表查询 union"></a>多表查询 union</h2><ul>
<li>  <strong>INNER JOIN（内连接,或等值连接）</strong>：获取两个表中字段匹配关系的记录。</li>
<li>  <strong>LEFT JOIN（左连接）：</strong>获取左表所有记录，即使右表没有对应匹配的记录。</li>
<li>  <strong>RIGHT JOIN（右连接）：</strong> 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li>
</ul>
<h2 id="NULL-值处理"><a href="#NULL-值处理" class="headerlink" title="NULL 值处理"></a>NULL 值处理</h2><p>查找数据表中列是否为 NULL，必须使用 <strong>IS NULL</strong> 和 <strong>IS NOT NULL</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL;+---------------+--------------+| runoob_author | runoob_count |+---------------+--------------+| 菜鸟教程  | NULL         || Google        | NULL         |+---------------+--------------+2 rows in set (0.01 sec) mysql&gt; SELECT * from runoob_test_tbl WHERE runoob_count IS NOT NULL;+---------------+--------------+| runoob_author | runoob_count |+---------------+--------------+| RUNOOB        | 20           || FK            | 20           |+---------------+--------------+2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>



<h2 id="正则表达式-regexp（瑞杰克斯普）"><a href="#正则表达式-regexp（瑞杰克斯普）" class="headerlink" title="正则表达式 regexp（瑞杰克斯普）"></a>正则表达式 regexp（瑞杰克斯普）</h2><p>MySQL中使用 REGEXP 操作符来进行正则表达式匹配</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">匹配输入字符串的开始位置。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配输入字符串的结束位置。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像 ‘[.\n]’ 的模式。</td>
</tr>
<tr>
<td align="left">[…]</td>
<td align="left">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td>
</tr>
<tr>
<td align="left">[^…]</td>
<td align="left">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。</td>
</tr>
<tr>
<td align="left">p1|p2|p3</td>
<td align="left">匹配 p1 或 p2 或 p3。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td>
</tr>
</tbody></table>
<p>查找name字段中以’st’为开头的所有数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;^st&#x27;;</span><br></pre></td></tr></table></figure>

<p>查找name字段中以’ok’为结尾的所有数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;ok$&#x27;;</span><br></pre></td></tr></table></figure>

<p>查找name字段中包含’mar’字符串的所有数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;mar&#x27;;</span><br></pre></td></tr></table></figure>

<p>查找name字段中以元音字符开头或以’ok’字符串结尾的所有数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &#x27;^[aeiou]|ok$&#x27;;</span><br></pre></td></tr></table></figure>



<h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h2><ul>
<li>  在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li>
<li>  事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li>
<li>  事务用来管理 insert,update,delete 语句</li>
</ul>
<h3 id="MYSQL-事务处理主要有两种方法："><a href="#MYSQL-事务处理主要有两种方法：" class="headerlink" title="MYSQL 事务处理主要有两种方法："></a>MYSQL 事务处理主要有两种方法：</h3><p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p>
<ul>
<li>  <strong>BEGIN</strong> 开始一个事务</li>
<li>  <strong>ROLLBACK</strong> 事务回滚</li>
<li>  <strong>COMMIT</strong> 事务确认</li>
</ul>
<p>2、直接用 SET 来改变 MySQL 的自动提交模式:</p>
<ul>
<li>  <strong>SET AUTOCOMMIT=0</strong> 禁止自动提交</li>
<li>  <strong>SET AUTOCOMMIT=1</strong> 开启自动提交</li>
</ul>
<h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><p>索引分单列索引和组合索引。</p>
<p>单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。</p>
<p>组合索引，即一个索引包含多个列。</p>
<p>索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p>
<p>索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p>
<h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX indexName ON table_name (column_name)</span><br></pre></td></tr></table></figure>

<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p>
<h3 id="修改表结构-添加索引"><a href="#修改表结构-添加索引" class="headerlink" title="修改表结构(添加索引)"></a>修改表结构(添加索引)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER table tableName ADD INDEX indexName(columnName)</span><br></pre></td></tr></table></figure>

<h3 id="创建表的时候直接指定"><a href="#创建表的时候直接指定" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mytable(   ID INT NOT NULL,    username VARCHAR(16) NOT NULL,   INDEX [indexName] (username(length))   );  </span><br></pre></td></tr></table></figure>

<h3 id="删除索引的语法"><a href="#删除索引的语法" class="headerlink" title="删除索引的语法"></a>删除索引的语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX [indexName] ON mytable; </span><br></pre></td></tr></table></figure>

<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<h3 id="创建索引-1"><a href="#创建索引-1" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX indexName ON mytable(username(length)) </span><br></pre></td></tr></table></figure>

<h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER table mytable ADD UNIQUE [indexName] (username(length))</span><br></pre></td></tr></table></figure>

<h3 id="创建表的时候直接指定-1"><a href="#创建表的时候直接指定-1" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mytable(   ID INT NOT NULL,    username VARCHAR(16) NOT NULL,   UNIQUE [indexName] (username(length))   );  </span><br></pre></td></tr></table></figure>

<h3 id="使用ALTER-命令添加和删除索引"><a href="#使用ALTER-命令添加和删除索引" class="headerlink" title="使用ALTER 命令添加和删除索引"></a>使用ALTER 命令添加和删除索引</h3><p>有四种方式来添加数据表的索引：</p>
<ul>
<li>  ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li>
<li>  <strong>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):</strong> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li>
<li>  <strong>ALTER TABLE tbl_name ADD INDEX index_name (column_list):</strong> 添加普通索引，索引值可出现多次。</li>
<li>  **ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):**该语句指定了索引为 FULLTEXT ，用于全文索引。</li>
</ul>
<p>以下实例为在表中添加索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD INDEX (c);</span><br></pre></td></tr></table></figure>

<p>你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP INDEX c;</span><br></pre></td></tr></table></figure>


<h3 id="使用-ALTER-命令添加和删除主键"><a href="#使用-ALTER-命令添加和删除主键" class="headerlink" title="使用 ALTER 命令添加和删除主键"></a>使用 ALTER 命令添加和删除主键</h3><p>主键作用于列上（可以一个列或多个列联合主键），添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);</span><br></pre></td></tr></table></figure>

<p>你也可以使用 ALTER 命令删除主键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<p>删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。</p>
<h3 id="显示索引信息"><a href="#显示索引信息" class="headerlink" title="显示索引信息"></a>显示索引信息</h3><p>你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。</p>
<p>尝试以下实例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM table_name; \G........</span><br></pre></td></tr></table></figure>



<h2 id="MySQL-临时表（加个关键字-temporary）"><a href="#MySQL-临时表（加个关键字-temporary）" class="headerlink" title="MySQL 临时表（加个关键字 temporary）"></a>MySQL 临时表（加个关键字 temporary）</h2><p>保存一些临时数据</p>
<p>临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间，也可以手动删除。</p>
<h2 id="MySQL-复制表"><a href="#MySQL-复制表" class="headerlink" title="MySQL 复制表"></a>MySQL 复制表</h2><p> <strong>SHOW CREATE TABLE</strong> 命令获取创建数据表(<strong>CREATE TABLE</strong>) 语句，该语句包含了原数据表的结构，索引等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE targetTable LIKE sourceTable;INSERT INTO targetTable SELECT * FROM sourceTable;</span><br></pre></td></tr></table></figure>



<p>REPL(Read Eval Print Loop:交互式解释器) </p>
<h2 id="获取服务器元数据"><a href="#获取服务器元数据" class="headerlink" title="获取服务器元数据"></a>获取服务器元数据</h2><p>以下命令语句可以在 MySQL 的命令提示符使用</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SELECT VERSION( )</td>
<td align="left">服务器版本信息</td>
</tr>
<tr>
<td align="left">SELECT DATABASE( )</td>
<td align="left">当前数据库名 (或者返回空)</td>
</tr>
<tr>
<td align="left">SELECT USER( )</td>
<td align="left">当前用户名</td>
</tr>
<tr>
<td align="left">SHOW STATUS</td>
<td align="left">服务器状态</td>
</tr>
<tr>
<td align="left">SHOW VARIABLES</td>
<td align="left">服务器配置变量</td>
</tr>
</tbody></table>
<h2 id="MySQL-序列使用"><a href="#MySQL-序列使用" class="headerlink" title="MySQL 序列使用"></a>MySQL 序列使用</h2><p>MySQL 序列是一组整数：1, 2, 3, …，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。</p>
<ul>
<li>  使用 AUTO_INCREMENT 来定义序列</li>
<li>  使用 LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值</li>
</ul>
<h2 id="防止SQL注入"><a href="#防止SQL注入" class="headerlink" title="防止SQL注入"></a>防止SQL注入</h2><p>注意以下几个要点：</p>
<ul>
<li>  1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双”-“进行转换等。</li>
<li>  2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。</li>
<li>  3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li>
<li>  4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。</li>
<li>  5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装</li>
<li>  6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。</li>
</ul>
<h2 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h2><p>使用 SELECT … INTO OUTFILE 语句导出数据</p>
<p>可以通过命令选项来设置数据输出的指定格式，以下实例为导出 CSV 格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM passwd INTO OUTFILE &#x27;/tmp/runoob.txt&#x27;    -&gt; FIELDS TERMINATED BY &#x27;,&#x27; ENCLOSED BY &#x27;&quot;&#x27;    -&gt; LINES TERMINATED BY &#x27;\r\n&#x27;;</span><br></pre></td></tr></table></figure>



<h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><h3 id="source-命令导入"><a href="#source-命令导入" class="headerlink" title="source 命令导入"></a>source 命令导入</h3><p>source 命令导入数据库需要先登录到数库终端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database abc;      # 创建数据库mysql&gt; use abc;                  # 使用已创建的数据库 mysql&gt; set names utf8;           # 设置编码mysql&gt; source /home/abc/abc.sql  # 导入备份数据库</span><br></pre></td></tr></table></figure>



<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><blockquote>
<p>  菜鸟论坛</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/archives/4509351.html</url>
    <content><![CDATA[<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><blockquote>
<p>  这篇文章我只是个搬运工，虽然自己也总结了，但是感觉人家写的更好。</p>
<p>  原文链接：<a href="https://github.com/liguigui/CyC2018-CS-Notes">https://github.com/liguigui/CyC2018-CS-Notes</a></p>
</blockquote>
<span id="more"></span>

<h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><a href="https://camo.githubusercontent.com/d1efb1abc3173aa2a607316dda79bea560fe333f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232303934383038342e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232303934383038342e706e67" alt="img"></a></p>
<h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h3><ul>
<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</li>
</ul>
<h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><ul>
<li>ArrayList：基于动态数组实现，支持随机访问。</li>
<li>Vector：和 ArrayList 类似，但它是线程安全的。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<h3 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h3><ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><a href="https://camo.githubusercontent.com/cd126ae7572489beead8b33f3a26a5a0bb1f288e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232343735373835352e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232343735373835352e706e67" alt="img"></a></p>
<ul>
<li>TreeMap：基于红黑树实现。</li>
<li>HashMap：基于哈希表实现。</li>
<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>
<h1 id="二、容器中的设计模式"><a href="#二、容器中的设计模式" class="headerlink" title="二、容器中的设计模式"></a>二、容器中的设计模式</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p><a href="https://camo.githubusercontent.com/6ee13e3fa6717189ef266359ec74ed8a8fb88d62/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232353330313937332e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383232353330313937332e706e67" alt="img"></a></p>
<p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;a&quot;);</span><br><span class="line">list.add(&quot;b&quot;);</span><br><span class="line">for (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SafeVarargs</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a)</span><br></pre></td></tr></table></figure>

<p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;1, 2, 3&#125;;</span><br><span class="line">List list = Arrays.asList(arr);</span><br></pre></td></tr></table></figure>

<p>也可以使用以下方式调用 asList()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List list = Arrays.asList(1, 2, 3);</span><br></pre></td></tr></table></figure>

<h1 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h1><p>如果没有特别说明，以下源码分析基于 JDK 1.8。</p>
<p>在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h3><p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>数组的默认大小为 10。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br></pre></td></tr></table></figure>

<p><a href="https://camo.githubusercontent.com/d1e665d0dfc95837e4ba243d2b26eccf2148f7f1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233323232313236352e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233323232313236352e706e67" alt="img"></a></p>
<h3 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2. 扩容"></a>2. 扩容</h3><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3. 删除元素"></a>3. 删除元素</h3><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    int numMoved = size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-序列化"><a href="#4-序列化" class="headerlink" title="4. 序列化"></a>4. 序列化</h3><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br></pre></td></tr></table></figure>

<p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s)    throws java.io.IOException, ClassNotFoundException &#123;    elementData = EMPTY_ELEMENTDATA;    // Read in size, and any hidden stuff    s.defaultReadObject();    // Read in capacity    s.readInt(); // ignored    if (size &gt; 0) &#123;        // be like clone(), allocate array based upon size not capacity        ensureCapacityInternal(size);        Object[] a = elementData;        // Read in all elements in the proper order.        for (int i=0; i&lt;size; i++) &#123;            a[i] = s.readObject();        &#125;    &#125;&#125;private void writeObject(java.io.ObjectOutputStream s)    throws java.io.IOException&#123;    // Write out element count, and any hidden stuff    int expectedModCount = modCount;    s.defaultWriteObject();    // Write out size as capacity for behavioural compatibility with clone()    s.writeInt(size);    // Write out all elements in the proper order.    for (int i=0; i&lt;size; i++) &#123;        s.writeObject(elementData[i]);    &#125;    if (modCount != expectedModCount) &#123;        throw new ConcurrentModificationException();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList list = new ArrayList();ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));oos.writeObject(list);</span><br></pre></td></tr></table></figure>

<h3 id="5-Fail-Fast"><a href="#5-Fail-Fast" class="headerlink" title="5. Fail-Fast"></a>5. Fail-Fast</h3><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h3 id="1-同步"><a href="#1-同步" class="headerlink" title="1. 同步"></a>1. 同步</h3><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized boolean add(E e) &#123;    modCount++;    ensureCapacityHelper(elementCount + 1);    elementData[elementCount++] = e;    return true;&#125;public synchronized E get(int index) &#123;    if (index &gt;= elementCount)        throw new ArrayIndexOutOfBoundsException(index);    return elementData(index);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-扩容-1"><a href="#2-扩容-1" class="headerlink" title="2. 扩容"></a>2. 扩容</h3><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Vector(int initialCapacity, int capacityIncrement) &#123;    super();    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                           initialCapacity);    this.elementData = new Object[initialCapacity];    this.capacityIncrement = capacityIncrement;&#125;private void grow(int minCapacity) &#123;    // overflow-conscious code    int oldCapacity = elementData.length;    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?                                     capacityIncrement : oldCapacity);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</span><br></pre></td></tr></table></figure>

<p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Vector(int initialCapacity) &#123;    this(initialCapacity, 0);&#125;public Vector() &#123;    this(10);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-与-ArrayList-的比较"><a href="#3-与-ArrayList-的比较" class="headerlink" title="3. 与 ArrayList 的比较"></a>3. 与 ArrayList 的比较</h3><ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li>
</ul>
<h3 id="4-替代方案"><a href="#4-替代方案" class="headerlink" title="4. 替代方案"></a>4. 替代方案</h3><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="1. 读写分离"></a>1. 读写分离</h3><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;    final ReentrantLock lock = this.lock;    lock.lock();    try &#123;        Object[] elements = getArray();        int len = elements.length;        Object[] newElements = Arrays.copyOf(elements, len + 1);        newElements[len] = e;        setArray(newElements);        return true;    &#125; finally &#123;        lock.unlock();    &#125;&#125;final void setArray(Object[] a) &#123;    array = a;&#125;@SuppressWarnings(&quot;unchecked&quot;)private E get(Object[] a, int index) &#123;    return (E) a[index];&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h3><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="1-概览-1"><a href="#1-概览-1" class="headerlink" title="1. 概览"></a>1. 概览</h3><p>基于双向链表实现，使用 Node 存储链表节点信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;    E item;    Node&lt;E&gt; next;    Node&lt;E&gt; prev;&#125;</span><br></pre></td></tr></table></figure>

<p>每个链表存储了 first 和 last 指针：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transient Node&lt;E&gt; first;transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<p><a href="https://camo.githubusercontent.com/333ccf04b7d4667fbc7c4f1a217e7e5526c400fe/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233333934303036362e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233333934303036362e706e67" alt="img"></a></p>
<h3 id="2-与-ArrayList-的比较"><a href="#2-与-ArrayList-的比较" class="headerlink" title="2. 与 ArrayList 的比较"></a>2. 与 ArrayList 的比较</h3><p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p>
<ul>
<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li>
<li>链表不支持随机访问，但插入删除只需要改变指针。</li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>为了便于理解，以下源码分析以 JDK 1.7 为主。</p>
<h3 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p>
<p><a href="https://camo.githubusercontent.com/5d81dca069e6bd97466ee40c53ea963696cfc1ef/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233343934383230352e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233343934383230352e706e67" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transient Entry[] table;static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;    final K key;    V value;    Entry&lt;K,V&gt; next;    int hash;    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;        value = v;        next = n;        key = k;        hash = h;    &#125;    public final K getKey() &#123;        return key;    &#125;    public final V getValue() &#123;        return value;    &#125;    public final V setValue(V newValue) &#123;        V oldValue = value;        value = newValue;        return oldValue;    &#125;    public final boolean equals(Object o) &#123;        if (!(o instanceof Map.Entry))            return false;        Map.Entry e = (Map.Entry)o;        Object k1 = getKey();        Object k2 = e.getKey();        if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123;            Object v1 = getValue();            Object v2 = e.getValue();            if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))                return true;        &#125;        return false;    &#125;    public final int hashCode() &#123;        return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());    &#125;    public final String toString() &#123;        return getKey() + &quot;=&quot; + getValue();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-拉链法的工作原理"><a href="#2-拉链法的工作原理" class="headerlink" title="2. 拉链法的工作原理"></a>2. 拉链法的工作原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(&quot;K1&quot;, &quot;V1&quot;);map.put(&quot;K2&quot;, &quot;V2&quot;);map.put(&quot;K3&quot;, &quot;V3&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>新建一个 HashMap，默认大小为 16；</li>
<li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</li>
<li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</li>
<li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</li>
</ul>
<p>应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p>
<p>查找需要分成两步进行：</p>
<ul>
<li>计算键值对所在的桶；</li>
<li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li>
</ul>
<p><a href="https://camo.githubusercontent.com/a7761ef5ade932ba3513693653ee65bedfa0f5db/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233353235383634332e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230383233353235383634332e706e67" alt="img"></a></p>
<h3 id="3-put-操作"><a href="#3-put-操作" class="headerlink" title="3. put 操作"></a>3. put 操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;    if (table == EMPTY_TABLE) &#123;        inflateTable(threshold);    &#125;    // 键为 null 单独处理    if (key == null)        return putForNullKey(value);    int hash = hash(key);    // 确定桶下标    int i = indexFor(hash, table.length);    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;            V oldValue = e.value;            e.value = value;            e.recordAccess(this);            return oldValue;        &#125;    &#125;    modCount++;    // 插入新键值对    addEntry(hash, key, value, i);    return null;&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private V putForNullKey(V value) &#123;    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;        if (e.key == null) &#123;            V oldValue = e.value;            e.value = value;            e.recordAccess(this);            return oldValue;        &#125;    &#125;    modCount++;    addEntry(0, null, value, 0);    return null;&#125;</span><br></pre></td></tr></table></figure>

<p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;        resize(2 * table.length);        hash = (null != key) ? hash(key) : 0;        bucketIndex = indexFor(hash, table.length);    &#125;    createEntry(hash, key, value, bucketIndex);&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123;    Entry&lt;K,V&gt; e = table[bucketIndex];    // 头插法，链表头部指向新的键值对    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);    size++;&#125;Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;    value = v;    next = n;    key = k;    hash = h;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-确定桶下标"><a href="#4-确定桶下标" class="headerlink" title="4. 确定桶下标"></a>4. 确定桶下标</h3><p>很多操作都需要先确定一个键值对所在的桶下标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int hash = hash(key);int i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>

<p><strong>4.1 计算 hash 值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final int hash(Object k) &#123;    int h = hashSeed;    if (0 != h &amp;&amp; k instanceof String) &#123;        return sun.misc.Hashing.stringHash32((String) k);    &#125;    h ^= k.hashCode();    // This function ensures that hashCodes that differ only by    // constant multiples at each bit position have a bounded    // number of collisions (approximately 8 at default load factor).    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;public final int hashCode() &#123;    return Objects.hashCode(key) ^ Objects.hashCode(value);&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.2 取模</strong></p>
<p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x   : 00010000x-1 : 00001111</span><br></pre></td></tr></table></figure>

<p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y       : 10110010x-1     : 00001111y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure>

<p>这个性质和 y 对 x 取模效果是一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y   : 10110010x   : 00010000y%x : 00000010</span><br></pre></td></tr></table></figure>

<p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;    return h &amp; (length-1);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-扩容-基本原理"><a href="#5-扩容-基本原理" class="headerlink" title="5. 扩容-基本原理"></a>5. 扩容-基本原理</h3><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>capacity</td>
<td>table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td>size</td>
<td>键值对数量。</td>
</tr>
<tr>
<td>threshold</td>
<td>size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td>
</tr>
<tr>
<td>loadFactor</td>
<td>装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 16;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;transient Entry[] table;transient int size;int threshold;final float loadFactor;transient int modCount;</span><br></pre></td></tr></table></figure>

<p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;    Entry&lt;K,V&gt; e = table[bucketIndex];    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);    if (size++ &gt;= threshold)        resize(2 * table.length);&#125;</span><br></pre></td></tr></table></figure>

<p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;    Entry[] oldTable = table;    int oldCapacity = oldTable.length;    if (oldCapacity == MAXIMUM_CAPACITY) &#123;        threshold = Integer.MAX_VALUE;        return;    &#125;    Entry[] newTable = new Entry[newCapacity];    transfer(newTable);    table = newTable;    threshold = (int)(newCapacity * loadFactor);&#125;void transfer(Entry[] newTable) &#123;    Entry[] src = table;    int newCapacity = newTable.length;    for (int j = 0; j &lt; src.length; j++) &#123;        Entry&lt;K,V&gt; e = src[j];        if (e != null) &#123;            src[j] = null;            do &#123;                Entry&lt;K,V&gt; next = e.next;                int i = indexFor(e.hash, newCapacity);                e.next = newTable[i];                newTable[i] = e;                e = next;            &#125; while (e != null);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-扩容-重新计算桶下标"><a href="#6-扩容-重新计算桶下标" class="headerlink" title="6. 扩容-重新计算桶下标"></a>6. 扩容-重新计算桶下标</h3><p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">capacity     : 00010000new capacity : 00100000</span><br></pre></td></tr></table></figure>

<p>对于一个 Key，它的哈希值 hash 在第 5 位：</p>
<ul>
<li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；</li>
<li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。</li>
</ul>
<h3 id="7-计算数组容量"><a href="#7-计算数组容量" class="headerlink" title="7. 计算数组容量"></a>7. 计算数组容量</h3><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p>
<p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mask |= mask &gt;&gt; 1    11011000mask |= mask &gt;&gt; 2    11111110mask |= mask &gt;&gt; 4    11111111</span><br></pre></td></tr></table></figure>

<p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num     10010000mask+1 100000000</span><br></pre></td></tr></table></figure>

<p>以下是 HashMap 中计算数组容量的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123;    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-链表转红黑树"><a href="#8-链表转红黑树" class="headerlink" title="8. 链表转红黑树"></a>8. 链表转红黑树</h3><p>从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。</p>
<h3 id="9-与-Hashtable-的比较"><a href="#9-与-Hashtable-的比较" class="headerlink" title="9. 与 Hashtable 的比较"></a>9. 与 Hashtable 的比较</h3><ul>
<li>Hashtable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="1-存储结构-1"><a href="#1-存储结构-1" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h3><p><a href="https://camo.githubusercontent.com/f701cb7c0c3f8cc5b5da3db85d01c57d3095fa77/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230393030313033383032342e706e67"><img src="../images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303139313230393030313033383032342e706e67" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class HashEntry&lt;K,V&gt; &#123;    final int hash;    final K key;    volatile V value;    volatile HashEntry&lt;K,V&gt; next;&#125;</span><br></pre></td></tr></table></figure>

<p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<p>Segment 继承自 ReentrantLock。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;    private static final long serialVersionUID = 2249069246763182397L;    static final int MAX_SCAN_RETRIES =        Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;    transient volatile HashEntry&lt;K,V&gt;[] table;    transient int count;    transient int modCount;    transient int threshold;    final float loadFactor;&#125;final Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>

<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final int DEFAULT_CONCURRENCY_LEVEL = 16;</span><br></pre></td></tr></table></figure>

<h3 id="2-size-操作"><a href="#2-size-操作" class="headerlink" title="2. size 操作"></a>2. size 操作</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** * The number of elements. Accessed only either within locks * or among other volatile reads that maintain visibility. */transient int count;</span><br></pre></td></tr></table></figure>

<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** * Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result. */static final int RETRIES_BEFORE_LOCK = 2;public int size() &#123;    // Try a few times to get accurate count. On failure due to    // continuous async changes in table, resort to locking.    final Segment&lt;K,V&gt;[] segments = this.segments;    int size;    boolean overflow; // true if size overflows 32 bits    long sum;         // sum of modCounts    long last = 0L;   // previous sum    int retries = -1; // first iteration isn&#x27;t retry    try &#123;        for (;;) &#123;            // 超过尝试次数，则对每个 Segment 加锁            if (retries++ == RETRIES_BEFORE_LOCK) &#123;                for (int j = 0; j &lt; segments.length; ++j)                    ensureSegment(j).lock(); // force creation            &#125;            sum = 0L;            size = 0;            overflow = false;            for (int j = 0; j &lt; segments.length; ++j) &#123;                Segment&lt;K,V&gt; seg = segmentAt(segments, j);                if (seg != null) &#123;                    sum += seg.modCount;                    int c = seg.count;                    if (c &lt; 0 || (size += c) &lt; 0)                        overflow = true;                &#125;            &#125;            // 连续两次得到的结果一致，则认为这个结果是正确的            if (sum == last)                break;            last = sum;        &#125;    &#125; finally &#123;        if (retries &gt; RETRIES_BEFORE_LOCK) &#123;            for (int j = 0; j &lt; segments.length; ++j)                segmentAt(segments, j).unlock();        &#125;    &#125;    return overflow ? Integer.MAX_VALUE : size;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-JDK-1-8-的改动"><a href="#3-JDK-1-8-的改动" class="headerlink" title="3. JDK 1.8 的改动"></a>3. JDK 1.8 的改动</h3><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p>
<p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p>
<p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** * The head (eldest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; head;/** * The tail (youngest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure>

<p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;void afterNodeInsertion(boolean evict) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess()"></a>afterNodeAccess()</h3><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last    LinkedHashMap.Entry&lt;K,V&gt; last;    if (accessOrder &amp;&amp; (last = tail) != e) &#123;        LinkedHashMap.Entry&lt;K,V&gt; p =            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;        p.after = null;        if (b == null)            head = a;        else            b.after = a;        if (a != null)            a.before = b;        else            last = b;        if (last == null)            head = p;        else &#123;            p.before = last;            last.after = p;        &#125;        tail = p;        ++modCount;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h3><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest    LinkedHashMap.Entry&lt;K,V&gt; first;    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;        K key = first.key;        removeNode(hash(key), key, null, false, true);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;    return false;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h3><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES 为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;    private static final int MAX_ENTRIES = 3;    protected boolean removeEldestEntry(Map.Entry eldest) &#123;        return size() &gt; MAX_ENTRIES;    &#125;    LRUCache() &#123;        super(MAX_ENTRIES, 0.75f, true);    &#125;&#125;public static void main(String[] args) &#123;    LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;();    cache.put(1, &quot;a&quot;);    cache.put(2, &quot;b&quot;);    cache.put(3, &quot;c&quot;);    cache.get(1);    cache.put(4, &quot;d&quot;);    System.out.println(cache.keySet());&#125;[3, 1, 4]</span><br></pre></td></tr></table></figure>

<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentCache"><a href="#ConcurrentCache" class="headerlink" title="ConcurrentCache"></a>ConcurrentCache</h3><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<p>ConcurrentCache 采取的是分代缓存：</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class ConcurrentCache&lt;K, V&gt; &#123;    private final int size;    private final Map&lt;K, V&gt; eden;    private final Map&lt;K, V&gt; longterm;    public ConcurrentCache(int size) &#123;        this.size = size;        this.eden = new ConcurrentHashMap&lt;&gt;(size);        this.longterm = new WeakHashMap&lt;&gt;(size);    &#125;    public V get(K k) &#123;        V v = this.eden.get(k);        if (v == null) &#123;            v = this.longterm.get(k);            if (v != null)                this.eden.put(k, v);        &#125;        return v;    &#125;    public void put(K k, V v) &#123;        if (this.eden.size() &gt;= size) &#123;            this.longterm.putAll(this.eden);            this.eden.clear();        &#125;        this.eden.put(k, v);    &#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统概念</title>
    <url>/archives/531663ae.html</url>
    <content><![CDATA[<h1 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h1><blockquote>
<p>  参考文献：</p>
<ul>
<li>  [1]操作系统概念（第九版） - 机械工业出版社</li>
<li>  [2]OS 课件（感谢JJM老师）</li>
</ul>
</blockquote>
<span id="more"></span>



<h1 id="第一章：简介"><a href="#第一章：简介" class="headerlink" title="第一章：简介"></a>第一章：简介</h1><h2 id="1、特权指令和非特权指令"><a href="#1、特权指令和非特权指令" class="headerlink" title="1、特权指令和非特权指令"></a>1、特权指令和非特权指令</h2><p>特权指令：不允许用户程序中直接使用的指令。例如：I/O指令、设置时钟、 置控制寄存器等指令都是特权指令。 </p>
<p>非特权指令:用户程序中所使用的指令。</p>
<h2 id="2、用户态和内核态"><a href="#2、用户态和内核态" class="headerlink" title="2、用户态和内核态"></a>2、用户态和内核态</h2><p>内核态 </p>
<ul>
<li>  能够访问所有系统资源，可以执行特权指令，可以直接操作和管理硬件设备。 </li>
<li>  操作系统内核程序运行在内核态下 </li>
<li>  使用内核栈 </li>
</ul>
<p>用户态 </p>
<ul>
<li>  只能访问属于它的存储空间和普通寄存器，只能执行普通指令。 </li>
<li>  用户程序以及操作系统核外服务程序运行在用户态下 </li>
<li>  使用用户栈</li>
</ul>
<h2 id="3、分布式系统"><a href="#3、分布式系统" class="headerlink" title="3、分布式系统"></a>3、分布式系统</h2><p>定义：物理上分开的、可能异构的、通过网络相连的一组计算机系统。</p>
<h1 id="第二章：操作系统结构"><a href="#第二章：操作系统结构" class="headerlink" title="第二章：操作系统结构"></a>第二章：操作系统结构</h1><h2 id="1、系统调用"><a href="#1、系统调用" class="headerlink" title="1、系统调用"></a>1、系统调用</h2><p>系统调用：进程和内核之间的程序接口。</p>
<ul>
<li>  系统调用的实现是在内核完成的</li>
<li>  系统调用是通过软中断向内核发出一个明确的请求，每个系统调用对应一个封装例程（wrapper routine，唯一目的就是发布系统调用）</li>
</ul>
<p>分为六大类：</p>
<p>进程控制、文件管理、设备管理、信息维护、通信、保护</p>
<h2 id="2、如何向操作系统提供参数？"><a href="#2、如何向操作系统提供参数？" class="headerlink" title="2、如何向操作系统提供参数？"></a>2、如何向操作系统提供参数？</h2><ul>
<li>  通过寄存器</li>
<li>  存在内存的块或表中，块地址再作为参数传给寄存器</li>
<li>  放在栈里面，让操作系统弹出</li>
</ul>
<p>后面两种方法不限制参数的数量和长度</p>
<h2 id="几个Linux命令"><a href="#几个Linux命令" class="headerlink" title="几个Linux命令"></a>几个Linux命令</h2><p><code>lsmod</code>：查看所有内核模块</p>
<p><code>insmod 模块名</code>：加载内核模块</p>
<p><code>rmmod 模块名（不需要.ko后缀</code>：卸载模块</p>
<p><code>dmesg</code>：查看系统启动信息</p>
<h1 id="第三章：进程"><a href="#第三章：进程" class="headerlink" title="第三章：进程"></a>第三章：进程</h1><h2 id="1、进程是什么？"><a href="#1、进程是什么？" class="headerlink" title="1、进程是什么？"></a>1、进程是什么？</h2><ul>
<li>一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。进程是操作系统进行资源分配和调度的一个独立单位。</li>
<li>正在执行中的程序 a program in execution</li>
</ul>
<p><img src="../images/image-20210120155904570.png" alt="image-20210120155904570"></p>
<blockquote>
<p>  张尧学，计算机操作系统教程，清华大学出版社</p>
</blockquote>
<p><img src="../images/image-20200626162307991.png" alt="image-20200626162307991"></p>
<h2 id="2、进程组成"><a href="#2、进程组成" class="headerlink" title="2、进程组成"></a>2、进程组成</h2><ul>
<li>代码段</li>
<li>数据段（全局变量）</li>
<li>堆（动态申请空间）</li>
<li>程序计数器（PC）</li>
<li>一组寄存器</li>
<li>栈（临时变量）</li>
</ul>
<p>示意图：</p>
<p><img src="../images/image-20210120160234236.png" alt="image-20210120160234236"></p>
<p>PCB（进程控制块）</p>
<ul>
<li>进程状态</li>
<li>程序计数器</li>
<li>CPU寄存器</li>
<li>CPU调度信息</li>
<li>内存管理信息</li>
<li>记账信息</li>
<li>IO状态信息</li>
</ul>
<h2 id="3、进程状态（5个）"><a href="#3、进程状态（5个）" class="headerlink" title="3、进程状态（5个）"></a>3、进程状态（5个）</h2><p>new、running、ready、waiting、terminated</p>
<p><img src="../images/image-20200626162734708.png" alt="image-20200626162734708"></p>
<p>一个处理器一次只能运行一个进程</p>
<p>三个基本状态之间可能转换和转换原因如下：</p>
<ul>
<li>  就绪→运行：当处理器空闲时，进程调度程序必将处理机分配给一个处于就绪状态的进程 ，该进程便由就绪状态转换为运行状态。</li>
<li>  运行→等待：处于运行状态的进程在运行过程中需要等待某一事件发生后（例如因I／O请求等待I／O完成后），才能继续运行，则该进程放弃处理器，从运行状态转换为等待状态。</li>
<li>  等待→就绪：处于等待状态的进程，若其等待的事件已经发生，于是进程由等待状态转换为就绪状态。</li>
<li>  运行→就绪：处于运行状态的进程在其运行过程中，因分给它的处理器时间片已用完，而不得不让出（被抢占）处理器，于是进程由运行态转换为就绪态。</li>
</ul>
<p>等待→运行，就绪→等待这二种状态转换一般不可能发生。</p>
<p>处于运行状态进程：如系统有一个处理器，则在任何一时刻，最多只有一个进程处于运行状态。</p>
<p>处于就绪状态进程：一般处于就绪状态的进程按照一定的算法（如先来的进程排在前面，或采用优先权高的进程排在前面）排成一个就绪队列。</p>
<p>处于等待状态进程：处于等待状态的进程排在等待队列中。由于等待事件原因不同，等待队列也可以按事件分成几个队列。</p>
<h2 id="4、进程和程序"><a href="#4、进程和程序" class="headerlink" title="4、进程和程序"></a>4、进程和程序</h2><ul>
<li>进程是动态的，程序是静态的</li>
<li>进程是暂时的，程序是永久的</li>
<li>进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程状态信息）</li>
<li>通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序</li>
</ul>
<h2 id="5、进程调度"><a href="#5、进程调度" class="headerlink" title="5、进程调度"></a>5、进程调度</h2><p>调度队列和调度程序</p>
<p>上下文切换：切换 CPU 到另外一个进程需要保存当前进程的状态，同时恢复另一个进程的状态</p>
<p>进程上下文用进程 PCB 表示</p>
<h2 id="6、进程操作"><a href="#6、进程操作" class="headerlink" title="6、进程操作"></a>6、进程操作</h2><h3 id="6-1-创建进程"><a href="#6-1-创建进程" class="headerlink" title="6.1 创建进程"></a>6.1 创建进程</h3><p><img src="../images/image-20210120162500381.png" alt="image-20210120162500381"></p>
<p>进程标识符（pid）唯一标识一个进程</p>
<p>子进程可能共享父进程的所有资源或者部分资源，或者直接不共享</p>
<p>创建新进程，可以使用 fork() 这个系统调用</p>
<ul>
<li>  子进程继承了父进程的地址空间</li>
<li>  子进程 PID 是 0，父进程的 PID 值是子进程的 PID</li>
</ul>
<h3 id="6-2-进程终止"><a href="#6-2-进程终止" class="headerlink" title="6.2 进程终止"></a>6.2 进程终止</h3><p>引起进程终止的事件：</p>
<ul>
<li>  正常结束</li>
<li>  异常结束</li>
<li>  外界干预</li>
</ul>
<p>僵尸进程：进程已经中止，但父进程未调用wait()</p>
<p>孤儿进程：父进程未调用wait()就终止了，处理方式：将init进程（1号进程）作为孤儿进程的父进程</p>
<h3 id="6-3-进程通信-Interprocess-Communication，IPC"><a href="#6-3-进程通信-Interprocess-Communication，IPC" class="headerlink" title="6.3 进程通信(Interprocess Communication，IPC)"></a>6.3 进程通信(Interprocess Communication，IPC)</h3><p>IPC为进程提供了一种无需共享相同地址空间就可以进行通信和同步操作的机制</p>
<p>两种模型：共享内存、消息传递</p>
<p><img src="../images/image-20210123094831885.png" alt="image-20210123094831885"></p>
<p>通信类型：直接通信、间接通信</p>
<p>常用通信机制：</p>
<ul>
<li>信号(signal)</li>
<li>共享存储区(shared memory)</li>
<li>管道(pipe)</li>
<li>消息(message)</li>
<li>套接字(socket)</li>
</ul>
<p>Linux实现进程间通信(IPC Inter Process Communication)：</p>
<ul>
<li><p>System V IPC机制:</p>
<ul>
<li>信号量、 消息队列、 共享内存</li>
</ul>
</li>
<li><p>管道（pipe）、命名管道 </p>
</li>
<li><p>套接字（socket）</p>
</li>
<li><p>信号( signal )</p>
</li>
<li><p>文件锁(file lock)</p>
</li>
<li><p>POSIX线程：</p>
<ul>
<li>互斥锁(互斥体、互斥量)（mutex）、条件变量(condition variables)</li>
</ul>
</li>
<li><p>POSIX：</p>
<ul>
<li>消息队列、信号量、共享内存</li>
</ul>
</li>
</ul>
<h2 id="7、IPC"><a href="#7、IPC" class="headerlink" title="7、IPC"></a>7、IPC</h2><h3 id="7-1-共享内存"><a href="#7-1-共享内存" class="headerlink" title="7.1 共享内存"></a>7.1 共享内存</h3><ul>
<li>  希望通信的进程之间共享的一块内存区域</li>
<li>  通信在用户进程的控制下，而不是操作系统的控制下。</li>
<li>  主要问题是提供一种机制，允许用户进程在访问共享内存时同步它们的操作</li>
<li>  协同进程的并发执行需要允许进程之间进行通信并同步它们的动作的机制</li>
<li>生产者-消费者问题<ul>
<li>  有界缓冲区</li>
<li>  无界缓冲区</li>
</ul>
</li>
</ul>
<h3 id="7-2-消息传递"><a href="#7-2-消息传递" class="headerlink" title="7.2 消息传递"></a>7.2 消息传递</h3><p>进程之间的通信不需要依赖共享变量</p>
<p>如果 P 和 Q 要通信，需要两步：</p>
<p>1、建立连接</p>
<p>2、交换信息</p>
<p><strong>直接通信</strong></p>
<ul>
<li>  明确说明要发给谁或者从谁接收信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">send (P, message) – send a message to process P</span><br><span class="line">receive(Q, message) – receive a message from process Q</span><br></pre></td></tr></table></figure>

<p>通信连接的特性：</p>
<ul>
<li>  连接自动建立</li>
<li>  一个链接只与一对通信进程相关联，换言之，一对通信之间只有一个链接</li>
<li>  链接可能是单向的，但通常是双向的</li>
</ul>
<p><strong>间接通信</strong></p>
<ul>
<li>  从邮箱(mailbox，也称为端口)定向和接收消息</li>
<li>  每个邮箱都有一个唯一的id</li>
<li>  进程只有在共享邮箱时才能通信</li>
</ul>
<p>通信链路的特性</p>
<ul>
<li>  仅当进程共享一个公共邮箱时才建立链接</li>
<li>  一个链接可能与许多进程相关联</li>
<li>  每一对进程可以共享几个通信链路</li>
<li>  链接可以是单向的，也可以是双向的</li>
</ul>
<h2 id="8、同步异步"><a href="#8、同步异步" class="headerlink" title="8、同步异步"></a>8、同步异步</h2><p>消息传递可以是阻塞的，也可以是非阻塞的</p>
<p><strong>阻塞</strong>被认为是<strong>同步</strong>的。</p>
<ul>
<li><p>  阻塞发送——发送方被阻塞，直到接收方接收到消息</p>
</li>
<li><p>  阻塞接收——接收者被阻塞，直到有消息可用</p>
</li>
</ul>
<p><strong>非阻塞</strong>被视为<strong>异步</strong>的</p>
<ul>
<li><p>  非阻塞发送——发送者发送消息并继续</p>
</li>
<li><p>  非阻塞接收——接收方接收到有效的消息，或空消息</p>
</li>
</ul>
<p><strong>RPC</strong></p>
<p>如同调用本地过程一样调用远程主机的过程</p>
<p><strong>管道</strong></p>
<ul>
<li>  普通管道：单向（单工）通信，标准的生产者消费者方式进行通信——生产者向管道一端写入，消费者从管道另一端读出；进程通信时管道才存在</li>
<li>  命名管道：可以双向通信，一个管道可以被多个进程使用</li>
</ul>
<h2 id="9、几个命令"><a href="#9、几个命令" class="headerlink" title="9、几个命令"></a>9、几个命令</h2><p>查看所有活动进程的详细信息：<code>ps -el</code></p>
<p><img src="../images/image-20210120161756889.png" alt="image-20210120161756889"></p>
<p>杀进程：<code>kill -9 进程号</code></p>
<p>查看文件：<code>cat 文件名</code></p>
<h1 id="第四章：线程和并发"><a href="#第四章：线程和并发" class="headerlink" title="第四章：线程和并发"></a>第四章：线程和并发</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>线程定义为进程内一个执行单元或一个可调度实体。</p>
<p>线程只拥有一点在运行中必不可省的资源（程序计数器、一组寄存器和栈），但它可与同属一个进程的其它线程共享进程拥有的全部资源。</p>
<p>通常，使用一个包含读个线程的进程更加有效</p>
<p>延伸：</p>
<ul>
<li>  线程私有的：线程ID、程序计数器、一组寄存器和栈</li>
<li>  线程共享的：代码段、数据段、其他操作系统资源</li>
</ul>
<p>资源拥有单元称为进程，调度的单位称为线程。</p>
<p>线程：</p>
<ul>
<li>  有执行状态（状态转换）</li>
<li>  不运行时保存上下文</li>
<li>  有一个执行栈</li>
<li>  有一些局部变量的静态存储</li>
<li>  可存取所在进程的内存和其他资源</li>
<li>  可以创建、撤消另一个线程</li>
</ul>
<p>线程的特点：</p>
<ul>
<li>  不拥有系统资源（只拥有少量的资源，资源是分配给进程） </li>
<li>  一个进程中的多个线程可并发执行（进程可创建线程执行同一程序的不同部分） </li>
<li>  系统开销小、切换快。（进程的多个线程都在进程的地址空间活动）</li>
</ul>
<p>优点：</p>
<ul>
<li>  <strong>创建一个新线程花费时间少</strong>（结束亦如此）</li>
<li>  <strong>两个线程的切换花费时间少</strong>（如果机器设有“存储[恢复]所有寄存器”指令，则整个切换过程用几条指令即可完成）</li>
<li>  <strong>通信方便</strong>：因为同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核</li>
<li>  <strong>适合多处理机系统</strong></li>
</ul>
<h2 id="2、线程的实现机制"><a href="#2、线程的实现机制" class="headerlink" title="2、线程的实现机制"></a>2、线程的实现机制</h2><blockquote>
<p>  了解即可</p>
</blockquote>
<p><strong>用户级线程</strong>：不依赖于OS核心（内核不了解用户线程的存在），应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程</p>
<p>调度由应用软件内部进行，通常采用非抢占式和更简单的规则，也无需用户态/核心态切换，所以速度特别快。</p>
<p>一个线程发起系统调用而阻塞，则整个进程在等待。 </p>
<p>特点：</p>
<ul>
<li>  用户线程的维护由应用进程完成；</li>
<li>  内核不了解用户线程的存在；</li>
<li>  用户线程切换不需要内核特权；</li>
<li>  用户线程调度算法可针对应用优化；</li>
<li>  一个线程发起系统调用而阻塞，则整个进程在等待。（一对多模型中）</li>
</ul>
<p><strong>内核级线程</strong>：依赖于OS核心，由内核的内部需求进行创建和撤销，用来执行一个指定的函数。一个线程发起系统调用而阻塞，不会影响其他线程。时间片分配给线程，所以多线程的进程获得更多CPU时间。</p>
<p>特点：</p>
<ul>
<li>  内核维护进程和线程的上下文信息；</li>
<li>  线程切换由内核完成；</li>
<li>  时间片分配给线程，所以多线程的进程获得更多CPU时间；</li>
<li>  一个线程发起系统调用而阻塞，不会影响其他线程的运行。</li>
</ul>
<p>并行：同时执行多个任务</p>
<p>并发：支持多个任务，并允许所有任务都有其进展</p>
<p>用户级线程和内核级线程的映射关系：</p>
<p>1、一对一：一个用户级线程对应一个内核级线程。一个线程阻塞，整个进程阻塞；不能用在多核处理器上</p>
<p>2、多对一：多个用户级线程对应一个内核级线程。内核级线程数量需要限制；允许多个线程并行运行在多处理器上；没有增加并发（内核一次只能调度一个线程）</p>
<p>3、多对多：多路复用多个用户级线程到同等数量或者数量更少的内核线程上。</p>
<p>多线程创建的策略：</p>
<p>1、同步线程：父线程创建子线程后，等到所有的子线程执行完毕，自己才继续执行（分叉-连接策略）。这里，由父线程创建的线程并发执行工作，但是父线程在这个工作完成之前无法继续。一旦每个线程完成了它的工作，它就会终止，并与父线程连接。只有在所有子线程都连接之后，父线程才恢复执行。通常，同步线程涉及线程之间的大量数据的共享。例如，父线程可以组合由子线程计算的结果。</p>
<p>2、异步线程：父线程创建子线程后，自己恢复自身的执行，这样父线程与子线程会并发执行。每个线程的运行独立于其他线程，父线程无需知道子线程何时终止。由于线程是独立的，所以线程之间通常很少有数据共享。</p>
<p><img src="../images/image-20210123113518672.png" alt="image-20210123113518672"></p>
<h2 id="3、线程池"><a href="#3、线程池" class="headerlink" title="3、线程池"></a>3、线程池</h2><p>主要思想是:在进程开始时创建一定数量的线程，并加到池中以等待工作。当服务器收到请求时，它会唤醒池内的一个线程(如果有可用线程)，并将需要服务的请求传递给它。一旦线程完成了服务，它会返回到池中再等待工作。如果池内没有可用线程，那么服务器会等待,直到有空线程为止。</p>
<p>线程池具有以下优点:</p>
<ul>
<li>  用现有线程服务请求比等待创建一个线程更快。</li>
<li>  线程池<strong>限制了任何时候可用线程的数量</strong>。这对那些不能支持大量并发线程的系统非常重要。</li>
<li>  <strong>每个线程的运行策略可定制</strong>：将要执行任务从创建任务的机制中分离出来，允许我们采用不同策略运行任务。例如，任务可以被安排在某一个时间延迟后执行,或定期执行。</li>
<li>  <strong>可以提前估算线程池大小</strong>：池内线程的数量可以通过一些因素来加以估算，如系统CPU的数量、物理内存的大小和并发客户请求数量的期望值等。更为高级的线程池架构可以根据使用模式动态调整池内线程数量。这类架构在系统负荷低时，提供了较小的池，从而减低内存消耗。</li>
</ul>
<h1 id="第五章：进程调度"><a href="#第五章：进程调度" class="headerlink" title="第五章：进程调度"></a>第五章：进程调度</h1><h2 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h2><p>CPU 调度 = 处理器调度 = 进程调度</p>
<p>单处理器系统：同一时间只有一个进程可以运行</p>
<p>多处理器系统：多个进程同时处于内存。当一个进程等待时，操作系统就从该进程接管 CPU 控制权，并把 CPU 交给另外一个进程。</p>
<p>三层调度模型：</p>
<p><img src="../images/image-20210201152812097.png" alt="image-20210201152812097"></p>
<h3 id="5-1-1-CPU-调度程序"><a href="#5-1-1-CPU-调度程序" class="headerlink" title="5.1.1 CPU 调度程序"></a>5.1.1 CPU 调度程序</h3><p>每当 CPU 空闲的时候，操作系统就应该从就绪队列中选择一个进程来执行。干这个工作的叫做 <strong>CPU 调度程序</strong>。调度程序从内存里面选择一个可以执行的进程，并为其分配 CPU</p>
<p>队列里面放的是进程控制块（PCB）</p>
<h3 id="5-1-2-什么时候需要进程调度？"><a href="#5-1-2-什么时候需要进程调度？" class="headerlink" title="5.1.2 什么时候需要进程调度？"></a>5.1.2 什么时候需要进程调度？</h3><ol>
<li> 运行状态切换到等待状态（ IO 请求）</li>
<li> 运行状态切换到就绪状态（出现中断）</li>
<li> 等待切换到就绪（IO 请求完成）</li>
<li> 进程终止</li>
</ol>
<p><img src="../images/image-20210201153740780.png" alt="image-20210201153740780"></p>
<p>调度方式：</p>
<p>非抢占式（Nonpreemptive）调度:调度程序一旦把处理器分配给某进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理器分配给另一个进程。如上1、4</p>
<p>抢占式（Preemptive）调度:当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。剥夺原则有：优先权原则、短进程优先原则、时间片原则。如上2、3</p>
<h3 id="5-1-3-Dispatcher（调度程序）"><a href="#5-1-3-Dispatcher（调度程序）" class="headerlink" title="5.1.3 Dispatcher（调度程序）"></a>5.1.3 Dispatcher（调度程序）</h3><p>是个模块，把 CPU 的控制权交给<strong>短期调度程序</strong>选择的进程</p>
<p>功能：</p>
<ul>
<li>  切换上下文</li>
<li>  切换到用户模式</li>
<li>  跳转到用户程序的合适位置，以便重新启动程序</li>
</ul>
<p>特点：尽可能快。因为每次进程切换都需要使用。</p>
<p>Dispatch latency（调度延迟） ：调度程序停止一个进程到启动一个进程所需要的时间</p>
<p>Linux命令：vmstat</p>
<h2 id="5-2-调度准则"><a href="#5-2-调度准则" class="headerlink" title="5.2 调度准则"></a>5.2 调度准则</h2><p><strong>最大化 CPU 利用率和吞吐量，最小化周转时间、等待时间和响应时间，公平！！</strong></p>
<p>周转时间Turnaround time ：进程从提交到完成所经历的时间。包括：在CPU上执行，就绪队列和阻塞队列中等待。</p>
<p>响应时间Response time ：从进程提出请求到首次被响应（而不是输出结果）的时间段（在分时系统环境下）</p>
<p>等待时间Waiting time  – 进程在就绪队列中等待的时间总和</p>
<p>公平性：不因作业或进程本身的特性而使上述指标过分恶化。如长进程等待很长时间。</p>
<p>优先级：可以使关键任务达到更好的指标</p>
<p>调度算法本身的调度性能准则</p>
<ul>
<li>  易于实现</li>
<li>  执行开销比较小</li>
</ul>
<h2 id="5-3-调度算法"><a href="#5-3-调度算法" class="headerlink" title="5.3 调度算法"></a>5.3 调度算法</h2><ul>
<li>  First-Come, First-Served (FCFS) Scheduling     <strong>先来先服务</strong>调度</li>
<li>  Shortest-Job-First (SJF) Scheduling                     <strong>短作业优先</strong>调度</li>
<li>  Priority Scheduling                                               <strong>优先权</strong>调度</li>
<li>  Round Robin (RR)                                                 <strong>时间片轮转</strong>调度</li>
<li>  Multilevel Queue Scheduling                             <strong>多级队列</strong>调度</li>
<li>  Multilevel Feedback Queue Scheduling           多级反馈队列调度</li>
<li>高响应比优先调度算法 Highest Response Ratio Next(HRRN)<ul>
<li>  响应比R = (等待时间 + 要求执行时间) / 要求执行时间</li>
</ul>
</li>
</ul>
<h3 id="5-3-1-FCFS算法"><a href="#5-3-1-FCFS算法" class="headerlink" title="5.3.1 FCFS算法"></a>5.3.1 FCFS算法</h3><ul>
<li>  按照进程或作业提交顺序形成就绪状态的先后次序，分派CPU</li>
<li>  当前进程或作业占用CPU，直到执行完或阻塞，才出让CPU（非抢占方式）</li>
<li>  在进程或作业唤醒后（如I/O完成），并不立即恢复执行，通常等到当前作业或进程出让CPU</li>
<li>  最简单的算法</li>
<li>  用一个队列就可以实现</li>
</ul>
<p>FCFS的特点</p>
<ul>
<li>比较有利于长进程，而不利于短进程。</li>
<li>有利于CPU Bound的进程，而不利于I/O Bound的进程。</li>
</ul>
<h3 id="5-3-2-SJF算法"><a href="#5-3-2-SJF算法" class="headerlink" title="5.3.2 SJF算法"></a>5.3.2 SJF算法</h3><ul>
<li>  对预计执行时间短的作业（进程）优先分派处理器</li>
<li>  最优的算法</li>
<li>  平均等待时间最小</li>
<li>  常用于长期调度</li>
</ul>
<p>SJF的变型：</p>
<ul>
<li>最短剩余时间优先<strong>SRTF</strong>(Shortest Remaining Time First)-基于抢占的SJF算法<ul>
<li>  允许比当前进程剩余时间更短的进程来抢占</li>
</ul>
</li>
<li>最高响应比优先HRRN(Highest Response Ratio Next)<ul>
<li>响应比R = (等待时间 + 要求执行时间) / 要求执行时间<br>  是FCFS和SJF的折衷</li>
</ul>
</li>
</ul>
<h3 id="5-3-3-优先权调度"><a href="#5-3-3-优先权调度" class="headerlink" title="5.3.3 优先权调度"></a>5.3.3 优先权调度</h3><p>该算法总是把处理机分配给就绪队列中具有最高优先权的进程。</p>
<p>常用以下两种方法来确定进程的优先权： </p>
<p>静态优先权: 静态优先权是在创建进程时确定的，在整个运行期间不再改变。依据有：进程类型、进程对资源的要求、用户要求的优先权。</p>
<p>动态优先权: 动态优先权是基于某种原则，使进程的优先权随时间改变而改变。</p>
<p>假定：最小的整数 = 最高的优先级.</p>
<p>SJF是以下一次CPU脉冲长度作为优先数的优先级调度</p>
<p>可以是抢占也可以非抢占</p>
<p>会产生饥饿：优先权低的进程可能永远不会被执行</p>
<ul>
<li>  解决方法：老化：随着时间推移，等待时间长的进程优先级会被提高</li>
</ul>
<h3 id="5-3-4-时间片轮转"><a href="#5-3-4-时间片轮转" class="headerlink" title="5.3.4 时间片轮转"></a>5.3.4 时间片轮转</h3><p>特点：允许抢占，平均等待时间一般较长</p>
<p>基本思路：通过时间片轮转，提高进程并发性和响应时间特性，从而提高资源利用率。</p>
<p>RR算法：</p>
<ul>
<li>  将系统中所有的就绪进程按照FCFS原则，排成一个队列。</li>
<li>  每次调度时将CPU分派给队首进程，让其执行一个时间片 (time slice) 。时间片的长度从几个ms到几百ms。</li>
<li>  在一个时间片结束时，发生时钟中断。</li>
<li>  调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程。</li>
<li>  进程可以未使用完一个时间片，就出让CPU（如阻塞）。</li>
</ul>
<p>时间片长度的影响因素：</p>
<ul>
<li>  就绪进程的数目：数目越多，时间片越小（当响应时间一定时）</li>
<li>  系统的处理能力：应当使用户输入通常在一个时间片内能处理完，否则使响应时间，平均周转时间和平均带权周转时间延长。</li>
</ul>
<p>【其他】</p>
<p>在RR调度算法中，没有进程被连续分配超过一个时间片的CPU（除非它是唯一可运行的进程）。</p>
<p>如果进程的CPU执行超过一个时间片，那么该进程会被抢占，并被放回到就绪队列。</p>
<h3 id="5-3-5-多级队列调度"><a href="#5-3-5-多级队列调度" class="headerlink" title="5.3.5 多级队列调度"></a>5.3.5 多级队列调度</h3><p>特点：引入多个就绪队列，通过各队列的区别对待，达到一个综合的调度目标</p>
<p>根据进程的性质或类型的不同，将就绪队列再分为若干个子队列。</p>
<p>每个作业固定归入一个队列。</p>
<p>各队列的不同处理：不同队列可有不同的优先级、时间片长度、调度策略等。如：系统进程、用户交互进程、批处理进程等。</p>
<p>级队列算法调度须在队列间进行</p>
<ul>
<li><p>  固定优先级调度，即前台运行完后再运行后台。有可能产生饥饿</p>
</li>
<li><p>  给定时间片调度，即每个队列得到一定的CPU时间，进程在给定时间内执行；如，80%的时间执行前台的RR调度，20%的时间执行后台的FCFS调度</p>
</li>
</ul>
<img src="../images/image-20210201160951705.png" alt="image-20210201160951705" style="zoom: 67%;" />

<h3 id="5-3-6-多级反馈队列"><a href="#5-3-6-多级反馈队列" class="headerlink" title="5.3.6 多级反馈队列"></a>5.3.6 多级反馈队列</h3><p>多级反馈队列算法是时间片轮转算法和优先级算法的综合和发展。</p>
<p>优点：</p>
<ul>
<li>  为提高系统吞吐量和缩短平均周转时间而照顾短进程</li>
<li>  为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程</li>
<li>  不必估计进程的执行时间，动态调节</li>
</ul>
<p>设置多个就绪队列，分别赋予不同的优先级，如逐级降低，队列1的优先级最高。每个队列执行时间片的长度也不同，规定优先级越低则时间片越长，如逐级加倍</p>
<p>新进程进入内存后，先投入队列1的末尾，按FCFS算法调度；若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，同样按FCFS算法调度；如此下去，降低到最后的队列，则按”时间片轮转”算法调度直到完成。</p>
<p>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢占执行新进程，并把被抢占的进程投入原队列的末尾。</p>
<img src="../images/image-20210201161158163.png" alt="image-20210201161158163" style="zoom:50%;" />

<h2 id="5-4-线程调度"><a href="#5-4-线程调度" class="headerlink" title="5.4 线程调度"></a>5.4 线程调度</h2><p>在支待线程的操作系统上，内核级线程（而不是进程）才是操作系统所调度的。用户级线程是由线程库来管理的，而内核并不知道它们。用户级线程为了运行在CPU上，最终应映射到相关的内核级线程，但是这种映射可能不是直接的，可能采用轻量级进程(LWP)。</p>
<h1 id="第六章：进程同步"><a href="#第六章：进程同步" class="headerlink" title="第六章：进程同步"></a>第六章：进程同步</h1><p>进程之间竞争资源面临三个控制问题：</p>
<ul>
<li><p>  <strong>互斥</strong>（mutual exclusion )指多个进程不能同时使用同一个资源</p>
</li>
<li><p>  <strong>死锁</strong>（deadlock )指多个进程互不相让，都得不到足够的资源。永远得不到资源</p>
</li>
<li><p>  <strong>饥饿</strong>（starvation )指一个进程长时间得不到资源（其他进程可能轮流占用资源）。资源分配不公平</p>
</li>
</ul>
<h2 id="6-1-临界区问题"><a href="#6-1-临界区问题" class="headerlink" title="6.1 临界区问题"></a>6.1 临界区问题</h2><p>每个进程有一段代码，称为临界区(critical section) ，进程在执行该区时可能修改公共变量、更新一个表、写一个文件等。</p>
<p>当一个进程在临界区内执行时，其他进程不允许在它们的临界区内执行。也就是说，没有两个进程可以在它们的临界区内同时执行。</p>
<p>临界区问题(critical-section problem)是，设计一个协议以便协作进程。在进入临界区前，每个进程应请求许可。实现这一请求的代码区段称为进入区(entry section) 。临界区之后可以有退出区(exit section) ，其他代码为剩余区(remainder section) 。</p>
<p>临界资源：一次只允许一个进程使用(访问)的资源。如：硬件打印机、磁带机等，软件的消息缓冲队列、变量、数组、缓冲区等。</p>
<p>临界区：访问临界资源的那段代码</p>
<p>必须满足的要求：</p>
<ul>
<li>  互斥</li>
<li>  空闲让进</li>
<li>  有限等待</li>
</ul>
<h2 id="6-2-锁"><a href="#6-2-锁" class="headerlink" title="6.2 锁"></a>6.2 锁</h2><h3 id="6-2-1-互斥锁"><a href="#6-2-1-互斥锁" class="headerlink" title="6.2.1 互斥锁"></a>6.2.1 互斥锁</h3><p>一个进程在进入临界区时应得到锁；它在退出临界区时释放锁</p>
<p>当一个进程试图获取不可用的锁时，它会阻塞，直到锁被释放</p>
<h3 id="6-2-2-自旋锁-spinlock"><a href="#6-2-2-自旋锁-spinlock" class="headerlink" title="6.2.2 自旋锁 spinlock"></a>6.2.2 自旋锁 spinlock</h3><p>是一个与共用数据结构有关的锁定机制。特殊形式的互斥锁</p>
<p>储存在共用内存中。为了速度和使用任何在处理器体系下提供的锁定机构，获取和释放自旋锁的代码是用汇编语言写的。</p>
<p>当线程试图获得自旋锁时，在处理器上所有其它工作将终止。因此<strong>拥有自旋锁的线程永远不会被抢占</strong>，但允许它继续执行以便使它尽快把锁释放。内核对于使用自旋锁十分小心，当它拥有自旋锁时，它执行的指令数将减至最少。</p>
<p>【优点】：当进程在等待锁时，没有上下文切换（上下文切换可能需要相当长的时间） 。</p>
<p>因此，当使用锁的时间较短时，自旋锁还是有用的。自旋锁通常用于多处理器系统，一个线程可以在一个处理器上“旋转＂，而其他线程在其他处理器上执行临界区。</p>
<h2 id="6-3-信号量"><a href="#6-3-信号量" class="headerlink" title="6.3 信号量"></a>6.3 信号量</h2><p>整形变量，只能 wait( ）和signal( ），原子性操作，当 S &lt;= 0 的时候，进程必须等待</p>
<p>通常用信号量表示资源或临界区</p>
<p>信号量的物理含义  </p>
<ul>
<li><p>  <code>S.value &gt;0</code> 表示有 <code>S.value</code> 个资源可用； </p>
</li>
<li><p>  <code>S.value=0</code>  表示无资源可用或表示不允许进程再进入临界区； </p>
</li>
<li><p>  <code>S.value&lt;0</code>  则 <code>|S.value|</code> 表示在等待队列中进程的个数或表示等待进入临界区的进程个数。 </p>
</li>
</ul>
<p>wait(S) ≡ P(S) ≡ down(S)  ： 表示申请一个资源</p>
<p>signal(S) ≡ V(S) ≡ up(S)   ： 表示释放一个资源</p>
<p>分类：</p>
<ul>
<li>  整型信号量</li>
<li>  记录型信号量</li>
<li>  AND型信号量</li>
<li>  二值信号量</li>
</ul>
<p>二值信号量类似互斥锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex;    <span class="comment">//  initialized to 1</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	wait (mutex);</span><br><span class="line">         <span class="comment">// Critical Section</span></span><br><span class="line">     signal (mutex);</span><br><span class="line">		<span class="comment">// remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (TRUE);</span><br></pre></td></tr></table></figure>



<p>计数信号量可以用于控制访问具有多个实例的某种资源。</p>
<p>1、信号量的初值为可用资源数量。</p>
<p>2、当进程需要使用资源时，需要对该信号扯执行wait( ）操作。</p>
<p>3、当进程释放资源时，需要对该信号最执行signal( ）操作。</p>
<p>4、当信号量的计数为0 时，所有资源都在使用中。之后，需要使用资源的进程将会阻塞，直到计数大于0 。</p>
<p>【信号量的实现】</p>
<p>当一个进程执行 P 操作并且发现信号量不为正时，它必须等待。然而，该进程不是忙等待而是阻塞自己 block()。阻塞操作将一个进程放到与信号量相关的等待队列中，并且将该进程状态切换成等待状态。然后，控制转到CPU 调度程序，以便选择执行另一个进程。</p>
<p>等待信号量 S 而阻塞的进程，在其他进程执行操作signal( ）后，应被重新执行。进程的重新执行是通过操作 wakeup( ）来进行的，它将进程从等待状态改为就绪状态。然后，进程被添加到就绪队列</p>
<p>wait、signal操作必须成对出现，有一个wait操作就一定有一个signal操作。一般情况下：当为互斥操作时，它们同处于同一进程；当为同步操作时，则不在同一进程中出现。 </p>
<p>如果两个wait操作相邻，那么它们的顺序至关重要，而两个相邻的signal操作的顺序无关紧要。一个同步wait操作与一个互斥wait操作在一起时，同步wait操作在互斥wait操作前。 </p>
<p>wait、signal操作的优缺点 </p>
<p>优点：简单，而且表达能力强 </p>
<p>缺点：不够安全；wait、signal操作使用不当会出现死锁；实现复杂。 </p>
<h2 id="6-4-经典同步问题"><a href="#6-4-经典同步问题" class="headerlink" title="6.4 经典同步问题"></a>6.4 经典同步问题</h2><ul>
<li>  生产者消费者问题（有界缓冲区问题）</li>
<li>  读者写者问题</li>
<li>  哲学家就餐问题</li>
</ul>
<p>生产者-消费者问题是最著名的同步问题，它描述一组生产者（P1  ……Pm）向一组消费者（C1……Cq）提供消息。它们共享一个有限缓冲池（bounded buffer pool）,生产者向其中投放消息，消费者从中取得消息。</p>
<p>生产者-消费者问题是许多相互合作进程的一种抽象。</p>
<p>读者写者</p>
<p>一个数据集（如文件）如果被几个并行进程所共享：</p>
<ul>
<li><p>  有些进程只要求读数据集内容，它称读者</p>
</li>
<li><p>  一些进程则要求修改数据集内容，它称写者</p>
</li>
<li><p>  几个读者可以同时读些数据集，而不需要互斥</p>
</li>
<li><p>  一个写者不能和其它进程（不管是写者或读者）同时访问些数据集，它们之间必须互斥。</p>
</li>
</ul>
<p>当写者写入数据时，独占数据库</p>
<p>【问题变种】</p>
<ul>
<li>第一读者写者问题<ul>
<li>  读者进程不应等待，除非数据库被另一个进程使用</li>
</ul>
</li>
<li>第二读者写者问题<ul>
<li>  一旦写者进程就绪，那么写者进程就必须尽可能快被执行</li>
</ul>
</li>
</ul>
<p>哲学家就餐问题</p>
<p>多个进程之间分配多个资源，并且不会产生饥饿和死锁。</p>
<p>为了避免死锁，把哲学家分为三种状态：思考、饥饿、吃饭，并且一次拿到两只筷子，否则不拿。（Dijkstra）</p>
<h2 id="6-5-管程"><a href="#6-5-管程" class="headerlink" title="6.5 管程"></a>6.5 管程</h2><p>管程的定义：管程是关于共享资源的数据结构及一组针对该资源的操作过程所构成的软件模块。</p>
<p>管程是管理进程间同步的机制，它保证进程互斥地访问共享变量，并方便地阻塞和唤醒进程。</p>
<p>管程可以函数库的形式实现。相比之下，管程比信号量好控制</p>
<p>主要特性：</p>
<ul>
<li><p>  模块化：一个管程是一个基本程序单位，可以单独编译；</p>
</li>
<li><p>  抽象数据类型：管程是一种特殊的数据类型，其中不仅有数据，而且有对数据进行操作的代码</p>
</li>
<li><p>  信息封装：管程是半透明的，管程中的外部过程（函数）实现了某些功能，至于这些功能是怎样实现的，在其外部则是不可见的；</p>
</li>
</ul>
<p>实现要素：</p>
<ul>
<li><p>  管程中的共享变量在管程外部是不可见的，外部只能通过调用管程中所说明的外部过程（函数）来间接地访问管程中的共享变量；</p>
</li>
<li><p>  为了保证管程共享变量的数据完整性，规定管程互斥进入；</p>
</li>
<li><p>  管程通常是用来管理资源的，因而在管程中应当设有进程等待队列以及相应的等待及唤醒操作；</p>
</li>
</ul>
<p>组成：</p>
<ul>
<li><p>  名称：为每个共享资源设立一个管程</p>
</li>
<li><p>  数据结构说明：一组局部于管程的控制变量</p>
</li>
<li><p>  操作原语：对控制变量和临界资源进行操作的一组原语过程（程序代码），是访问该管程的唯一途径。这些原语本身是互斥的，任一时刻只允许一个进程去调用，其余需要访问的进程就等待。</p>
</li>
<li><p>  初始化代码：对控制变量进行初始化的代码</p>
</li>
</ul>
<p>由于管程通常是用于管理资源的，因而在管程内部，应当存在某种等待机制。当进入管程的进程因资源被占用等原因不能继续运行时使其等待。为此在管程内部可以说明和使用一种特殊类型的变量—-<strong>条件变量</strong>。</p>
<p>每个条件变量表示一种等待原因，并不取具体数值－－相当于每个原因对应一个队列。</p>
<h1 id="第七章：死锁"><a href="#第七章：死锁" class="headerlink" title="第七章：死锁"></a>第七章：死锁</h1><h2 id="7-1-概念"><a href="#7-1-概念" class="headerlink" title="7.1 概念"></a>7.1 概念</h2><p>死锁：指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进</p>
<p>四个必要条件：</p>
<p>1、互斥：一个资源同一时间只能被一个进程使用</p>
<p>2、Hold and wait（占有并等待、请求和保持）：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已经获得的其它资源保持不放</p>
<p>3、不可抢占、不剥夺：已有的资源不能被抢占</p>
<p>4、循环等待</p>
<h2 id="7-2-处理策略"><a href="#7-2-处理策略" class="headerlink" title="7.2 处理策略"></a>7.2 处理策略</h2><p>简单讲：预防、避免、检测、解除、装死看不到</p>
<p>大体分三种：</p>
<p>1、通过协议来预防或避免死锁，确保系统不会进入死锁状态。打破死锁的必要条件，一般是限制申请资源来解决，或者运行抢占资源，再比如就是进程有序申请资源</p>
<p>2、可以允许系统进入死锁状态，然后检测它，并加以恢复。</p>
<p>3、可以忽视这个问题，认为死锁不可能在系统内发生（如果发生了，程序员自己解决）</p>
<h2 id="7-3-死锁避免算法"><a href="#7-3-死锁避免算法" class="headerlink" title="7.3 死锁避免算法"></a>7.3 死锁避免算法</h2><h3 id="7-3-1-资源分配图算法"><a href="#7-3-1-资源分配图算法" class="headerlink" title="7.3.1 资源分配图算法"></a>7.3.1 资源分配图算法</h3><p>算法：假设进程Pi申请资源Rj。只有在需求边Pi –&gt; Rj 变成分配边 Rj –&gt; Pi 而不会导致资源分配图形成环时，才允许申请。</p>
<p>用算法循环检测，如果没有环存在，那么资源分配会使系统处于安全状态。如果存在环，资源分配会使系统不安全。进程Pi必须等待。</p>
<h3 id="7-3-2-银行家算法"><a href="#7-3-2-银行家算法" class="headerlink" title="7.3.2 银行家算法"></a>7.3.2 银行家算法</h3><p>Dijkstra 提出的</p>
<h2 id="7-4-死锁检测"><a href="#7-4-死锁检测" class="headerlink" title="7.4 死锁检测"></a>7.4 死锁检测</h2><p>死锁检测</p>
<p>死锁恢复</p>
<ul>
<li>终止进程<ul>
<li>  终止所有死锁的进程</li>
<li>  一次终止一个进程，直到消除死锁循环为止</li>
</ul>
</li>
<li>允许资源抢占<ul>
<li>  选择牺牲进程</li>
<li>  回滚牺牲的进程</li>
<li>  饥饿避免（不能总牺牲同一个）</li>
</ul>
</li>
</ul>
<h1 id="第八章：内存管理"><a href="#第八章：内存管理" class="headerlink" title="第八章：内存管理"></a>第八章：内存管理</h1><h2 id="8-1-背景"><a href="#8-1-背景" class="headerlink" title="8.1 背景"></a>8.1 背景</h2><p>操作系统的主要目的是执行程序，在执行时，这些程序及其访问的数据应该至少部分在内存中。</p>
<p>内存是现代计算机运行的核心 。 内存由一个很大的字节数组来组成， 每个字节都有各自的地址。 CPU 根据程序计数器的值从内存中提取指令，这些指令可能引 起对特定内存地址的额外加载与存储。 </p>
<p>CPU 可以直接访问的通用存储只有<strong>内存</strong>和处理器<strong>内置的寄存器</strong>。 机器指令可以用内存地址作为参数，而不能用磁盘地址作为参数。 因此，执行指令以及指令使用的数据，应处在这些可直接访问的存储设备上。 如果数据不在内存中，那么在 CPU 使用它们之前应先把数据移到内存。 </p>
<p>CPU 内置寄存器通常可以在一个 CPU 时钟周期内完成访问。对千寄存器的内容，大多数 CPU 可以在一个时钟周期内解释并执行一条或多条指令。而对于内存（它可通过内存总线的事务来访问），就不行了。完成内存的访问可能需要多个 CPU 时钟周期。在这种情况下，由于没有数据以便完成正在执行的指令，CPU 通常需要暂停(stall)。由于内存访问的频繁，这种情况是无法容忍的。补救措施是在 CPU 与内存之间，通常是在 CPU 芯片上，增加更快的内存；这称为高速缓存(cache)</p>
<p><img src="../images/image-20210210141158021.png" alt="image-20210210141158021"></p>
<p>确保每个进程都有一个单独的内存空间。 单独的进程内存空间可以保护 进程而不互相影响</p>
<p>基地址寄存器(base register) 含有最小的合法的物理内存地址，而界限地址寄存器 (limit register) 指定了范围的大小。 </p>
<p><img src="../images/image-20210210140936759.png" alt="image-20210210140936759"></p>
<p>内存空间保护的实现是通过 CPU 硬件对在用户模式下产生的地址与寄存器的地址进行比较来完成的</p>
<p>只有操作系统可以通过特殊的特权指令，才能加载基地址寄存器和界限地址寄存器。</p>
<h3 id="8-1-1-绝对地址和相对地址"><a href="#8-1-1-绝对地址和相对地址" class="headerlink" title="8.1.1 绝对地址和相对地址"></a>8.1.1 绝对地址和相对地址</h3><p>Logical address（逻辑地址，相对地址，虚地址）</p>
<ul>
<li><p>用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式。</p>
</li>
<li><p>首地址为0，其余指令中的地址都相对于首地址来编址。</p>
</li>
<li><p>不能用逻辑地址在内存中读取信息。</p>
</li>
</ul>
<p>Physical address （物理地址，绝对地址，实地址）</p>
<ul>
<li>内存中存储单元的地址。</li>
<li>物理地址可直接寻址</li>
</ul>
<p>从虚拟地址到物理地址的运行时映射是由内存管理单元 (Memory-Management Unit, MMU ) 的硬件设备来完成。</p>
<h2 id="8-1-2-动态加载和动态链接"><a href="#8-1-2-动态加载和动态链接" class="headerlink" title="8.1.2 动态加载和动态链接"></a>8.1.2 动态加载和动态链接</h2><p> 采用动态加载时，一个程序只有在调用时才会加载。所有程序都以 可重定位加载格式保存在磁盘上。</p>
<p>程序执行步骤：</p>
<p>1、主程序被加载到内存，并执行。 </p>
<p>2、当一个程序需要调用另一 个程序时，调用程序首先检查另一个程序是否已加载。 如果没有，可重定位链接程序会加 载所需的程序到内存，并更新程序的地址表以反映这一变化。 </p>
<p>3、控制传递给新加载的 程序。</p>
<p>优点：只有一个程序被需要时，它才会被加载；</p>
<p>在内核模式下执行的操作系统可以无限制地访问操作系统及用户的内存。 </p>
<p>1、加载用户程序到用户内存</p>
<p>2、转储出现错误的程序</p>
<p>3、访问和修改系统调用的参数</p>
<p>4、执行用户内存的 IO</p>
<p>5、提供许多其他服务等</p>
<h2 id="8-2-Swapping（交换技术）"><a href="#8-2-Swapping（交换技术）" class="headerlink" title="8.2 Swapping（交换技术）"></a>8.2 Swapping（交换技术）</h2><p>进程必须在内存中以便执行。不过，进程可以暂时从内存交换(swap)到备份存储(backing store)，当再次执行时再调回到内存中。</p>
<p>交换有可能让所有进程的总的物理地址空间超过真实系统的物理地址空间，</p>
<p>如果我们想要换出一个进程，那么应确保该进程是完全处于空闲的。</p>
<p>一个常用的变种是(UNIX, Linux, and Windows)：</p>
<p>正常情况下，禁止交换；</p>
<p>当空闲内存（未被操作系统或进程使用的内存）低千某个阙值时，启用交换。</p>
<p>当空闲内存的数量增加了，就停止交换。</p>
<p>另一变种是交换进程的部分（而不是整个进程），以降低交换时间。</p>
<p>移动系统不支持交换，Flash memory based：</p>
<ul>
<li><p>小空间</p>
</li>
<li><p>闪存写次数限制</p>
</li>
<li><p>在移动平台上闪存和 CPU 之间的吞吐量很低</p>
</li>
</ul>
<p>iOS要求应用程序自愿放弃分配的内存</p>
<ul>
<li><p>只读数据从系统中直接删除，已修改数据不会被删除</p>
</li>
<li><p>OS可以终止任何未能释放足够空间的应用</p>
</li>
</ul>
<p>Android如果空闲内存不足，会终止应用程序，但首先会将应用程序状态写入闪存，以便快速重启</p>
<h2 id="8-3-连续内存分配"><a href="#8-3-连续内存分配" class="headerlink" title="8.3 连续内存分配"></a>8.3 连续内存分配</h2><p>内存通常分为两个区域：一个用于驻留操作系统，另一个用于用户进程。</p>
<p>操作系统可以放在低内存，也可放在高内存。影响这一决定的主要因素是中断向量的位置。由于中断向量通常位于低内存，因此程序员通常将操作系统也放在低内存</p>
<p>在采用连续内存分配 (contiguous memory allocation) 时， 每个进程位于一个连续的内存区域，与包含下一个进程的内存相连</p>
<h3 id="8-3-1-内存保护"><a href="#8-3-1-内存保护" class="headerlink" title="8.3.1 内存保护"></a>8.3.1 内存保护</h3><p>重定位寄存器、界限寄存器</p>
<p> MMU 通过动态地将逻辑地址加上重定位寄存器的值，来进行映射。 映射后的地址再发送到内存</p>
<p><img src="../images/image-20210210145915125.png" alt="image-20210210145915125"></p>
<h3 id="8-3-2-内存分配"><a href="#8-3-2-内存分配" class="headerlink" title="8.3.2 内存分配"></a>8.3.2 内存分配</h3><p>多分区分配</p>
<p>分区式管理的基本思想是将内存划分成若干个连续区域，称为分区。每个分区只能存放一个进程。 </p>
<ul>
<li><p>fixed partitioning（固定分区）：分区大小固定</p>
</li>
<li><p>Dynamic Partitions（动态分区）：在程序装入内存时把可用内存“切出”一个连续的区域分配给该进程，且分区大小正好适合进程的需要。操作系统维护已分配分区和空闲分区的信息</p>
</li>
</ul>
<p>动态存储分区问题（Dynamic Storage-Allocation Problem）</p>
<p>1、首次适应（First-fit）：分配首个足够大的孔。查找可以从头开始，也可以从上次首次适应结束时开始。一旦找到足够大的空闲孔，就可以停止。 </p>
<p>2、最优适应（Best-fit）：分配最小的足够大的孔。 应查找整个列表</p>
<p>3、最差适应（Worst-fit）：分配最大的孔。 应查找整个列表</p>
<p>4、Next-fit：类似首次适应，每次分区时，查找都从上次结束的地方开始</p>
<p>首次适应和最优适应在执行时间和利用空间方面都好于最差适应。 </p>
<p>首次适应和最优适应在利用空间方面难分伯仲，但是首次适应要更快些。</p>
<h3 id="8-3-3-碎片（Fragmentation）"><a href="#8-3-3-碎片（Fragmentation）" class="headerlink" title="8.3.3 碎片（Fragmentation）"></a>8.3.3 碎片（Fragmentation）</h3><p>首次适应和最优适应算法都有外部碎片 </p>
<p>外部碎片问题的一种解决方法是紧缩 ( compaction) 。 它的目的是移动内存内容，以便将所有空闲空间合并成一整块。 </p>
<p>外部碎片化问题的另一个可能的解决方案是：允许进程的逻辑地址空间是不连续的；这样，只要有物理内存可用，就允许为进程分配内存。 有两种互补的技术可以实现这个解决方 案：分段和分页</p>
<p>内部碎片 (internal fragmentation)，这部分内存在分区内部，但又不能用</p>
<h2 id="8-4-分段"><a href="#8-4-分段" class="headerlink" title="8.4 分段"></a>8.4 分段</h2><p>逻辑地址空间是由一组段构成。每个段都有名称和长度。</p>
<p>地址指定了段名称和段内偏移。因此用户通过两个量来指定地址：段名称和段偏移。</p>
<p>为了实现简单起见，段是编号的，是通过段号而不是段名称来引用。因此，逻辑地址由有序对组成：</p>
<p><code>＜段号s，段偏移d＞</code></p>
<p>通常，在编译用户程序时，编译器会根据输入程序来自动构造段。</p>
<p> 段表的每个条目都有段基地址 (segment base) 和段界限 (segment limit) 。 段基地址包含该段在内存中的开始物理地址，而 段界限指定该段的长度。</p>
<h2 id="8-5-分页"><a href="#8-5-分页" class="headerlink" title="8.5 分页"></a>8.5 分页</h2><p>物理内存分为固定大小的块，称为帧(size is power of 2, between 512 bytes and 8,192 bytes)</p>
<ul>
<li>Linux 、Windows for x86: 4K</li>
<li>查看命令 <code>getconf PAGESIZE</code></li>
</ul>
<p>逻辑内存也分为同样大小的块，称为页</p>
<p>跟踪所有的空闲帧</p>
<p>设置一个页表来将逻辑地址转换为物理地址</p>
<p>页码作为页表的索引 。 页表包含每页所在物理内存的基地址。 这个基地址与页偏移的组合就形成了物理内存地址，可发送到物理单元</p>
<p>有内碎片（可能用不完）</p>
<p>如果进程大小与页大小无关，那么每个进程的内部碎片的均值为半页 。 </p>
<p>分页允许我们使用的物理内存大于 CPU 地址指针可访问的空间 。</p>
<p>TLB 与页表一起使用的方法如下： </p>
<p>TLB 只包含少数的页表条目 。 当 CPU 产生一个逻辑 地址后，它的页码就发送到 TLB。 如果找到这个页码，它的帧码也就立即可用，可用于访 问内存。 </p>
<p>如果页码不在 TLB 中（称为 TLB 未命中 (TLB miss ) ），那么就需访问页表。 取决于 CPU,，这可能由硬件自动处理或通过操作系统的中断来处理。</p>
<p>当得到帧码后，就可以用它们来访间内存。 另外，将页码和帧码添加到 TLB,，这样下次再用时就可很快查找到；如果 TLB 内的条目已满，那么会选择一个来替换</p>
<h1 id="第九章：虚拟内存管理"><a href="#第九章：虚拟内存管理" class="headerlink" title="第九章：虚拟内存管理"></a>第九章：虚拟内存管理</h1><h2 id="9-1-Demand-paging-（请求调页，按需调页，请求页式管理）"><a href="#9-1-Demand-paging-（请求调页，按需调页，请求页式管理）" class="headerlink" title="9.1 Demand paging （请求调页，按需调页，请求页式管理）"></a>9.1 Demand paging （请求调页，按需调页，请求页式管理）</h2><p>仅在需要时才加载页面</p>
<p>有效-无效位方案：当该位被设置为“有效”时，相关联的 页面是合法的，并且在内存中 。 当该位被设置为“无效”时，页面无效（ 即不在进程的逻辑 地址空间中），或有效但只在磁盘上。 对千已调入内存的页面，它的页表条目是照常设置的； 但是对于不在内存的页面，它的页表条目可简单标记为无效，或者包含磁盘上的页面地址。 </p>
<p><img src="../images/image-20210210154135243.png" alt="image-20210210154135243"></p>
<p>对标记为无效的页面访问会产生缺页错误(page fault)。</p>
<p>分页硬件在通过页表转换地址时会注意到无效位被设置，从而陷入操作系统。这种陷阱是由于操作系统未能将所需的页面调入内存引起的。处理这种缺页错误的程序很简单：</p>
<p>1．检查这个进程的内部表，以确定该引用是有效的还是无效的内存访问。</p>
<p>2．如果引用无效，那么终止进程。如果引用有效但是尚未调入页面，那么现在就应调入。</p>
<p>3．找到一个空闲帧（例如，从空闲帧链表上得到一个）。</p>
<p>4．调度一个磁盘操作，以将所需页面读到刚分配的帧。</p>
<p>5．当磁盘读取完成时，修改进程的内部表和页表，以指示该页现在处于内存中。</p>
<p>6．重新启动被陷阱中断的指令。</p>
<p>该进程现在能访问所需的页面，就好像它总是在内存中。</p>
<p>在任何情况下，缺页错误的处理时间有三个主要组成部分：</p>
<p>1、处理缺页错误中断。</p>
<p>2、读入页面。</p>
<p>3、重新启动进程</p>
<h2 id="9-2-写时复制-copy-on-write"><a href="#9-2-写时复制-copy-on-write" class="headerlink" title="9.2 写时复制 (copy-on-write)"></a>9.2 写时复制 (copy-on-write)</h2><p>允许父进程和子进程最初共享相同的页面来工作。</p>
<p> 这些共享页面标记为写时复制，这意味着如果任何一个进程<strong>写入共享页面</strong>，那么就创建共享页面的副本</p>
<p>当使用写时复制技术时，仅复制任何一进程修改的页面，所有未修改的页面可以由父进程和子进程共享。</p>
<p>还要注意，只有可以修改的页面才需要标记为写时复制。不能修改的页面（包含可执行代码的页面）可以由父进程和子进程共享。</p>
<p><img src="../images/image-20210210154730349.png" alt="image-20210210154730349"></p>
<p>可以使用池化技术</p>
<h2 id="9-3-页面置换"><a href="#9-3-页面置换" class="headerlink" title="9.3 页面置换"></a>9.3 页面置换</h2><p>步骤：</p>
<p>1、找到所需页面的磁盘位置。</p>
<p>2、找到一个空闲帧：</p>
<p>​    a．如果有空闲帧，那么就使用它。</p>
<p>​    b．如果没有空闲帧，那么就使用页面置换算法来选择一个牺牲帧(victim frame)。</p>
<p>​    c.     将牺牲帧的内容写到磁盘上，修改对应的页表和帧表。</p>
<p>3、将所需页面读入（新的）空闲帧，修改页表和帧表。</p>
<p>4、从发生缺页错误位置，继续用户进程。</p>
<p><strong>有关算法：</strong></p>
<ul>
<li><p>First-In-First-Out Algorithm (FIFO，先进先出算法) </p>
</li>
<li><p>Optimal Algorithm （OPT，最佳页面置换算法）：置换最长时间不会使用的页面</p>
</li>
<li><p>Least Recently Used (LRU) Algorithm (最近最久使用算法) </p>
</li>
<li><p>LRU Approximation Algorithms （近似LRU算法） ：</p>
<ul>
<li><p>Additional-Reference-Bits Algorithm</p>
</li>
<li><p>Second-Chance（clock） Algorithm</p>
</li>
<li><p>Enhanced Second-Chance  Algorithm</p>
</li>
</ul>
</li>
<li><p>Counting-Base Page Replacement：</p>
<ul>
<li><p>Least Frequently Used Algorithm (LFU，最不经常使用算法）</p>
</li>
<li><p>Most Frequently Used Algorithm (MFU，最经常使用算法)</p>
</li>
</ul>
</li>
</ul>
<p>Page Buffering Algorithm（页面缓冲算法）</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
</search>
