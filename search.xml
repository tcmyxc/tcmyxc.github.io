<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lua 编译</title>
    <url>/archives/41ff62c0.html</url>
    <content><![CDATA[<h1 id="一、环境以及安装包"><a href="#一、环境以及安装包" class="headerlink" title="一、环境以及安装包"></a>一、环境以及安装包</h1><h2 id="1-1-环境以及安装包"><a href="#1-1-环境以及安装包" class="headerlink" title="1.1 环境以及安装包"></a>1.1 环境以及安装包</h2><ul>
<li>gcc 编译环境（本人选择TDM-GCC9.2.0，<a href="https://jmeubank.github.io/tdm-gcc/">下载链接</a>）</li>
<li>Lua 源代码（本人选择 <a href="http://www.lua.org/ftp/">lua-5.3.6</a>）</li>
</ul>
<span id="more"></span>

<h2 id="1-2-安装前的准备工作"><a href="#1-2-安装前的准备工作" class="headerlink" title="1.2 安装前的准备工作"></a>1.2 安装前的准备工作</h2><ul>
<li>将 TDM-GCC 的 bin 目录添加到环境变量</li>
<li>进入 TDM-GCC 的 bin 目录，将 <code>把 mingw32-make.exe</code> 复制一份并修改为改为 <code>make.exe</code>，如下图：<br><img src="../images/20210219211832365.png" alt="在这里插入图片描述"></li>
<li>验证 GCC 环境，输出如下<br><img src="../images/20210219212048248.png" alt="在这里插入图片描述"></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=C:/TDM-GCC-64/bin/../libexec/gcc/x86_64-w64-mingw32/9.2.0/lto-wrapper.exe</span><br><span class="line">Target: x86_64-w64-mingw32</span><br><span class="line">Configured with: ../../../src/gcc-git-9.2.0/configure --build=x86_64-w64-mingw32 --enable-targets=all --enable-languages=ada,c,c++,fortran,lto,objc,obj-c++ --enable-libgomp --enable-lto --enable-graphite --enable-cxx-flags=-DWINPTHREAD_STATIC --disable-build-with-cxx --disable-build-poststage1-with-cxx --enable-libstdcxx-debug --enable-threads=posix --enable-version-specific-runtime-libs --enable-fully-dynamic-string --enable-libstdcxx-threads --enable-libstdcxx-time --with-gnu-ld --disable-werror --disable-nls --disable-win32-registry --enable-large-address-aware --disable-rpath --disable-symvers --prefix=/mingw64tdm --with-local-prefix=/mingw64tdm --with-pkgversion=tdm64-1 --with-bugurl=http://tdm-gcc.tdragon.net/bugs</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 9.2.0 (tdm64-1)</span><br><span class="line"></span><br><span class="line">&gt;g++ -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=g++</span><br><span class="line">COLLECT_LTO_WRAPPER=C:/TDM-GCC-64/bin/../libexec/gcc/x86_64-w64-mingw32/9.2.0/lto-wrapper.exe</span><br><span class="line">Target: x86_64-w64-mingw32</span><br><span class="line">Configured with: ../../../src/gcc-git-9.2.0/configure --build=x86_64-w64-mingw32 --enable-targets=all --enable-languages=ada,c,c++,fortran,lto,objc,obj-c++ --enable-libgomp --enable-lto --enable-graphite --enable-cxx-flags=-DWINPTHREAD_STATIC --disable-build-with-cxx --disable-build-poststage1-with-cxx --enable-libstdcxx-debug --enable-threads=posix --enable-version-specific-runtime-libs --enable-fully-dynamic-string --enable-libstdcxx-threads --enable-libstdcxx-time --with-gnu-ld --disable-werror --disable-nls --disable-win32-registry --enable-large-address-aware --disable-rpath --disable-symvers --prefix=/mingw64tdm --with-local-prefix=/mingw64tdm --with-pkgversion=tdm64-1 --with-bugurl=http://tdm-gcc.tdragon.net/bugs</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 9.2.0 (tdm64-1)</span><br><span class="line"></span><br><span class="line">&gt;make -v</span><br><span class="line">GNU Make 3.82.90</span><br><span class="line">Built <span class="keyword">for</span> i686-pc-mingw32</span><br><span class="line">Copyright (C) 1988-2012 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br></pre></td></tr></table></figure>

<h1 id="二、编译"><a href="#二、编译" class="headerlink" title="二、编译"></a>二、编译</h1><ul>
<li><p>将下载的源代码解压</p>
</li>
<li><p>进入源代码根目录，也就是 <code>lua-5.3.6</code> 目录下</p>
</li>
<li><p>按住 <code>shift</code> 键的同时点击鼠标右键，选择 <code>在此处打开 PowerShell 窗口</code></p>
</li>
<li><p>输入 <code>make mingw</code><br><img src="../images/2021021921314179.png" alt="在这里插入图片描述"><br><img src="../images/20210219213212429.png" alt="在这里插入图片描述"></p>
</li>
<li><p>编译完成，生成的目标文件共有三个 <code>lua.exe</code>，<code>luac.exe</code>，<code>lua53.dll</code>，在 <code>src</code> 目录下<br><img src="../images/20210219213307215.png" alt="在这里插入图片描述"></p>
</li>
<li><p>可以直接将 <code>src</code> 添加到环境变量，或者将上述三个文件保存在某个目录，然后将这个目录添加到环境变量</p>
</li>
<li><p>验证，在命令行窗口输入 <code>lua</code>，或者输入 <code>lua -v</code><br><img src="../images/20210219213357495.png" alt="在这里插入图片描述"><br><img src="../images/20210219213454730.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h1 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h1><p>我们通过有关的环境变量配置即可自己手动编译一个自己的 Lua 环境，但是这里也有一个注意点，本人在 <code>TDM-GCC</code> 以及 <code>Mingw</code> 的 GCC 编译环境下编译出来的不需要再依赖其他的库，但是在 <code>cygwin64</code> 平台下编译的 Lua 解释器还需要依赖 <code>cygwin64</code> 的有关库（也就是说编译好的文件不能共享给其他人使用）</p>
<h1 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h1><ul>
<li>[1] Lua 官方文档</li>
<li>[2] <a href="https://github.com/joedf/LuaBuilds">https://github.com/joedf/LuaBuilds</a> </li>
</ul>
]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet学习笔记</title>
    <url>/archives/1a5315c2.html</url>
    <content><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Servlet（Server Applet）是<a href="https://baike.baidu.com/item/Java/85979">Java</a> Servlet的简称，称为小服务程序或服务连接器，用Java编写的<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>端程序，具有独立于平台和<a href="https://baike.baidu.com/item/%E5%8D%8F%E8%AE%AE/13020269">协议</a>的特性，主要功能在于交互式地浏览和生成数据，生成动态<a href="https://baike.baidu.com/item/Web/150564">Web</a>内容。</p>
<p>广义的Servlet是指任何实现了Servlet接口的类</p>
<p>Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p>
<p>【总结】实现了servlet接口的java程序，就是servlet</p>
<span id="more"></span>



<h2 id="HelloServlet"><a href="#HelloServlet" class="headerlink" title="HelloServlet"></a>HelloServlet</h2><p>Servlet接口Sun公司有两个默认的实现类：HttpServlet，GenericServlet</p>
<ol>
<li><p>maven模板，webapp，修改web.xml（这部分看自己tomcat服务器web.xml是啥，然后复制个头文件过来就行）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://java.sun.com/xml/ns/javaee</span></span><br><span class="line"><span class="string">                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;3.0&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>将项目的结构补充完整，java和resources</p>
</li>
<li><p>编写一个Servlet程序</p>
<ul>
<li><p>编写一个普通的类</p>
</li>
<li><p>实现Servlet接口，这里我们直接继承HttpServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于get或者post只是实现方式不同，可以互相调用，业务逻辑都一样</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line"></span><br><span class="line">        writer.print(<span class="string">&quot;Hello Servlet!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>编写Servlet的映射</p>
<ul>
<li><p>为什么需要映射？</p>
<ul>
<li><p>因为我们写的是java程序，但是要通过浏览器访问，浏览器访问需要连接服务器，所以我们需要在web服务中注册我们写的Servlet，还需要给个URL路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.tcmyxc.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet请求路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello&lt;<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>配置Tomcat</p>
<ul>
<li>注意配置项目发布的路径</li>
</ul>
</li>
<li><p>测试</p>
</li>
</ol>
<h2 id="Servlet原理"><a href="#Servlet原理" class="headerlink" title="Servlet原理"></a>Servlet原理</h2><p>Servlet由Web服务器调用</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate学习笔记</title>
    <url>/archives/9ec6fc96.html</url>
    <content><![CDATA[<h2 id="一、是什么？"><a href="#一、是什么？" class="headerlink" title="一、是什么？"></a>一、是什么？</h2><p>hibernate框架应用在javaee三层结构中 dao层框架</p>
<p>hibernate底层代码就是jdbc，hibernate对jdbc进行封装，使用hibernate好处，不需要写复杂jdbc代码了，<br>不需要写sql语句实现</p>
<p>开源的轻量级的框架</p>
<span id="more"></span>



<h2 id="ORM思想"><a href="#ORM思想" class="headerlink" title="ORM思想"></a>ORM思想</h2><p>orm：object relational mapping，对象关系映射<br>文字描述：<br>（1）让实体类和数据库表进行一一对应关系<br>让实体类首先和数据库表对应<br>让实体类属性 和 表里面字段对应<br>（2）不需要直接操作数据库表，而操作表对应实体类对象</p>
<p><img src="../images/clip_image002.jpg" alt="img"></p>
<p><img src="../images/clip_image002-1623322622876.jpg" alt="img"></p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="搭建一个demo"><a href="#搭建一个demo" class="headerlink" title="搭建一个demo"></a>搭建一个demo</h3><h4 id="1、使用IDEA创建一个Maven工程"><a href="#1、使用IDEA创建一个Maven工程" class="headerlink" title="1、使用IDEA创建一个Maven工程"></a>1、使用IDEA创建一个Maven工程</h4><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>解决编译时资源文件不生效的问题：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认打包资源文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、写个实体类"><a href="#2、写个实体类" class="headerlink" title="2、写个实体类"></a>2、写个实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> uid;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> uid, String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、写实体类对应的配置文件"><a href="#3、写实体类对应的配置文件" class="headerlink" title="3、写实体类对应的配置文件"></a>3、写实体类对应的配置文件</h4><p>建议：在实体类所在包里面创建，<code>实体类名称.hbm.xml</code></p>
<p><img src="../images/image-20210610190546796.png" alt="image-20210610190546796"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  ~ Hibernate, Relational Persistence for Idiomatic Java</span></span><br><span class="line"><span class="comment">  ~</span></span><br><span class="line"><span class="comment">  ~ License: GNU Lesser General Public License (LGPL), version 2.1 or later.</span></span><br><span class="line"><span class="comment">  ~ See the lgpl.txt file in the root directory or &lt;http://www.gnu.org/licenses/lgpl-2.1.html&gt;.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;com.tcmyxc.dao&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置类名和表名的映射关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;User&quot;</span> <span class="attr">table</span>=<span class="string">&quot;t_user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置主键自增长--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置类属性和表结构中列名的对应关系，不填就一模一样--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4、创建hibernate的核心配置文件"><a href="#4、创建hibernate的核心配置文件" class="headerlink" title="4、创建hibernate的核心配置文件"></a>4、创建hibernate的核心配置文件</h4><p>名字是固定的：<code>hibernate.cfg.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  ~ Hibernate, Relational Persistence for Idiomatic Java</span></span><br><span class="line"><span class="comment">  ~</span></span><br><span class="line"><span class="comment">  ~ License: GNU Lesser General Public License (LGPL), version 2.1 or later.</span></span><br><span class="line"><span class="comment">  ~ See the lgpl.txt file in the root directory or &lt;http://www.gnu.org/licenses/lgpl-2.1.html&gt;.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-configuration</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Database connection settings --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.driver_class&quot;</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.url&quot;</span>&gt;</span>jdbc:mysql:///mytest?serverTimezone=UTC<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.username&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--可选配置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- JDBC connection pool (use the built-in) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.pool_size&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- SQL dialect --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQL8Dialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 输出 sql 语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;show_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--sql 语句格式化--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;format_sql&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自动创建表</span></span><br><span class="line"><span class="comment">            update: 没有则创建，有则更新</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hbm2ddl.auto&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;com/tcmyxc/dao/User.hbm.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h4><p>第一步 加载hibernate核心配置文件</p>
<p>第二步 创建SessionFactory对象</p>
<p>第三步 使用SessionFactory创建session对象</p>
<p>第四步 开启事务</p>
<p>第五步 写具体逻辑 crud操作</p>
<p>第六步 提交事务</p>
<p>第七步 关闭资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Configuration cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">    cfg.configure();</span><br><span class="line"></span><br><span class="line">    SessionFactory sessionFactory = cfg.buildSessionFactory();</span><br><span class="line">    Session session = sessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    Transaction transaction = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">&quot;xwx&quot;</span>);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    session.save(user);</span><br><span class="line"></span><br><span class="line">    transaction.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hibernate核心api"><a href="#Hibernate核心api" class="headerlink" title="Hibernate核心api"></a>Hibernate核心api</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><p>找到名称hibernate.cfg.xml配置文件，创建对象，把配置文件放到对象里面（加载核心配置文件）</p>
<h4 id="SessionFactory"><a href="#SessionFactory" class="headerlink" title="SessionFactory"></a>SessionFactory</h4><p>1 使用configuration对象创建sessionFactory对象<br>（1）创建sessionfactory过程中做事情：</p>
<ul>
<li>根据核心配置文件中，有数据库配置，有映射文件部分，到数据库里面根据映射关系把表创建</li>
</ul>
<p>2 创建sessionFactory过程中，这个过程特别耗资源的<br>（1）在hibernate操作中，建议一个项目一般创建一个sessionFactory对象</p>
<p>3 具体实现<br>（1）写工具类，写静态代码块实现</p>
<ul>
<li>静态代码块在类加载时候执行，执行一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionFactoryUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Configuration cfg = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sessionFactory = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态代码块保证只被加载一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">        cfg.configure();</span><br><span class="line">        sessionFactory = cfg.buildSessionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SessionFactory <span class="title">getSessionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>1 session类似于jdbc中connection</p>
<p>2 调用session里面不同的方法实现crud操作<br>（1）添加 save方法<br>（2）修改 update方法<br>（3）删除 delete方法<br>（4）根据id查询 get方法</p>
<p>3 session对象单线程对象<br>（1）session对象不能共用，只能自己使用</p>
<h3 id="增删改查那些事"><a href="#增删改查那些事" class="headerlink" title="增删改查那些事"></a>增删改查那些事</h3><h4 id="Hibernate实体类编写规则"><a href="#Hibernate实体类编写规则" class="headerlink" title="Hibernate实体类编写规则"></a>Hibernate实体类编写规则</h4><p>1 实体类里面属性私有的</p>
<p>2 私有属性使用公开的set和get方法操作</p>
<p>3 要求实体类有属性作为唯一值（一般使用id值）</p>
<p>4 实体类属性建议不使用基本数据类型，使用基本数据类型对应的包装类<br>（1）八个基本数据类型对应的包装类</p>
<ul>
<li>int – Integer</li>
<li>char—Character、</li>
<li>其他的都是首字母大写 比如 double – Double<br>（2）比如 表示学生的分数，假如 int score;</li>
<li>比如学生得了0分 ，int score = 0;</li>
<li>如果表示学生没有参加考试，int score = 0;不能准确表示学生是否参加考试<ul>
<li>解决：使用包装类可以了， Integer score = 0，表示学生得了0分，表示学生没有参加考试，Integer score = null;</li>
</ul>
</li>
</ul>
<h4 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h4><p><img src="../images/clip_image002-1623324391800.jpg" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置主键自增长--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><p>根据 id 查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210610193221935.png" alt="image-20210610193221935"></p>
<h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line">user.setPassword(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">session.update(user);</span><br><span class="line">User user2 = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user2);</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210610193536590.png" alt="image-20210610193536590"></p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line"><span class="comment">// 测试删除操作</span></span><br><span class="line">session.delete(user);</span><br><span class="line">User user2 = session.get(User.class, <span class="number">2</span>);</span><br><span class="line">System.out.println(user2);</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210610193824545.png" alt="image-20210610193824545"></p>
<h2 id="其他的概念"><a href="#其他的概念" class="headerlink" title="其他的概念"></a>其他的概念</h2><h3 id="实体类对象状态"><a href="#实体类对象状态" class="headerlink" title="实体类对象状态"></a>实体类对象状态</h3><p>实体类状态有三种</p>
<p>（1）瞬时态：对象里面没有id值，对象与session没有关联</p>
<p><img src="../images/clip_image002-1623325203474.jpg" alt="img"></p>
<p>（2）持久态：对象里面有id值，对象与session关联</p>
<p><img src="../images/clip_image004.jpg" alt="img"></p>
<p>（3）托管态：对象有id值，对象与session没有关联</p>
<p><img src="../images/clip_image006.jpg" alt="img"></p>
<p>saveOrUpdate方法：实现添加、实现修改</p>
<p><img src="../images/clip_image002-1623325258642.jpg" alt="img"></p>
<p><img src="../images/clip_image004-1623325258643.jpg" alt="img"></p>
<p><img src="../images/clip_image006-1623325258643.jpg" alt="img"></p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>hibernate缓存特点：</p>
<p>第一类 hibernate的一级缓存</p>
<p>（1）hibernate的一级缓存默认打开的</p>
<p>（2）hibernate的一级缓存使用范围，是session范围，从session创建到session关闭范围</p>
<p>（3）hibernate的一级缓存中，存储数据必须 持久态数据</p>
<p>第二类 hibernate的二级缓存</p>
<p>（1）目前已经不使用了，替代技术 redis</p>
<p>（2）二级缓存默认不是打开的，需要配置</p>
<p>（3）二级缓存使用范围，是sessionFactory范围</p>
<p><img src="../images/clip_image002-1623325371492.jpg" alt="img"></p>
<h3 id="事务代码规范写法"><a href="#事务代码规范写法" class="headerlink" title="事务代码规范写法"></a>事务代码规范写法</h3><p>代码结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; 开启事务 提交事务&#125;</span><br><span class="line"><span class="keyword">catch</span>() &#123; 回滚事务&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123; 关闭&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTx</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    SessionFactory sessionFactory = <span class="keyword">null</span>;    </span><br><span class="line">    Session session = <span class="keyword">null</span>;    </span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;    </span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">        sessionFactory = HibernateUtils.getSessionFactory();        </span><br><span class="line">        session = sessionFactory.openSession();        </span><br><span class="line">        <span class="comment">//开启事务        </span></span><br><span class="line">        tx = session.beginTransaction();        </span><br><span class="line">        <span class="comment">//添加        </span></span><br><span class="line">        User user = <span class="keyword">new</span> User();        </span><br><span class="line">        user.setUsername(<span class="string">&quot;小马&quot;</span>);        </span><br><span class="line">        user.setPassword(<span class="string">&quot;250&quot;</span>);        </span><br><span class="line">        user.setAddress(<span class="string">&quot;美国&quot;</span>);        </span><br><span class="line">        session.save(user);        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;        </span><br><span class="line">        <span class="comment">//提交事务        </span></span><br><span class="line">        tx.commit();    </span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e) &#123;        </span><br><span class="line">    	e.printStackTrace();        </span><br><span class="line">        <span class="comment">//回滚事务        </span></span><br><span class="line">        tx.rollback();    </span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;        </span><br><span class="line">        <span class="comment">//关闭操作        </span></span><br><span class="line">        session.close();        </span><br><span class="line">        sessionFactory.close();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210610194600591.png" alt="image-20210610194600591"></p>
<h2 id="回顾表和表之间的关系"><a href="#回顾表和表之间的关系" class="headerlink" title="回顾表和表之间的关系"></a>回顾表和表之间的关系</h2><p>一对多：分类和商品关系，一个分类里面有多个商品，一个商品只能属于一个分类</p>
<p>多对多：订单和商品关系，一个订单里面有多个商品，一个商品属于多个订单</p>
<p>多对多建表：创建第三张表维护关系</p>
<p><img src="../images/clip_image002-1623910791593.jpg" alt="img"></p>
<h2 id="查询方式介绍"><a href="#查询方式介绍" class="headerlink" title="查询方式介绍"></a>查询方式介绍</h2><h3 id="对象导航查询"><a href="#对象导航查询" class="headerlink" title="对象导航查询"></a>对象导航查询</h3><p>（1）根据id查询某个客户，再查询这个客户里面所有的联系人</p>
<p><img src="../images/clip_image002-1623913387871.jpg" alt="img"></p>
<h3 id="OID查询"><a href="#OID查询" class="headerlink" title="OID查询"></a>OID查询</h3><p>（1）根据id查询某一条记录，返回对象</p>
<p><img src="../images/clip_image002-1623913455625.jpg" alt="img"></p>
<h3 id="HQL查询"><a href="#HQL查询" class="headerlink" title="HQL查询"></a>HQL查询</h3><p>HQL，即hibernate query language，hibernate提供一种查询语言，hql语言和普通sql很相似</p>
<p>区别：普通sql操作数据库表和字段，hql操作实体类和属性</p>
<p>常用的hql语句</p>
<p>（1）查询所有： from 实体类名称</p>
<p>（2）条件查询： from 实体类名称 where 属性名称=? </p>
<p>（3）排序查询： from 实体类名称 order by 实体类属性名称 asc/desc</p>
<p>使用hql查询操作时候，使用Query对象</p>
<p>（1）创建Query对象，写hql语句</p>
<p>（2）调用query对象里面的方法得到结果</p>
<h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><p><img src="../images/clip_image002-1623913606053.jpg" alt="img"></p>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p><img src="../images/clip_image002-1623913667053.jpg" alt="img"></p>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>在hql操作中，在语句里面不能写limit，hibernate的Query对象封装两个方法实现分页操作</p>
<p><img src="../images/clip_image002-1623913727409.jpg" alt="img"></p>
<h4 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h4><p> 投影查询：查询不是所有字段值，而是部分字段的值</p>
<p>投影查询hql语句写法：</p>
<p>（1）select 实体类属性名称1, 实体类属性名称2  from 实体类名称</p>
<p>（2）select 后面不能写 <code>* </code>，不支持的</p>
<p>具体实现：</p>
<p><img src="../images/clip_image002-1623914156308.jpg" alt="img"></p>
<h3 id="QBC查询"><a href="#QBC查询" class="headerlink" title="QBC查询"></a>QBC查询</h3><p>1、使用hql查询需要写hql语句实现，但是使用qbc时候，不需要写语句了，使用方法实现</p>
<p>2、使用qbc时候，操作实体类和属性</p>
<p>3、使用qbc，使用Criteria对象实现</p>
<h4 id="查询所有-1"><a href="#查询所有-1" class="headerlink" title="查询所有"></a>查询所有</h4><p><img src="../images/clip_image002-1623914241737.jpg" alt="img"></p>
<h4 id="条件查询-1"><a href="#条件查询-1" class="headerlink" title="条件查询"></a>条件查询</h4><p><img src="../images/clip_image002-1623914264974.jpg" alt="img"></p>
<h4 id="分页查询-1"><a href="#分页查询-1" class="headerlink" title="分页查询"></a>分页查询</h4><p><img src="../images/clip_image002-1623914337716.jpg" alt="img"></p>
<h4 id="统计查询"><a href="#统计查询" class="headerlink" title="统计查询"></a>统计查询</h4><p><img src="../images/clip_image002-1623914367144.jpg" alt="img"></p>
<h4 id="本地sql查询"><a href="#本地sql查询" class="headerlink" title="本地sql查询"></a>本地sql查询</h4><p>SQLQuery对象，使用普通sql实现查询</p>
<p>servlet调用service，service调用dao</p>
<p>（1）在dao里面对数据库crud操作<br>（2）在dao里面使用hibernate框架，使用hibernate框架时候，调用session里面的方法实现功能</p>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>迫切内连接</p>
<p>（1）迫切内连接和内连接底层实现一样的</p>
<p>（2）区别：使用内连接返回list中每部分是数组，迫切内连接返回list每部分是对象</p>
<p>（3）hql语句写法：from  Customer  c  inner  join  fetch  c.setLinkMan</p>
<h2 id="检索策略"><a href="#检索策略" class="headerlink" title="检索策略"></a>检索策略</h2><p>检索策略分为两类：</p>
<p>（1）立即查询：根据id查询，调用get方法，一调用get方法马上发送语句查询数据库</p>
<p>（2）延迟查询：根据id查询，还有load方法，调用load方法不会马上发送语句查询数据，只有得到对象里面的值时候才会发送语句查询数据库</p>
<p>延迟查询分成两类：</p>
<p>（1）类级别延迟：根据id查询返回实体类对象，调用load方法不会马上发送语句</p>
<p>（2）关联级别延迟：查询某个客户，再查询这个客户的所有联系人，查询客户的所有联系人的过程是否需要延迟，这个过程称为关联级别延迟</p>
<p>批量抓取</p>
<p>查询所有的客户，返回list集合，遍历list集合，得到每个客户，得到每个客户的所有联系人</p>
<p><img src="../images/clip_image002-1623914745666.jpg" alt="img"></p>
<p>在客户的映射文件中，set标签配置 batch-size值，值越大发送语句越少</p>
<p><img src="../images/clip_image002-1623914783979.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/archives/e255a10a.html</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><blockquote>
<p>  参考文献：</p>
<ul>
<li>  [1]王道计算机网络复习书</li>
<li>  [2]计算机网络（第五版）- 潘爱民等译</li>
</ul>
</blockquote>
<span id="more"></span>



<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h3 id="对称秘钥算法"><a href="#对称秘钥算法" class="headerlink" title="对称秘钥算法"></a>对称秘钥算法</h3><p><strong>使用相同的秘钥加解密</strong></p>
<p><img src="../images/image-20210112143721721.png" alt="image-20210112143721721"></p>
<h4 id="DES-数据加密标准"><a href="#DES-数据加密标准" class="headerlink" title="DES 数据加密标准"></a>DES 数据加密标准</h4><p>三重 DES</p>
<p>1、使用秘钥 1 执行 DES 加密</p>
<p>2、使用秘钥 2 解密</p>
<p>3、使用秘钥 1 加密</p>
<h4 id="AES-高级加密标准"><a href="#AES-高级加密标准" class="headerlink" title="AES 高级加密标准"></a>AES 高级加密标准</h4><h3 id="公开秘钥算法"><a href="#公开秘钥算法" class="headerlink" title="公开秘钥算法"></a>公开秘钥算法</h3><p>加密算法 E，解密算法 D</p>
<p>1、$\ D(E(P))=P$</p>
<p>2、从 E 很难推出 D</p>
<p>3、加密算法不可能被选择明文攻击破解</p>
<p>使用公钥加密信息，私钥解密信息 </p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>1、接收方可以验证发送方的身份</p>
<p>2、发送方不能说我没发过</p>
<p>3、接收方不可能伪造发送的信息</p>
<h4 id="对称秘钥签名"><a href="#对称秘钥签名" class="headerlink" title="对称秘钥签名"></a>对称秘钥签名</h4><p><strong>使用同一秘钥</strong></p>
<p>找一个权威机构，自己的私钥自己知道，机构也知道</p>
<p>发送消息：</p>
<p>1、Alice 使用私钥加密，并标识要发送给 Bob</p>
<p>2、机构看到消息，解密该消息，然后发给 Bob</p>
<p>3、Bob 接收消息</p>
<h4 id="公开秘钥签名"><a href="#公开秘钥签名" class="headerlink" title="公开秘钥签名"></a>公开秘钥签名</h4><p><img src="../images/image-20210112150440539.png" alt="image-20210112150440539"></p>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>认证中心 CA</p>
<p>证书：将一个公钥和一个实体绑定</p>
<h3 id="SSL-安全套接字层"><a href="#SSL-安全套接字层" class="headerlink" title="SSL 安全套接字层"></a>SSL 安全套接字层</h3><p>HTTPS 443端口</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><h4 id="C-S-模型"><a href="#C-S-模型" class="headerlink" title="C/S 模型"></a>C/S 模型</h4><p>服务器总是打开，总是处于接收请求的状态，如果收到请求，则解析请求，进行必要的处理，并将处理结果发送给客户端</p>
<p>特点：</p>
<ul>
<li>  客户机地位不均等，服务器可以通过用户权限控制管理客户机</li>
<li>  客户机不直接通信</li>
<li>  单个服务器支持的客户机有限</li>
</ul>
<h4 id="P2P-模型"><a href="#P2P-模型" class="headerlink" title="P2P 模型"></a>P2P 模型</h4><p>各节点既是客户端又是服务器，都可以上传下载，相互之间直接通信</p>
<p>优点：</p>
<ul>
<li>  减轻了服务器的压力</li>
<li>  消除对某个服务器的完全依赖，可以把任务放到多个节点上</li>
<li>  可直接共享文档</li>
<li>  拓展性好</li>
<li>  网络健壮性强</li>
</ul>
<p>缺点：</p>
<ul>
<li>  由于既获取服务也提供服务，内存占用较大，会影响整机速度</li>
</ul>
<h3 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h3><p>C/S 模型，协议运行在 UDP 之上，53 号端口</p>
<p>域名是层次结构，级别高的在右边</p>
<p>域名系统：联机分布式的数据库系统</p>
<p>四种 DNS 服务器：根（13个）、顶级、授权、本地</p>
<p>每台主机都必须在授权域名服务器登记</p>
<h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><p>两种方式：</p>
<ul>
<li>  递归查询（根 DNS 服务器是中继节点，压力大）</li>
<li>  递归和迭代相结合</li>
</ul>
<p>递归查询示意图：</p>
<p><img src="../images/image-20210112131956527.png" alt="image-20210112131956527"></p>
<p>递归和迭代结合：</p>
<p><img src="../images/image-20210112132617854.png" alt="image-20210112132617854"></p>
<p>主机向本地 DNS 服务器查询是递归，本地 DNS 向其他 DNS 查询是迭代</p>
<p>域名解析过程如下：</p>
<p>1、客户机发送 DNS 请求报文，以 UDP 数据报的形式发送到本地 DNS 服务器</p>
<p>2、本地 DNS 收到后，先查缓存，如果没有，自己扮演 DNS 客户，向根域名服务器发送解析请求</p>
<p>3、根 DNS 服务器收到后，判断一下属于哪个顶级域名服务器，将对应的 IP 地址发来，说，你去找他，他知道</p>
<p>4、本地 DNS 服务器向顶级域名服务器发送解析请求</p>
<p>5、顶级收到后，判断一下属于哪个授权域名服务器，将对应的 IP 地址发来，说，你去找他，他知道</p>
<p>6、本地向授权发送请解析请求</p>
<p>7、授权收到之后会将解析结果发回本地域名服务器</p>
<p>8、本地把查询结果存到缓存，并发给客户端</p>
<h3 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议 FTP"></a>文件传输协议 FTP</h3><p>21 端口，C/S 模型，使用 TCP，有两个并行的 TCP 连接，一个控制连接进程（21），一个数据连接进程（20）</p>
<p>客户端有传输请求的时候才会创建数据连接进程 </p>
<p>功能：</p>
<p>1、在不同种类操作系统之家传输文件（屏蔽了操作系统的细节）</p>
<p>2、通过用户权限控制管理用户行为</p>
<p>3、可以用匿名 FTP 方式提供公用文件的共享能力</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>80 端口、无状态</p>
<p>使用 TCP进行可靠的传输</p>
<p>输入 URL 之后发生的事情：</p>
<p>1、浏览器分析 URL ，然后请求域名解析获得 IP 地址</p>
<p>2、与服务器建立 TCP 连接，然后发送 HTTP 请求</p>
<p>3、服务器对浏览请求进行处理，通过 HTTP 响应返回信息给浏览器</p>
<p>4、关闭连接</p>
<p>5、浏览器渲染页面</p>
<p>HTTP/1.1 支持长连接，分两种：</p>
<p>1、非流水线。收到前一个的响应之后才能发请求</p>
<p>2、流水线。发现对象引用就发请求</p>
<h4 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h4><ul>
<li>  请求报文</li>
<li>  响应报文</li>
</ul>
<p>组成：开始行、首部行、实体主体</p>
<p>请求报文和响应报文仅开始行不同</p>
<ul>
<li>  开始行：有三个字段，请求行是请求的方法、URL 以及 HTTP 版本号；响应行是版本、状态码、短语</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>为运行在不同主机上的进程之间提供逻辑通信，屏蔽了低层网络核心的细节，让两个进程认为咱们两个是直接在通信</p>
<h3 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h3><p>让各种应用层的进程把要传输的数据通过端口号向下交付给传输层，以及让传输层（一般指另外一个主机）知道把要传输的数据通过端口号向上交付给应用层的有关进程。</p>
<p>其实就是一个标识作用，让应用层知道该把数据通过哪个端口给传输层，传输层根据这个端口号把数据给应用层的相关进程。</p>
<p>端口号有 16 位，所以最大是 65536 - 1 = 65535</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>实际上是一个通信端点，即 套接字 = (主机 IP 地址, 端口号)，它可以唯一标识一台主机的一个应用（进程）</p>
<p>通常用C/S架构</p>
<p>只允许交换无结构的字节流</p>
<h4 id="面向连接和无连接"><a href="#面向连接和无连接" class="headerlink" title="面向连接和无连接"></a>面向连接和无连接</h4><p>面向连接：就是要求通信双方在通信之前必须要建立连接，也就是 <code>建立连接 -&gt; 开始通信 -&gt; 通信结束，关闭连接</code></p>
<p>无连接：通信双方不需要事先建立连接，如果需要通信，直接将信息发送到网络，让该信息的传递在网上尽力而为地往目的地传送。</p>
<p>TCP</p>
<ul>
<li>  面向连接（传送数据前需要建立连接）</li>
<li>  全双工</li>
<li>  没有广播和组播</li>
<li>  用于可靠性更重要的场合，如 FTP，HTTP，Telnet远程登录</li>
</ul>
<p>UDP</p>
<ul>
<li>  无连接，不可靠</li>
<li>  收到 UDP 数据报之后不需要给出确认报文</li>
<li>  执行速度快，实时性好，如 DNS，RTP（实时传输协议）</li>
</ul>
<h3 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h3><h4 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h4><p><strong>优点：</strong></p>
<p>1、无需建立连接，不会引入建立连接的时延</p>
<p>2、无连接。不需要维护连接状态，一般可以支持更多的活动客户机</p>
<p>3、分组首部开销小。仅有 8B 的开销（TCP 有 20B）</p>
<p>4、可以更好地控制发送的数据和发送时间。没有拥塞控制，网络中的拥塞不会影响主机的发送效率。</p>
<p><strong>常用场景</strong></p>
<ul>
<li>  一次性传输较少数据的网络应用，如 DNS，SNMP</li>
<li>  多媒体应用（IP 电话，实时视频会议，流媒体等）</li>
</ul>
<p>不保证可靠交换，所以维护传输可靠性的工作需要用户在<strong>应用层</strong>完成</p>
<p>面向报文。发送方 UDP 对应用层传下来的报文，仅仅是添加一个首部就交给 IP 层，别的啥也不干</p>
<p><strong>首部格式</strong></p>
<p>UDP 数据报包括：UDP 首部和用户数据</p>
<p>首部有四个字段：源端口、目的端口、数据报长度（包含首部和数据）、校验和</p>
<h4 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h4><p>在不可靠的 IP 层之上实现的可靠的数据传输协议</p>
<p>解决的问题：传输的可靠、有序、无重复和不丢失问题</p>
<p><strong>特点</strong></p>
<p>1、面向连接的</p>
<p>2、一个 TCP 连接只能有两个端点，每条 TCP 连接只能是点对点的</p>
<p>3、提供可靠的交付，保证数据无差错、不丢失、不重复、有序</p>
<p>4、全双工通信。TCP 两端都有缓存，用来临时存放通信数据</p>
<ul>
<li>  发送缓存：发送应用程序传送给发送放 TCP要发送的数据、TCP 已发送但是未收到确认的数据</li>
<li>  接收缓存：按序到达但未被接收方应用程序读取的数据、不按序到达的数据</li>
</ul>
<p>5、面向字节的。</p>
<p><strong>首部格式</strong></p>
<p>一个 TCP 报文段分为 TCP 首部和 TCP 数据两部分，整个报文段被封装在 IP 数据报的数据部分</p>
<p>TCP 报文段用途：</p>
<ul>
<li>  运载数据</li>
<li>  建立连接</li>
<li>  释放连接</li>
<li>  应答</li>
</ul>
<p><strong>结构示意图</strong></p>
<p><img src="../images/6-19110Q62344I5.gif" alt="img"></p>
<p><img src="../images/image-20210128212948575.png" alt="image-20210128212948575"></p>
<blockquote>
<p>  图片来源：<a href="http://c.biancheng.net/view/6441.html">http://c.biancheng.net/view/6441.html</a></p>
<p>  <a href="https://blog.csdn.net/lqglqglqg/article/details/48850029">https://blog.csdn.net/lqglqglqg/article/details/48850029</a></p>
</blockquote>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>每个 TCP 连接都有三个阶段：建立连接、数据传送、连接释放</p>
<p>TCP 连接需要解决三个问题：</p>
<p>1、要使发送双方都知道对方的存在</p>
<p>2、要允许双方协议一些参数（如最大窗口值，是否使用窗口扩大选项，时间戳服务及服务质量）</p>
<p>3、能够对运输实体资源进行分配</p>
<p>TCP 连接的端口是套接字（IP 地址 + 端口）</p>
<p>每条 TCP 连接可以由通信两端的两个端点确定。</p>
<p>TCP 连接的建立采用 C/S 模式</p>
<p><img src="../images/d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpeg" alt="img"></p>
<p>服务端的资源是在第二次握手时分配的（容易遭到 SYN 泛红攻击）</p>
<p>客户端的资源是在第三次握手的时候建立的</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>当 FIN 段被另 一方确认后，这个方向上的连接就被关闭，不再发送任何数据。然而，另一个方向上或许还在继续着无限的数据流。当两个方向都关闭后，连接才算被彻底释放</p>
<p>为了避免两军对垒问题，需要使用计时器。如果在两倍于最大数据包生存期内，针对 FIN 的响应没有出现，那么 FIN 的发送端直接释放连接</p>
<p><img src="../images/48540923dd54564e5260495ce0006487d0584fb6.jpeg" alt="img"></p>
<p>TCP 有限状态机的状态：</p>
<p><img src="../images/image-20210128212137505.png" alt="image-20210128212137505"></p>
<h4 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h4><p>保证接收方进程从缓存区读出的字节流与发送方发出的字节流完全一致</p>
<p>使用的机制：校验、序号、确认、重传</p>
<p>1、序号</p>
<p>TCP 首部的序号字段保证数据能有序提交给应用层，序号值是本报文要发送的第一个字节的序号</p>
<p>2、确认</p>
<p>确认号是希望收到对方的下一个报文段的数据的第一个字节的序号。</p>
<p>3、重传</p>
<p>重传条件：超时和冗余 ACK</p>
<p>（1）超时</p>
<p>每发送一个报文段，就对这个报文设置一次计时器。如果计时器设置的重传时间到期但还没有收到确认，就必须重传。（RTT：报文往返一趟的时间）</p>
<p>（2）冗余确认</p>
<p>当收到三个 ACK 的时候，必须重传该报文。</p>
<p>比如，1、2、3、4、5，五个报文发出去，但是2号丢了。<strong>TCP 规定每当比期望序号大的失序报文到达时，就要发送一个冗余 ACK，指明期待收到的下一个报文序号。</strong>所以会发送3个1号报文的冗余ACK，必须重传。</p>
<h4 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h4><p>避免发送方发送的数据大于接收方缓存，从而导致数据丢失。</p>
<p>滑动窗口协议</p>
<p><img src="../images/image-20210128214226394.png" alt="image-20210128214226394"></p>
<blockquote>
<p>例如，假设接收端有一个 4096 字节的缓冲区，如图 6-40 所示。如果发送端传送了一个2048字节的数据段，并且该数据段已被正确地接收，那么接收方将确认该数据段；然而，由于接收端现在只剩下2048字节的缓冲区空间（在应用程序从缓存区取走数据之前），所以它将宣告下一个期望字节开始窗口为 2048。</p>
</blockquote>
<p>接收方根据自己接收缓存的大小，动态调整发送方的发送窗口大小，这是接收窗口 rwnd</p>
<p>发送方根据自己对当前网络拥塞程度估计而确定的窗口值，这是拥塞窗口 cwnd。</p>
<h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h4><p>防止过多的数据注入网络，保证网络中的路由器或者链路不至于过载。</p>
<p>4种算法：慢开始、拥塞避免、快重传、快恢复</p>
<p>1、慢开始算法</p>
<p>拥塞窗口指数级别增长，最开始是1，然后是2、4、8……</p>
<p>达到规定的慢开始阈值之后，改用拥塞避免算法</p>
<p>2、拥塞避免算法</p>
<p>每次增加1，线性增长</p>
<p>如果出现拥塞，把慢开始的阈值设置为发生拥塞时的发送方的 cwnd 的一半，然后把拥塞窗口设置成1，重新慢开始（这样做是为了迅速减少主机发送到网络中的分组数，使发生拥塞的路由器把积压的分组处理完）</p>
<p><img src="../images/image-20210128220140738.png" alt="image-20210128220140738"></p>
<p>3、快重传</p>
<p>收到三个冗余 ACK 就必须重传</p>
<p>4、快恢复（因为跳过了慢开始阶段）</p>
<p>收到三个冗余 ACK，把慢开始的阈值设置为发生拥塞时的发送方的 cwnd 的一半，然后把拥塞窗口设置成这个阈值，然后执行拥塞避免算法</p>
<p><img src="../images/image-20210128220441976.png" alt="image-20210128220441976"></p>
<p>在流量控制中，发送方发送数据的量由接收方决定，而在拥塞控制中，则由发送方自己通过检测网络状况来决定。</p>
<p>实际上，慢开始、拥塞避免、快重传和快恢复几种算法应是同时应用在拥塞控制机制之中的，当发送方检测到超时的时候，就采用慢开始和拥塞避免，当发送方按收到冗余 ACK 时,就采用快重传和快恢复。</p>
<p>发送方发送窗口的实际大小由流量控制和拥塞控制共同决定。因此，当同时出现接收端窗口（rwnd）和拥塞窗口(cwnd）时，发送方实际的发送窗口大小是由 rwnd 和 cwnd 中较小的那一个确定的。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA学习笔记</title>
    <url>/archives/4ac63db6.html</url>
    <content><![CDATA[<h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p>JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体<a href="https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96/7316192">对象持久化</a>到数据库中。 </p>
<span id="more"></span>

<p>Sun引入新的JPA ORM规范出于两个原因：其一，简化现有Java EE和Java SE应用开发工作；其二，Sun希望整合ORM技术，实现天下归一。</p>
<p>JPA包括以下3方面的技术：</p>
<p><strong>ORM映射元数据</strong></p>
<p>JPA支持XML和<a href="https://baike.baidu.com/item/JDK">JDK</a>5.0注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体<a href="https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1%E6%8C%81%E4%B9%85%E5%8C%96">对象持久化</a>到数据库表中；</p>
<p><strong>API</strong></p>
<p>用来操作实体对象，执行CRUD操作，框架在后台替代我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。</p>
<p><strong>查询语言</strong></p>
<p>这是持久化操作中很重要的一个方面，通过<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。</p>
<p>JPA是需要Provider来实现其功能的，Hibernate就是JPA Provider中很强的一个，应该说无人能出其右。从功能上来说，JPA就是Hibernate功能的一个子集。</p>
<blockquote>
<p>JPA 是规范</p>
</blockquote>
<h2 id="2、HelloWorld"><a href="#2、HelloWorld" class="headerlink" title="2、HelloWorld"></a>2、HelloWorld</h2><p>（1）创建 persistence.xml, 在这个文件中配置持久化单元</p>
<p>JPA 规范要求在类路径的 META-INF 目录下放置persistence.xml</p>
<ul>
<li><p>需要指定跟哪个数据库进行交互;</p>
</li>
<li><p>需要指定 JPA 使用哪个持久化的框架以及配置该框架的基本属性</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">persistence</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/persistence&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--需要配置persistence-unit节点</span></span><br><span class="line"><span class="comment">    持久化单元:</span></span><br><span class="line"><span class="comment">        name:持久化单元名称</span></span><br><span class="line"><span class="comment">        transaction-type:事务管理的方式</span></span><br><span class="line"><span class="comment">                JTA: 分布式事先管理</span></span><br><span class="line"><span class="comment">                RESOURCE_LOCAL:本地事务管理</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">persistence-unit</span> <span class="attr">name</span>=<span class="string">&quot;myJPA&quot;</span> <span class="attr">transaction-type</span>=<span class="string">&quot;RESOURCE_LOCAL&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        jpa的实现方式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span>&gt;</span>org.hibernate.jpa.HibernatePersistenceProvider<span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 添加持久化类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>com.tcmyxc.helloworld.Customer<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--        数据库信息</span></span><br><span class="line"><span class="comment">              用户名, javax.persistence.jdbc.user</span></span><br><span class="line"><span class="comment">              密码, javax.persistence.jdbc.password</span></span><br><span class="line"><span class="comment">              驱动, javax.persistence.jdbc.driver</span></span><br><span class="line"><span class="comment">              数据库地址 javax.persistence.jdbc.url</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--            三个/  ///表示本地路径,端口为3306 jdbc:mysql://localhost:3306/test?serverTimezone=UTC--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///jpa_test?serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--        可选配置:配置jpa实现方的配置信息</span></span><br><span class="line"><span class="comment">                    显示sql执行语句</span></span><br><span class="line"><span class="comment">                    自动创建数据库表  hibernate.hbm2ddl.auto</span></span><br><span class="line"><span class="comment">                                        create,程序运行时创建数据库表(如果有表,先删除表再创建表)</span></span><br><span class="line"><span class="comment">                                        update,程序运行时创建表(如果表存在,则不会创建)</span></span><br><span class="line"><span class="comment">                                        none 不会创建表</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.show_sql&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span> <span class="attr">value</span>=<span class="string">&quot;update&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.format_sql&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">persistence-unit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistence</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>（2）创建实体类, 使用 annotation 来描述实体类跟数据库表之间的映射关系.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 持久化类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Table(name = &quot;JPA_CUSTOMERS&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;LAST_NAME&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（3）使用 JPA API 完成数据增加、删除、修改和查询操作</p>
<ul>
<li><p>创建 EntityManagerFactory (对应 Hibernate 中的 SessionFactory);</p>
</li>
<li><p>创建 EntityManager (对应 Hibernate 中的Session);</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建 EntityManagerFactory</span></span><br><span class="line">    String persistenceUnitName = <span class="string">&quot;myJPA&quot;</span>;</span><br><span class="line">    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(persistenceUnitName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、创建 EntityManager</span></span><br><span class="line">    EntityManager entityManager = entityManagerFactory.createEntityManager();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、开启事务</span></span><br><span class="line">    EntityTransaction transaction = entityManager.getTransaction();</span><br><span class="line">    transaction.begin();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、CRUD 操作</span></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setLastName(<span class="string">&quot;xwx&quot;</span>);</span><br><span class="line">    customer.setEmail(<span class="string">&quot;1282494272@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    entityManager.persist(customer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、提交事务</span></span><br><span class="line">    transaction.commit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、关闭 EntityManager</span></span><br><span class="line">    entityManager.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7、关闭 EntityManagerFactory</span></span><br><span class="line">    entityManagerFactory.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行截图：</p>
<p><img src="../images/image-20210612173746712.png" alt="image-20210612173746712"></p>
<p><img src="../images/image-20210612173801846.png" alt="image-20210612173801846"></p>
<h2 id="3、注解"><a href="#3、注解" class="headerlink" title="3、注解"></a>3、注解</h2><h3 id="Entity"><a href="#Entity" class="headerlink" title="@Entity"></a>@Entity</h3><p>@Entity 标注用于实体类声明语句之前，指出该Java 类为实体类，将映射到指定的数据库表。</p>
<h3 id="Table"><a href="#Table" class="headerlink" title="@Table"></a>@Table</h3><p>当实体类与其映射的数据库表名不同名时需要使用 @Table 标注说明，该标注与 @Entity 标注并列使用，置于实体类声明语句之前，可写于单独语句行，也可与声明语句同行。</p>
<p>@Table 标注的常用选项是 name，用于指明数据库的表名</p>
<p>@Table标注还有一个两个选项 catalog 和 schema 用于设置表所属的数据库目录或模式，通常为数据库名。</p>
<p>uniqueConstraints 选项用于设置约束条件，通常不须设置。</p>
<h3 id="Id"><a href="#Id" class="headerlink" title="@Id"></a>@Id</h3><p>@Id 标注用于声明一个实体类的属性映射为数据库的主键列。该属性通常置于属性声明语句之前，可与声明语句同行，也可写在单独行上。</p>
<p>@Id标注也可置于属性的getter方法之前。</p>
<h3 id="GeneratedValue"><a href="#GeneratedValue" class="headerlink" title="@GeneratedValue"></a>@GeneratedValue</h3><p>@GeneratedValue  用于标注主键的生成策略，通过 strategy 属性指定。默认情况下，JPA 自动选择一个最适合底层数据库的主键生成策略：SqlServer 对应 identity，MySQL 对应 auto increment。</p>
<p>在 javax.persistence.GenerationType 中定义了以下几种可供选择的策略：</p>
<ul>
<li><p>IDENTITY：采用数据库 ID自增长的方式来自增主键字段，Oracle 不支持这种方式；</p>
</li>
<li><p><strong>AUTO</strong>： JPA自动选择合适的策略，是默认选项；</p>
</li>
<li><p>SEQUENCE：通过序列产生主键，通过 @SequenceGenerator 注解指定序列名，MySql 不支持这种方式</p>
</li>
<li><p>TABLE：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。</p>
</li>
</ul>
<h3 id="Basic"><a href="#Basic" class="headerlink" title="@Basic"></a>@Basic</h3><p>@Basic 表示一个简单的属性到数据库表的字段的映射,对于没有任何标注的 getXxxx() 方法,默认即为@Basic</p>
<p>fetch: 表示该属性的读取策略,有 EAGER 和 LAZY 两种,分别表示主支抓取和延迟加载,默认为 EAGER.</p>
<p>optional:表示该属性是否允许为null, 默认为true</p>
<h3 id="Column"><a href="#Column" class="headerlink" title="@Column"></a>@Column</h3><p>当实体的属性与其映射的数据库表的列不同名时需要使用@Column 标注说明，该属性通常置于实体的属性声明语句之前，还可与 @Id 标注一起使用。</p>
<p>@Column 标注的常用属性是 name，用于设置映射数据库表的列名。此外，该标注还包含其它多个属性，如：unique 、nullable、length 等。</p>
<p>@Column 标注的 columnDefinition 属性: 表示该字段在数据库中的实际类型.通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型,但是对于Date类型仍无法确定数据库中字段类型究竟是DATE,TIME还是TIMESTAMP.此外,String的默认映射类型为VARCHAR, 如果要将 String 类型映射到特定数据库的 BLOB 或TEXT 字段类型.</p>
<p>@Column标注也可置于属性的getter方法之前</p>
<h3 id="Transient"><a href="#Transient" class="headerlink" title="@Transient"></a>@Transient</h3><p>表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性.</p>
<p>如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic</p>
<h3 id="Temporal"><a href="#Temporal" class="headerlink" title="@Temporal"></a>@Temporal</h3><p>在核心的 Java API 中并没有定义 Date 类型的精度(temporal precision).  而在数据库中,表示 Date 类型的数据有 DATE, TIME, 和 TIMESTAMP 三种精度(即单纯的日期,时间,或者两者 兼备). 在进行属性映射时可使用@Temporal注解来调整精度</p>
<p><img src="../images/image-20210612175625699.png" alt="image-20210612175625699"></p>
<p>对应数据库：</p>
<p><img src="../images/image-20210612175607590.png" alt="image-20210612175607590"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create table jpa_customers;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `jpa_customers` (</span><br><span class="line">  `id` int NOT NULL,</span><br><span class="line">  `birth` date DEFAULT NULL,</span><br><span class="line">  `createdTime` datetime(6) DEFAULT NULL,</span><br><span class="line">  `email` varchar(255) DEFAULT NULL,</span><br><span class="line">  `LAST_NAME` varchar(50) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>

<h2 id="4、JPA-API"><a href="#4、JPA-API" class="headerlink" title="4、JPA API"></a>4、JPA API</h2><h3 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h3><p>用于获取 EntityManagerFactory 实例。该类包含一个名为 createEntityManagerFactory 的 静态方法 。</p>
<p>createEntityManagerFactory 方法有如下两个重载版本。</p>
<ul>
<li>带有一个参数的方法以 JPA 配置文件 persistence.xml 中的持久化单元名为参数</li>
<li>带有两个参数的方法：前一个参数含义相同，后一个参数 Map类型，用于设置 JPA 的相关属性，这时将忽略其它地方设置的属性。Map 对象的属性名必须是 JPA 实现库提供商的名字空间约定的属性名。</li>
</ul>
<p><img src="../images/image-20210612184416168.png" alt="image-20210612184416168"></p>
<h3 id="EntityManagerFactory"><a href="#EntityManagerFactory" class="headerlink" title="EntityManagerFactory"></a>EntityManagerFactory</h3><p>EntityManagerFactory 接口主要用来创建 EntityManager 实例。该接口约定了如下4个方法：</p>
<ul>
<li><p>createEntityManager()：用于创建实体管理器对象实例。</p>
</li>
<li><p>createEntityManager(Map map)：用于创建实体管理器对象实例的重载方法，Map 参数用于提供 EntityManager 的属性。</p>
</li>
<li><p>isOpen()：检查 EntityManagerFactory 是否处于打开状态。实体管理器工厂创建后一直处于打开状态，除非调用close()方法将其关闭。</p>
</li>
<li><p>close()：关闭 EntityManagerFactory 。 EntityManagerFactory 关闭后将释放所有资源，isOpen()方法测试将返回 false，其它方法将不能调用，否则将导致IllegalStateException异常。</p>
</li>
</ul>
<h3 id="EntityManager"><a href="#EntityManager" class="headerlink" title="EntityManager"></a>EntityManager</h3><p>是完成持久化操作的核心对象。实体作为普通 Java 对象，只有在调用 EntityManager 将其持久化后才会变成持久化对象。EntityManager 对象在一组实体类与底层数据源之间进行 O/R 映射的管理。它可以用来管理和更新 Entity Bean, 根椐主键查找 Entity Bean, 还可以通过JPQL语句查询实体。</p>
<p> 实体的状态:</p>
<p>新建状态:   新创建的对象，尚未拥有持久性主键。</p>
<p>持久化状态：已经拥有持久性主键并和持久化建立了上下文环境</p>
<p>游离状态：拥有持久化主键，但是没有与持久化建立上下文环境</p>
<p>删除状态:  拥有持久化主键，已经和持久化建立上下文环境，但是从数据库中删除。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">// 返回指定的 OID 对应的实体类对象</span><br><span class="line">find (Class&lt;T&gt; entityClass,Object primaryKey)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getReference (Class&lt;T&gt; entityClass,Object primaryKey)</span><br><span class="line"></span><br><span class="line">// 用于将新创建的 Entity 纳入到 EntityManager 的管理</span><br><span class="line">persist (Object entity)</span><br><span class="line"></span><br><span class="line">remove (Object entity)</span><br><span class="line"></span><br><span class="line">// 用于处理 Entity 的同步。即数据库的插入和更新操作</span><br><span class="line">merge (T entity)</span><br><span class="line"></span><br><span class="line">// 同步持久上下文环境</span><br><span class="line">flush ()</span><br><span class="line"></span><br><span class="line">// 设置持久上下文环境的Flush模式，自动更新或者提交事务才刷新</span><br><span class="line">setFlushMode (FlushModeType flushMode)</span><br><span class="line"></span><br><span class="line">// 获取持久上下文环境的Flush模式</span><br><span class="line">getFlushMode ()</span><br></pre></td></tr></table></figure>

<h3 id="EntityTransaction"><a href="#EntityTransaction" class="headerlink" title="EntityTransaction"></a>EntityTransaction</h3><p><code>begin(), commit(), rollback()</code> 等</p>
<h2 id="5、映射关系"><a href="#5、映射关系" class="headerlink" title="5、映射关系"></a>5、映射关系</h2><h3 id="单向多对一"><a href="#单向多对一" class="headerlink" title="单向多对一"></a>单向多对一</h3><p>例如：多个订单属于一个客户</p>
<p>只需从n的一端可以访问1的一端</p>
<p>1、订单实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;jpa_order&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_name&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderName</span><span class="params">(String orderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射单向多对一关系,，多个订单属于一个客户</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span><span class="comment">// 映射外键，同时声明列名</span></span><br><span class="line">    <span class="meta">@ManyToOne</span><span class="comment">// 这里可以设置懒加载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customer = customer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, orderName=&#x27;&quot;</span> + orderName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, customer=&quot;</span> + customer +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManyToOne</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setLastName(<span class="string">&quot;小华&quot;</span>);</span><br><span class="line">    customer.setEmail(<span class="string">&quot;ff@163.com&quot;</span>);</span><br><span class="line">    customer.setCreatedTime(<span class="keyword">new</span> Date());</span><br><span class="line">    customer.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setOrderName(<span class="string">&quot;O-FF-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setOrderName(<span class="string">&quot;O-FF-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order3 = <span class="keyword">new</span> Order();</span><br><span class="line">    order3.setOrderName(<span class="string">&quot;O-FF-3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联关系</span></span><br><span class="line">    order1.setCustomer(customer);</span><br><span class="line">    order2.setCustomer(customer);</span><br><span class="line">    order3.setCustomer(customer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存</span></span><br><span class="line">    entityManager.persist(customer);</span><br><span class="line">    entityManager.persist(order1);</span><br><span class="line">    entityManager.persist(order2);</span><br><span class="line">    entityManager.persist(order3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果先保存订单，实际上会把订单的<code>customer_id</code>设为<code>null</code>，之后再进行更新操作，开销变大了</p>
<p>【建议】</p>
<p>先保存 1 的一端，再保存多的一端</p>
<p>删除的时候因为有外键关联，不能直接删除 1 的一端</p>
<h3 id="单向一对多"><a href="#单向一对多" class="headerlink" title="单向一对多"></a>单向一对多</h3><p>一个客户有多个订单</p>
<p>1、修改订单类，去掉 Customer 属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;jpa_order&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_name&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderName</span><span class="params">(String orderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、在用户里添加订单属性（是个集合或者列表）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射单向一对多</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line"><span class="meta">@OneToMany</span><span class="comment">// 默认懒加载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Order&gt; <span class="title">getOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> orders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrders</span><span class="params">(Set&lt;Order&gt; orders)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orders = orders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOneToMany</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setLastName(<span class="string">&quot;小华&quot;</span>);</span><br><span class="line">    customer.setEmail(<span class="string">&quot;gg@163.com&quot;</span>);</span><br><span class="line">    customer.setCreatedTime(<span class="keyword">new</span> Date());</span><br><span class="line">    customer.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setOrderName(<span class="string">&quot;O-GG-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setOrderName(<span class="string">&quot;O-GG-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order3 = <span class="keyword">new</span> Order();</span><br><span class="line">    order3.setOrderName(<span class="string">&quot;O-GG-3&quot;</span>);</span><br><span class="line">    customer.getOrders().add(order1);</span><br><span class="line">    customer.getOrders().add(order2);</span><br><span class="line">    customer.getOrders().add(order3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存</span></span><br><span class="line">    entityManager.persist(customer);</span><br><span class="line">    entityManager.persist(order1);</span><br><span class="line">    entityManager.persist(order2);</span><br><span class="line">    entityManager.persist(order3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【注意】：单向一对多保存时一定会有更新语句发生，与保存顺序无关。因为多的一端再插入时不会同时插入外键列</p>
<p>删除一的一端，会把关联的多的一端外键置空，然后删除，可以在<code>@OneToMany</code>设置级联删除</p>
<h3 id="双向多对一"><a href="#双向多对一" class="headerlink" title="双向多对一"></a>双向多对一</h3><p>订单属性里面有客户，客户里面有订单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Date createdTime;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Order&gt; <span class="title">getOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orders;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span><span class="comment">// 映射外键</span></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>映射的外键名要一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManyToOne</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">    customer.setLastName(<span class="string">&quot;小华&quot;</span>);</span><br><span class="line">    customer.setEmail(<span class="string">&quot;ww@163.com&quot;</span>);</span><br><span class="line">    customer.setCreatedTime(<span class="keyword">new</span> Date());</span><br><span class="line">    customer.setBirth(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">    order1.setOrderName(<span class="string">&quot;O-ww-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">    order2.setOrderName(<span class="string">&quot;O-ww-2&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联关系</span></span><br><span class="line">    order1.setCustomer(customer);</span><br><span class="line">    order2.setCustomer(customer);</span><br><span class="line"></span><br><span class="line">    customer.getOrders().add(order1);</span><br><span class="line">    customer.getOrders().add(order2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存</span></span><br><span class="line">    entityManager.persist(customer);<span class="comment">// n条update，写后面就是 2n 条</span></span><br><span class="line">    entityManager.persist(order1);</span><br><span class="line">    entityManager.persist(order2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果先保存多的一端，会有多余的更新语句</p>
<p>让多的一方来维护关联关系，在 @OneToMany 中设置 mapperBy（值为多的一方的 customer 属性）</p>
<p>【注意】</p>
<p>如果在 1 的一端 @OneToMany 中使用 mapperBy，就不能再使用 @JoinColumn</p>
<h3 id="双向一对一"><a href="#双向一对一" class="headerlink" title="双向一对一"></a>双向一对一</h3><p>基于外键的 1-1 关联关系：在双向的一对一关联中，需要在关系被维护端(inverse side)中的 @OneToOne 注释中指定 mappedBy，以指定是这一关联中的被维护端。同时需要在关系维护端(owner side)建立外键列指向关系被维护端的主键列。</p>
<p>设计：一个部门只能有一个经理，一个经理也只能管一个部门</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;jpa_manager&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String mgrName;</span><br><span class="line">    <span class="keyword">private</span> Department dept;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToOne(mappedBy = &quot;mgr&quot;)</span><span class="comment">// 不维护关联关系（等于说是我这张表里面没有这个字段，虽然属性里面有），需要设置 mappedBy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;jpa_department&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String deptName;</span><br><span class="line">    <span class="keyword">private</span> Manager mgr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToOne</span> <span class="comment">// 映射一对一关联关系，维护关联关系</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;mgr_id&quot;, unique = true)</span><span class="comment">// 一对一需要添加 unique=true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Manager <span class="title">getMgr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mgr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOneToOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Manager manager = <span class="keyword">new</span> Manager();</span><br><span class="line">    manager.setMgrName(<span class="string">&quot;M-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Department department = <span class="keyword">new</span> Department();</span><br><span class="line">    department.setDeptName(<span class="string">&quot;D-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联关系</span></span><br><span class="line">    manager.setDept(department);</span><br><span class="line">    department.setMgr(manager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    entityManager.persist(manager);<span class="comment">// 先保存不维护关联关系的（即没有外键的一方）</span></span><br><span class="line">    entityManager.persist(department);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认情况下，若获取维护关联关系的一方，则会通过左外连接获取其关联的对象</span></span><br><span class="line"><span class="comment">// 但是可以设置维护关联关系的一方的 @OneToOne 的 fetch 属性来修改加载策略来实现懒加载</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOneToOneFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Department dept = entityManager.find(Department.class, <span class="number">1</span>);</span><br><span class="line">    System.out.println(dept.getDeptName());</span><br><span class="line">    System.out.println(dept.getMgr().getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        department0<span class="built_in">_</span>.id as id1<span class="built_in">_</span>1<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        department0<span class="built_in">_</span>.deptName as deptname2<span class="built_in">_</span>1<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        department0<span class="built_in">_</span>.mgr<span class="built_in">_</span>id as mgr<span class="built_in">_</span>id3<span class="built_in">_</span>1<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        manager1<span class="built_in">_</span>.id as id1<span class="built_in">_</span>2<span class="built_in">_</span>1<span class="built_in">_</span>,</span><br><span class="line">        manager1<span class="built_in">_</span>.mgr<span class="built_in">_</span>name as mgr<span class="built_in">_</span>name2<span class="built_in">_</span>2<span class="built_in">_</span>1<span class="built_in">_</span> </span><br><span class="line">    from</span><br><span class="line">        jpa<span class="built_in">_</span>department department0<span class="built_in">_</span> </span><br><span class="line">    left outer join</span><br><span class="line">        jpa<span class="built_in">_</span>manager manager1<span class="built_in">_</span> </span><br><span class="line">            on department0<span class="built_in">_</span>.mgr<span class="built_in">_</span>id=manager1<span class="built_in">_</span>.id </span><br><span class="line">    where</span><br><span class="line">        department0<span class="built_in">_</span>.id=?</span><br><span class="line">D-1</span><br><span class="line">com.tcmyxc.helloworld.Manager</span><br></pre></td></tr></table></figure>



<p>【注意】：默认情况下，若获取不维护关联关系的一方，则也会通过左外连接获取其关联的对象，虽然可以改为懒加载，但是会多发 SQL 语句，得不偿失</p>
<h3 id="双向多对多"><a href="#双向多对多" class="headerlink" title="双向多对多"></a>双向多对多</h3><p>在双向多对多关系中，我们必须指定一个关系维护端(owner side),可以通过 @ManyToMany 注释中指定 mappedBy 属性来标识其为关系维护端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;jpa_item&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String itemName;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Category&gt; categories = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">// 不写会报空指针，因为不能直接使用接口，接口变量必须引用实现了接口的类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置多对多的关系</span></span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="comment">// 设置中间表</span></span><br><span class="line">    <span class="comment">// 1、joinColumns 映射当前类</span></span><br><span class="line">    <span class="comment">// 2、inverseJoinColumns 映射关联的类</span></span><br><span class="line">    <span class="meta">@JoinTable(joinColumns = &#123;</span></span><br><span class="line"><span class="meta">            @JoinColumn(name = &quot;item_id&quot;, // 中间表的外键名</span></span><br><span class="line"><span class="meta">                    referencedColumnName = &quot;id&quot;)// 外键指向当前表的那个字段</span></span><br><span class="line"><span class="meta">            &#125;,</span></span><br><span class="line"><span class="meta">            inverseJoinColumns = &#123;</span></span><br><span class="line"><span class="meta">            @JoinColumn(name = &quot;category_id&quot;,// 中间表的外键名</span></span><br><span class="line"><span class="meta">                    referencedColumnName = &quot;id&quot;)</span></span><br><span class="line"><span class="meta">            &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Category&gt; <span class="title">getCategories</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> categories;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;jpa_category&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Item&gt; items;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany(mappedBy = &quot;categories&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Item&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化表，可以发现建立了三张表</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    create table jpa<span class="built_in">_</span>category (</span><br><span class="line">       id integer not null auto<span class="built_in">_</span>increment,</span><br><span class="line">        category<span class="built_in">_</span>name varchar(255),</span><br><span class="line">        primary key (id)</span><br><span class="line">    ) engine=InnoDB</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    create table jpa<span class="built_in">_</span>item (</span><br><span class="line">       id integer not null auto<span class="built_in">_</span>increment,</span><br><span class="line">        item<span class="built_in">_</span>name varchar(255),</span><br><span class="line">        primary key (id)</span><br><span class="line">    ) engine=InnoDB</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    create table jpa<span class="built_in">_</span>item<span class="built_in">_</span>jpa<span class="built_in">_</span>category (</span><br><span class="line">       item<span class="built_in">_</span>id integer not null,</span><br><span class="line">        category<span class="built_in">_</span>id integer not null,</span><br><span class="line">        primary key (item<span class="built_in">_</span>id, category<span class="built_in">_</span>id)</span><br><span class="line">    ) engine=InnoDB</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    alter table jpa<span class="built_in">_</span>item<span class="built_in">_</span>jpa<span class="built_in">_</span>category </span><br><span class="line">       add constraint FKedbrfsg4dplyysrucevm258pk </span><br><span class="line">       foreign key (category<span class="built_in">_</span>id) </span><br><span class="line">       references jpa<span class="built_in">_</span>category (id)</span><br><span class="line">Hibernate: </span><br><span class="line">    </span><br><span class="line">    alter table jpa<span class="built_in">_</span>item<span class="built_in">_</span>jpa<span class="built_in">_</span>category </span><br><span class="line">       add constraint FK7vk3csx9i2cq3etibrkouumid </span><br><span class="line">       foreign key (item<span class="built_in">_</span>id) </span><br><span class="line">       references jpa<span class="built_in">_</span>item (id)</span><br></pre></td></tr></table></figure>



<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManyToMany</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Item i1 = <span class="keyword">new</span> Item();</span><br><span class="line">    Item i2 = <span class="keyword">new</span> Item();</span><br><span class="line"></span><br><span class="line">    i1.setItemName(<span class="string">&quot;item1&quot;</span>);</span><br><span class="line">    i2.setItemName(<span class="string">&quot;item2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Category c1 = <span class="keyword">new</span> Category();</span><br><span class="line">    Category c2 = <span class="keyword">new</span> Category();</span><br><span class="line">    Category c3 = <span class="keyword">new</span> Category();</span><br><span class="line"></span><br><span class="line">    c1.setCategoryName(<span class="string">&quot;C-1&quot;</span>);</span><br><span class="line">    c2.setCategoryName(<span class="string">&quot;C-2&quot;</span>);</span><br><span class="line">    c3.setCategoryName(<span class="string">&quot;C-3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置关联关系</span></span><br><span class="line">    i1.getCategories().add(c1);</span><br><span class="line">    i1.getCategories().add(c2);</span><br><span class="line">    i1.getCategories().add(c3);</span><br><span class="line"></span><br><span class="line">    i2.getCategories().add(c1);</span><br><span class="line">    i2.getCategories().add(c3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    entityManager.persist(i1);</span><br><span class="line">    entityManager.persist(i2);</span><br><span class="line">    entityManager.persist(c1);</span><br><span class="line">    entityManager.persist(c2);</span><br><span class="line">    entityManager.persist(c3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>很尴尬地失败了</p>
<p><img src="../images/image-20210616165321122.png" alt="image-20210616165321122"></p>
<p>错误原因：不能直接使用接口变量，接口变量必须引用实现了接口的类的实例。</p>
<p>解决方法：在类定义那里把接口变量改为正确的引用。</p>
<p>查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManyToManyFind</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Item item = entityManager.find(Item.class, <span class="number">1</span>);</span><br><span class="line">    System.out.println(item.getItemName());</span><br><span class="line"></span><br><span class="line">    System.out.println(item.getCategories().size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        item0<span class="built_in">_</span>.id as id1<span class="built_in">_</span>4<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        item0<span class="built_in">_</span>.item<span class="built_in">_</span>name as item<span class="built_in">_</span>nam2<span class="built_in">_</span>4<span class="built_in">_</span>0<span class="built_in">_</span> </span><br><span class="line">    from</span><br><span class="line">        jpa<span class="built_in">_</span>item item0<span class="built_in">_</span> </span><br><span class="line">    where</span><br><span class="line">        item0<span class="built_in">_</span>.id=?</span><br><span class="line">I-1</span><br><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        categories0<span class="built_in">_</span>.item<span class="built_in">_</span>id as item<span class="built_in">_</span>id1<span class="built_in">_</span>0<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        categories0<span class="built_in">_</span>.category<span class="built_in">_</span>id as category2<span class="built_in">_</span>0<span class="built_in">_</span>0<span class="built_in">_</span>,</span><br><span class="line">        category1<span class="built_in">_</span>.id as id1<span class="built_in">_</span>1<span class="built_in">_</span>1<span class="built_in">_</span>,</span><br><span class="line">        category1<span class="built_in">_</span>.category<span class="built_in">_</span>name as category2<span class="built_in">_</span>1<span class="built_in">_</span>1<span class="built_in">_</span> </span><br><span class="line">    from</span><br><span class="line">        item<span class="built_in">_</span>category categories0<span class="built_in">_</span> </span><br><span class="line">    inner join</span><br><span class="line">        jpa<span class="built_in">_</span>category category1<span class="built_in">_</span> </span><br><span class="line">            on categories0<span class="built_in">_</span>.category<span class="built_in">_</span>id=category1<span class="built_in">_</span>.id </span><br><span class="line">    where</span><br><span class="line">        categories0<span class="built_in">_</span>.item<span class="built_in">_</span>id=?</span><br><span class="line">2</span><br></pre></td></tr></table></figure>



<p>可以看出来，这里默认用的是懒加载。其实从分类里面查标签也是懒加载。</p>
<h2 id="6、JQPL"><a href="#6、JQPL" class="headerlink" title="6、JQPL"></a>6、JQPL</h2><p>Java Persistence Query Language 的简称。JPQL 是一种和 SQL 非常类似的中间性和对象化查询语言，它最终会被编译成针对不同底层数据库的 SQL 查询，从而屏蔽不同数据库的差异。</p>
<p>JPQL语言的语句可以是 select 语句、update 语句或delete语句，它们都通过 Query 接口封装执行</p>
<h3 id="Query-接口"><a href="#Query-接口" class="headerlink" title="Query 接口"></a>Query 接口</h3><p>Query接口封装了执行数据库查询的相关方法。调用 EntityManager 的 createQuery、create NamedQuery 及 createNativeQuery 方法可以获得查询对象，进而可调用 Query 接口的相关方法来执行查询操作。</p>
<h3 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h3><p>用于执行查询。其语法可表示为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">select_clause </span><br><span class="line">form_clause </span><br><span class="line">[where_clause] </span><br><span class="line">[groupby_clause] </span><br><span class="line">[having_clause]</span><br><span class="line">[orderby_clause]</span><br></pre></td></tr></table></figure>

<p>select、from 都是 JPQL 的关键字，通常全大写或全小写，建议不要大小写混用。</p>
<p><strong>查询所有</strong>实体的 JPQL 查询字串很简单，例如：</p>
<p>​    select o from Order o 或  select o from Order as o</p>
<p>关键字 as 可以省去。</p>
<p>标识符变量的命名规范与 Java 标识符相同，且区分大小写。</p>
<p>调用 EntityManager 的 createQuery() 方法可创建查询对象，接着调用 Query 接口的 getResultList() 方法就可获得查询结果集。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query query = entityManager.createQuery( <span class="string">&quot;select o from Order o&quot;</span>); </span><br><span class="line">List orders = query.getResultList();</span><br><span class="line">Iterator iterator = orders.iterator();</span><br><span class="line"><span class="keyword">while</span>( iterator.hasNext() ) &#123;</span><br><span class="line">	<span class="comment">// 处理Order</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JPQL也支持<strong>包含参数的查询</strong>，例如：</p>
<p>​    select o from Orders o where o.id = :myId</p>
<p>​    select o from Orders o where o.id = :myId and o.customer = :customerName</p>
<p>注意：参数名前必须冠以冒号(:)，执行查询前须使用Query.setParameter(name, value)方法给参数赋值。</p>
<p>可以<strong>不使用参数名而使用参数的序号</strong>，例如：</p>
<p>select o from Order o where o.id = ?1 and o.customer = ?2</p>
<p>其中 ?1 代表第一个参数，?2 代表第一个参数。在执行查询之前需要使用重载方法Query.setParameter(pos, value) 提供参数值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query query = entityManager.createQuery( <span class="string">&quot;select o from Orders o where o.id = ?1 and o.customer = ?2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 占位符的索引是从 1 开始的</span></span><br><span class="line">query.setParameter( <span class="number">1</span>, <span class="number">2</span> );</span><br><span class="line">query.setParameter( <span class="number">2</span>, <span class="string">&quot;John&quot;</span> );</span><br><span class="line">List orders = query.getResultList();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>JPQL也支持子查询，在 where 或 having 子句中可以包含另一个查询。</p>
<p><strong>查询部分属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询部分属性</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPartlyProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String jpql = <span class="string">&quot;select c.email, c.lastName from Customer c where c.id &gt; ?1&quot;</span>;</span><br><span class="line">    Query query = entityManager.createQuery(jpql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 占位符的索引是从 1 开始的</span></span><br><span class="line">    query.setParameter(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    List resultList = query.getResultList();</span><br><span class="line">    System.out.println(resultList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[[Ljava.lang.Object;@c6b2dd9, [Ljava.lang.Object;@73437222]</span><br></pre></td></tr></table></figure>

<p>可以看到是个 Object 数组</p>
<p>如果想返回对应类的对象，需要有对应参数的构造器，同时修改查询语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Customer 类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String lastName, String email)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    <span class="keyword">this</span>.email = email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试语句</span></span><br><span class="line">String jpql = <span class="string">&quot;select new Customer(c.email, c.lastName) from Customer c where c.id &gt; ?1&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[Customer&#123;id=null, lastName=&#x27;ww@163.com&#x27;, email=&#x27;小华&#x27;, createdTime=null, birth=null&#125;, Customer&#123;id=null, lastName=&#x27;ww@163.com&#x27;, email=&#x27;小华&#x27;, createdTime=null, birth=null&#125;]</span><br></pre></td></tr></table></figure>

<p>这里 JQPL 帮我们做了底层的转换，所以数组里面放的是 Customer 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(resultList.get(<span class="number">0</span>).getClass().getName());</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">com.tcmyxc.helloworld.Customer</span><br></pre></td></tr></table></figure>

<p><strong>查询语句也可以放在实体类头上</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NamedQuery(name = &quot;testNamedQuery&quot;, query = &quot;SELECT c FROM Customer c where c.id = ?1&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;JPA_CUSTOMERS&quot;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 指定 name，同时设置参数</span></span><br><span class="line">    Query query = entityManager.createNamedQuery(<span class="string">&quot;testNamedQuerySQL&quot;</span>).setParameter(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    Customer customer = (Customer) query.getSingleResult();</span><br><span class="line">    System.out.println(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Customer&#123;id=1, lastName=&#x27;小华&#x27;, email=&#x27;ww@163.com&#x27;, createdTime=2021-06-13 17:07:17.677, birth=2021-06-13&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Native SQL</strong></p>
<p>指原生的 SQL 语句，不再是 JQPL 的语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNativedQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;select birth from JPA_CUSTOMERS c where c.id = 1&quot;</span>;</span><br><span class="line">    Query query = entityManager.createNativeQuery(sql);</span><br><span class="line">    System.out.println(query.getSingleResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Hibernate: </span><br><span class="line">    select</span><br><span class="line">        birth </span><br><span class="line">    from</span><br><span class="line">        JPA<span class="built_in">_</span>CUSTOMERS c </span><br><span class="line">    where</span><br><span class="line">        c.id = 1</span><br><span class="line">2021-06-13</span><br></pre></td></tr></table></figure>



<p>JQPL 也支持 order by、group by、having、关联查询、子查询等</p>
<h3 id="update-和-delete"><a href="#update-和-delete" class="headerlink" title="update 和 delete"></a>update 和 delete</h3><p>更新操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;update Customer c set c.lastName = ?1 where c.id = ?2&quot;</span>;</span><br><span class="line">    Query query = entityManager.createQuery(sql);</span><br><span class="line">    query.setParameter(<span class="number">1</span>, <span class="string">&quot;YYY&quot;</span>).setParameter(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    query.executeUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210617115000945.png" alt="image-20210617115000945"></p>
<p>删除操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;delete from Order o where o.id = ?1&quot;</span>;</span><br><span class="line">    Query query = entityManager.createQuery(sql);</span><br><span class="line">    query.setParameter(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    query.executeUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/image-20210617120812216.png" alt="image-20210617120812216"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JPA</tag>
        <tag>JQPL</tag>
      </tags>
  </entry>
  <entry>
    <title>Dropwizard学习笔记</title>
    <url>/archives/8125fdfd.html</url>
    <content><![CDATA[<h1 id="Dropwizard是什么？"><a href="#Dropwizard是什么？" class="headerlink" title="Dropwizard是什么？"></a>Dropwizard是什么？</h1><p>一个用于开发操作友好、高性能、RESTful Web 服务的 <strong>Java 框架</strong></p>
<blockquote>
<p>Dropwizard 将Java 生态系统中稳定、成熟的库整合到一个 简单、轻量级的包中，让您可以专注于完成工作。</p>
<p>Dropwizard对复杂的配置、 应用程序指标、日志记录、操作工具等提供开箱即用的支持，使您和您的团队能够在尽可能短的时间内提供生产质量的Web 服务。</p>
</blockquote>
<p>官网：<a href="https://www.dropwizard.io/en/latest/">https://www.dropwizard.io/en/latest/</a></p>
<span id="more"></span>



<h2 id="几个重要的组件"><a href="#几个重要的组件" class="headerlink" title="几个重要的组件"></a>几个重要的组件</h2><h3 id="Jetty-for-HTTP"><a href="#Jetty-for-HTTP" class="headerlink" title="Jetty for HTTP"></a>Jetty for HTTP</h3><p>使用Jetty HTTP 库将一个经过优化的 HTTP 服务器直接嵌入到项目中</p>
<h3 id="Jersey-for-REST"><a href="#Jersey-for-REST" class="headerlink" title="Jersey for REST"></a>Jersey for REST</h3><p>将 HTTP 请求映射到简单的 Java 对象。</p>
<p>支持流输出、矩阵 URI 参数、条件GET请求等等</p>
<h3 id="Jackson-for-JSON"><a href="#Jackson-for-JSON" class="headerlink" title="Jackson for JSON"></a>Jackson for JSON</h3><h3 id="Metrics-for-metrics"><a href="#Metrics-for-metrics" class="headerlink" title="Metrics for metrics"></a>Metrics for metrics</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>日志：<a href="https://logback.qos.ch/">Logback</a>和<a href="https://www.slf4j.org/">slf4j</a></p>
<p><a href="http://hibernate.org/validator/">Hibernate Validator</a></p>
<p>等等</p>
<h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><h2 id="1、使用Maven生成项目"><a href="#1、使用Maven生成项目" class="headerlink" title="1、使用Maven生成项目"></a>1、使用Maven生成项目</h2><h2 id="2、基本的依赖"><a href="#2、基本的依赖" class="headerlink" title="2、基本的依赖"></a>2、基本的依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dropwizard.version</span>&gt;</span>2.0.22<span class="tag">&lt;/<span class="name">dropwizard.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql-connector.version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">mysql-connector.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.dropwizard/dropwizard-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.dropwizard<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dropwizard-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dropwizard.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- mysql --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3、创建配置类"><a href="#3、创建配置类" class="headerlink" title="3、创建配置类"></a>3、创建配置类</h2><p>每个 Dropwizard 应用程序都有自己的<code>Configuration</code>类，用于指定特定于环境的参数。这些参数在YAML配置文件中指定，该文件会被加载，然后被反序列化为应用程序配置类的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloConfiguration</span> <span class="keyword">extends</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String defaultName = <span class="string">&quot;Stranger&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTemplate</span><span class="params">(String template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDefaultName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defaultName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultName = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个类会从 YAML 文件中反序列化，会去找两个跟级字段：<code>template</code>以及<code>defaultName</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">template:</span> <span class="string">Hello,</span> <span class="string">%s!</span> <span class="comment"># %s 是占位符，这里相当于一个模板字符串</span></span><br><span class="line"><span class="attr">defaultName:</span> <span class="string">Stranger</span></span><br></pre></td></tr></table></figure>

<p>这个文件要放在项目根目录下面</p>
<h2 id="4、创建一个Application类"><a href="#4、创建一个Application类" class="headerlink" title="4、创建一个Application类"></a>4、创建一个Application类</h2><p>必须要重写 <code>run</code> 方法（这个方法是抽象方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApplication</span> <span class="keyword">extends</span> <span class="title">Application</span>&lt;<span class="title">HelloConfiguration</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HelloWorldApplication().run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Bootstrap&lt;HelloConfiguration&gt; bootstrap)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(HelloConfiguration helloConfiguration, Environment environment)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、创建DAO类（pojo"><a href="#5、创建DAO类（pojo" class="headerlink" title="5、创建DAO类（pojo)"></a>5、创建DAO类（pojo)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Saying</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Saying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Saying</span><span class="params">(<span class="keyword">long</span> id, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6、创建Resource类"><a href="#6、创建Resource类" class="headerlink" title="6、创建Resource类"></a>6、创建Resource类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Path(&quot;/get&quot;)</span></span><br><span class="line"><span class="meta">@Produces(MediaType.APPLICATION_JSON)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String tempalte;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String defaultName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong counter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloResource</span><span class="params">(String tempalte, String defaultName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tempalte = tempalte;</span><br><span class="line">        <span class="keyword">this</span>.defaultName = defaultName;</span><br><span class="line">        <span class="keyword">this</span>.counter = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Saying <span class="title">sayHello</span><span class="params">(<span class="meta">@QueryParam(&quot;name&quot;)</span>Optional&lt;String&gt; name)</span></span>&#123;</span><br><span class="line">        String value = String.format(tempalte, name.orElse(defaultName));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Saying(counter.incrementAndGet(), value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、注册Resource类使其生效"><a href="#7、注册Resource类使其生效" class="headerlink" title="7、注册Resource类使其生效"></a>7、注册Resource类使其生效</h2><p>在Application类中注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelloWorldApplication</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(HelloConfiguration configuration, Environment env)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// new 一个对象</span></span><br><span class="line">    HelloResource helloResource = <span class="keyword">new</span> HelloResource(configuration.getTemplate(), configuration.getDefaultName());</span><br><span class="line">    <span class="comment">// 注册到应用程序的 Jersey 环境</span></span><br><span class="line">    env.jersey().register(helloResource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8、启动"><a href="#8、启动" class="headerlink" title="8、启动"></a>8、启动</h2><p>命令行启动：</p>
<p>命令行启动的话需要把配置文件放在<strong>子工程</strong>的根目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入子工程根目录</span></span><br><span class="line">java -jar target/01-HelloWorld-1.0-SNAPSHOT.jar server hello.yml</span><br></pre></td></tr></table></figure>



<p>IDEA启动：</p>
<p>需要把配置文件放在<strong>父工程</strong>的根目录</p>
<p><img src="../images/image-20210619134441719.png" alt="image-20210619134441719"></p>
<p>也可以在命令中指定配置文件路径</p>
<p><img src="../images/image-20210619134554883.png" alt="image-20210619134554883"></p>
<h2 id="9、测试"><a href="#9、测试" class="headerlink" title="9、测试"></a>9、测试</h2><p><img src="../images/image-20210619134648237.png" alt="image-20210619134648237"></p>
<h1 id="Dropwizard-Core"><a href="#Dropwizard-Core" class="headerlink" title="Dropwizard Core"></a>Dropwizard Core</h1><h2 id="提供了什么？"><a href="#提供了什么？" class="headerlink" title="提供了什么？"></a>提供了什么？</h2><ul>
<li>Jetty，一个高性能的 HTTP 服务器。</li>
<li>Jersey，一个功能齐全的 RESTful Web 框架。</li>
<li>Jackson，JVM 的最佳 JSON 库。</li>
<li>Metrics，一个优秀的应用程序度量库。</li>
<li>Logback，Log4j 的继承者，Java 使用最广泛的日志框架。</li>
<li>Hibernate Validator，Java Bean 验证标准的参考实现。</li>
</ul>
<p>官方建议把项目分成三个模块：<code>project-api</code>，<code>project-client</code>，和 <code>project-application</code>。</p>
<p>api：简单的Java bean</p>
<p>client：处理HTTP请求</p>
<p>application：应用类</p>
<h2 id="日志功能"><a href="#日志功能" class="headerlink" title="日志功能"></a>日志功能</h2><p>Dropwizard 使用<a href="http://logback.qos.ch/">Logback</a>作为其日志记录后端。它提供了一个<a href="http://www.slf4j.org/">slf4j</a>实现</p>
<p>slf4j 提供以下日志级别：</p>
<ul>
<li><code>ERROR</code>：可能仍允许应用程序继续运行的错误事件。</li>
<li><code>WARN</code>：可能有害的情况。</li>
<li><code>INFO</code>：在粗粒度级别突出显示应用程序进度的信息性消息。</li>
<li><code>DEBUG</code>：对调试应用程序最有用的细粒度信息事件。</li>
<li><code>TRACE</code>：比<code>DEBUG</code>级别更细粒度的信息事件。</li>
</ul>
<p>如果不想使用可以排除，具体参考：<a href="https://www.dropwizard.io/en/latest/manual/core.html">https://www.dropwizard.io/en/latest/manual/core.html</a></p>
<p>日志保存到文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">appenders:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">file</span></span><br><span class="line">      <span class="comment"># The file to which current statements will be logged.</span></span><br><span class="line">      <span class="attr">currentLogFilename:</span> <span class="string">./logs/example.log</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># When the log file rotates, the archived log will be renamed to this and gzipped. The</span></span><br><span class="line">      <span class="comment"># %d is replaced with the previous day (yyyy-MM-dd). Custom rolling windows can be created</span></span><br><span class="line">      <span class="comment"># by passing a SimpleDateFormat-compatible format as an argument: &quot;%d&#123;yyyy-MM-dd-hh&#125;&quot;.</span></span><br><span class="line">      <span class="attr">archivedLogFilenamePattern:</span> <span class="string">./logs/example-%d.log.gz</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># The number of archived files to keep.</span></span><br><span class="line">      <span class="attr">archivedFileCount:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># The timezone used to format dates. HINT: USE THE DEFAULT, UTC.</span></span><br><span class="line">      <span class="attr">timeZone:</span> <span class="string">UTC</span></span><br></pre></td></tr></table></figure>



<h2 id="Jersey"><a href="#Jersey" class="headerlink" title="Jersey"></a>Jersey</h2><p>一个框架，用于将传入 HTTP 请求的各个方面映射到 POJO，然后将 POJO 的各个方面映射到传出 HTTP 响应。</p>
<h2 id="Servlet-过滤器"><a href="#Servlet-过滤器" class="headerlink" title="Servlet 过滤器"></a>Servlet 过滤器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateNotSpecifiedServletFilter</span> <span class="keyword">implements</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Other methods in interface omitted for brevity</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequest) &#123;</span><br><span class="line">            String dateHeader = ((HttpServletRequest) request).getHeader(HttpHeaders.DATE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dateHeader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                chain.doFilter(request, response); <span class="comment">// This signals that the request should pass this filter</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">                httpResponse.setStatus(HttpStatus.BAD_REQUEST_400);</span><br><span class="line">                httpResponse.getWriter().print(<span class="string">&quot;Date Header was not specified&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将这个 servlet 过滤器包装在自己的 Application 类中<code>FilterHolder</code>并将其添加到应用程序上下文中，并与此过滤器将激活哪些路径的规范一起注册到您的 Application 类中。下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">environment.servlets()</span><br><span class="line">    .addFilter(<span class="string">&quot;DateNotSpecifiedServletFilter&quot;</span>, </span><br><span class="line">               <span class="keyword">new</span> DateNotSpecifiedServletFilter()).addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), <span class="keyword">true</span>, <span class="string">&quot;/*&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ol>
<li>Dropwizard 的所有 API 的设计都考虑到了可测试性，即使应用程序也可以进行单元测试</li>
<li>可以自定义 banner，放在<code>src/main/resources</code>目录下即可</li>
<li>每个资源类都必须有一个<code>@Path</code>注解</li>
<li><code>@Timed</code> 测量对资源请求的持续时间（不能和 <code>@Metered</code> 同时使用</li>
<li><code>@Metered</code> 衡量资源被访问的速率</li>
<li><code>@ResponseMetered</code> 测量每类响应代码的速率（1xx/2xx/3xx/4xx/5xx）</li>
<li><code>@ExceptionMetered</code> 测量处理资源的异常发生的频率</li>
<li>JSON 的一个常见问题是<code>camelCase</code>和<code>snake_case</code>字段名称之间的分歧。Java 和 Javascript 的人往往喜欢<code>camelCase</code>；Ruby、Python 和 Perl 的人坚持使用 <code>snake_case</code>. 要使 Dropwizard 自动将字段名称转换为<code>snake_case</code>（并返回），只需在类上面加注解<code>@JsonSnakeCase</code></li>
<li>返回大量信息，使用流式输出可能会大大提高性能和效率。通过返回一个实现 Jersey<code>StreamingOutput</code> 接口的对象，您的方法可以在块编码的输出流中流式传输响应实体</li>
</ol>
<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>依赖注入机制的底层库是 Eclipse 的<a href="https://github.com/eclipse-ee4j/glassfish-hk2">HK2</a>，推荐 Spring</p>
<h1 id="JDBI"><a href="#JDBI" class="headerlink" title="JDBI"></a>JDBI</h1><p>JDBI是Java的SQL连接处理的便利工具库。它试图以Java中使用集合，bean等来映射关系来访问关系数据库，同时保持与JDBC相同的粒度</p>
<p>要创建<a href="https://www.dropwizard.io/en/latest/manual/core.html#man-core-managed">托管的</a>检测<code>Jdbi</code>实例， <a href="https://www.dropwizard.io/en/latest/manual/core.html#man-core-configuration">配置类</a>需要一个<code>DataSourceFactory</code>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConfiguration</span> <span class="keyword">extends</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> DataSourceFactory database = <span class="keyword">new</span> DataSourceFactory();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;database&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceFactory</span><span class="params">(DataSourceFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.database = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;database&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceFactory <span class="title">getDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> database;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在Application类的<code>run</code>方法中，创建一个新的<code>JdbiFactory</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ExampleConfiguration config, Environment environment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> JdbiFactory factory = <span class="keyword">new</span> JdbiFactory();</span><br><span class="line">    <span class="keyword">final</span> Jdbi jdbi = factory.build(environment, config.getDataSourceFactory(), <span class="string">&quot;postgresql&quot;</span>);</span><br><span class="line">    environment.jersey().register(<span class="keyword">new</span> UserResource(jdbi));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将创建一个到数据库的新<a href="https://www.dropwizard.io/en/latest/manual/core.html#man-core-managed">托管</a>连接池、一个用于连接到数据库的 <a href="https://www.dropwizard.io/en/latest/manual/core.html#man-core-healthchecks">运行状况检查</a>以及一个<code>Jdbi</code> 供您使用的新实例。</p>
<p>配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">database:</span></span><br><span class="line">  <span class="comment"># the name of your JDBC driver</span></span><br><span class="line">  <span class="attr">driverClass:</span> <span class="string">org.postgresql.Driver</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the username</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">pg-user</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the password</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">iAMs00perSecrEET</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the JDBC URL</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">jdbc:postgresql://db.example.com/db-prod</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># any properties specific to your JDBC driver:</span></span><br><span class="line">  <span class="attr">properties:</span></span><br><span class="line">    <span class="attr">charSet:</span> <span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the maximum amount of time to wait on an empty pool before throwing an exception</span></span><br><span class="line">  <span class="attr">maxWaitForConnection:</span> <span class="string">1s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the SQL query to run when validating a connection&#x27;s liveness</span></span><br><span class="line">  <span class="attr">validationQuery:</span> <span class="string">&quot;/* MyService Health Check */ SELECT 1&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the timeout before a connection validation queries fail</span></span><br><span class="line">  <span class="attr">validationQueryTimeout:</span> <span class="string">3s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the minimum number of connections to keep open</span></span><br><span class="line">  <span class="attr">minSize:</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the maximum number of connections to keep open</span></span><br><span class="line">  <span class="attr">maxSize:</span> <span class="number">32</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># whether or not idle connections should be validated</span></span><br><span class="line">  <span class="attr">checkConnectionWhileIdle:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the amount of time to sleep between runs of the idle connection validation, abandoned cleaner and idle pool resizing</span></span><br><span class="line">  <span class="attr">evictionInterval:</span> <span class="string">10s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the minimum amount of time an connection must sit idle in the pool before it is eligible for eviction</span></span><br><span class="line">  <span class="attr">minIdleTime:</span> <span class="number">1</span> <span class="string">minute</span></span><br></pre></td></tr></table></figure>



<p>建议使用 JDBI 的<a href="http://jdbi.org/#_sql_objects">SQL Objects API</a>，它允许将 DAO 类编写为接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDAO</span> </span>&#123;</span><br><span class="line">  <span class="meta">@SqlUpdate(&quot;create table something (id int primary key, name varchar(100))&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">createSomethingTable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SqlUpdate(&quot;insert into something (id, name) values (:id, :name)&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="meta">@Bind(&quot;id&quot;)</span> <span class="keyword">int</span> id, <span class="meta">@Bind(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SqlQuery(&quot;select name from something where id = :id&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">findNameById</span><span class="params">(<span class="meta">@Bind(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MyDAO dao = database.onDemand(MyDAO.class);</span><br></pre></td></tr></table></figure>

<h1 id="Dropwizard-Hibernate"><a href="#Dropwizard-Hibernate" class="headerlink" title="Dropwizard Hibernate"></a>Dropwizard Hibernate</h1><h2 id="1、需要一个DataSourceFactory-实例"><a href="#1、需要一个DataSourceFactory-实例" class="headerlink" title="1、需要一个DataSourceFactory 实例"></a>1、需要一个<code>DataSourceFactory</code> 实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleConfiguration</span> <span class="keyword">extends</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> DataSourceFactory database = <span class="keyword">new</span> DataSourceFactory();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;database&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceFactory <span class="title">getDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> database;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;database&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceFactory</span><span class="params">(DataSourceFactory dataSourceFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.database = dataSourceFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、在应用类中注册这个实例"><a href="#2、在应用类中注册这个实例" class="headerlink" title="2、在应用类中注册这个实例"></a>2、在应用类中注册这个实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HibernateBundle&lt;ExampleConfiguration&gt; hibernate = <span class="keyword">new</span> HibernateBundle&lt;ExampleConfiguration&gt;(Person.class) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceFactory <span class="title">getDataSourceFactory</span><span class="params">(ExampleConfiguration configuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configuration.getDataSourceFactory();<span class="comment">// 在这里创建并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Bootstrap&lt;ExampleConfiguration&gt; bootstrap)</span> </span>&#123;</span><br><span class="line">    bootstrap.addBundle(hibernate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册自定义的实体类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ExampleConfiguration config, Environment environment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> PersonDAO dao = <span class="keyword">new</span> PersonDAO(hibernate.getSessionFactory());</span><br><span class="line">    environment.jersey().register(<span class="keyword">new</span> UserResource(dao));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实体类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDAO</span> <span class="keyword">extends</span> <span class="title">AbstractDAO</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonDAO</span><span class="params">(SessionFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">findById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">create</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> persist(person).getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list(namedTypedQuery(<span class="string">&quot;com.example.helloworld.core.Person.findAll&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractDAO</code>：一个用于特定于实体的 DAO 类的最小模板。它包含用于<code>SessionFactory</code>的常见操作的类型安全包装器</p>
<p>配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">database:</span></span><br><span class="line">  <span class="comment"># the name of your JDBC driver</span></span><br><span class="line">  <span class="attr">driverClass:</span> <span class="string">org.postgresql.Driver</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the username</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">pg-user</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the password</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">iAMs00perSecrEET</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the JDBC URL</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">jdbc:postgresql://db.example.com/db-prod</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># any properties specific to your JDBC driver:</span></span><br><span class="line">  <span class="attr">properties:</span></span><br><span class="line">    <span class="attr">charSet:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">hibernate.dialect:</span> <span class="string">org.hibernate.dialect.PostgreSQLDialect</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the maximum amount of time to wait on an empty pool before throwing an exception</span></span><br><span class="line">  <span class="attr">maxWaitForConnection:</span> <span class="string">1s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the SQL query to run when validating a connection&#x27;s liveness</span></span><br><span class="line">  <span class="attr">validationQuery:</span> <span class="string">&quot;/* MyApplication Health Check */ SELECT 1&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the minimum number of connections to keep open</span></span><br><span class="line">  <span class="attr">minSize:</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># the maximum number of connections to keep open</span></span><br><span class="line">  <span class="attr">maxSize:</span> <span class="number">32</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># whether or not idle connections should be validated</span></span><br><span class="line">  <span class="attr">checkConnectionWhileIdle:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GET</span></span><br><span class="line"><span class="meta">@Path(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Timed</span></span><br><span class="line"><span class="meta">@UnitOfWork</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">findPerson</span><span class="params">(<span class="meta">@PathParam(&quot;id&quot;)</span> LongParam id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dao.findById(id.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



































































]]></content>
      <categories>
        <category>Java</category>
        <category>Dropwizard</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Dropwizard</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统概念</title>
    <url>/archives/531663ae.html</url>
    <content><![CDATA[<h1 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h1><blockquote>
<p>  参考文献：</p>
<ul>
<li>  [1]操作系统概念（第九版） - 机械工业出版社</li>
<li>  [2]OS 课件（感谢JJM老师）</li>
</ul>
</blockquote>
<span id="more"></span>



<h1 id="第一章：简介"><a href="#第一章：简介" class="headerlink" title="第一章：简介"></a>第一章：简介</h1><h2 id="1、特权指令和非特权指令"><a href="#1、特权指令和非特权指令" class="headerlink" title="1、特权指令和非特权指令"></a>1、特权指令和非特权指令</h2><p>特权指令：不允许用户程序中直接使用的指令。例如：I/O指令、设置时钟、 置控制寄存器等指令都是特权指令。 </p>
<p>非特权指令:用户程序中所使用的指令。</p>
<h2 id="2、用户态和内核态"><a href="#2、用户态和内核态" class="headerlink" title="2、用户态和内核态"></a>2、用户态和内核态</h2><p>内核态 </p>
<ul>
<li>  能够访问所有系统资源，可以执行特权指令，可以直接操作和管理硬件设备。 </li>
<li>  操作系统内核程序运行在内核态下 </li>
<li>  使用内核栈 </li>
</ul>
<p>用户态 </p>
<ul>
<li>  只能访问属于它的存储空间和普通寄存器，只能执行普通指令。 </li>
<li>  用户程序以及操作系统核外服务程序运行在用户态下 </li>
<li>  使用用户栈</li>
</ul>
<h2 id="3、分布式系统"><a href="#3、分布式系统" class="headerlink" title="3、分布式系统"></a>3、分布式系统</h2><p>定义：物理上分开的、可能异构的、通过网络相连的一组计算机系统。</p>
<h1 id="第二章：操作系统结构"><a href="#第二章：操作系统结构" class="headerlink" title="第二章：操作系统结构"></a>第二章：操作系统结构</h1><h2 id="1、系统调用"><a href="#1、系统调用" class="headerlink" title="1、系统调用"></a>1、系统调用</h2><p>系统调用：进程和内核之间的程序接口。</p>
<ul>
<li>  系统调用的实现是在内核完成的</li>
<li>  系统调用是通过软中断向内核发出一个明确的请求，每个系统调用对应一个封装例程（wrapper routine，唯一目的就是发布系统调用）</li>
</ul>
<p>分为六大类：</p>
<p>进程控制、文件管理、设备管理、信息维护、通信、保护</p>
<h2 id="2、如何向操作系统提供参数？"><a href="#2、如何向操作系统提供参数？" class="headerlink" title="2、如何向操作系统提供参数？"></a>2、如何向操作系统提供参数？</h2><ul>
<li>  通过寄存器</li>
<li>  存在内存的块或表中，块地址再作为参数传给寄存器</li>
<li>  放在栈里面，让操作系统弹出</li>
</ul>
<p>后面两种方法不限制参数的数量和长度</p>
<h2 id="几个Linux命令"><a href="#几个Linux命令" class="headerlink" title="几个Linux命令"></a>几个Linux命令</h2><p><code>lsmod</code>：查看所有内核模块</p>
<p><code>insmod 模块名</code>：加载内核模块</p>
<p><code>rmmod 模块名（不需要.ko后缀</code>：卸载模块</p>
<p><code>dmesg</code>：查看系统启动信息</p>
<h1 id="第三章：进程"><a href="#第三章：进程" class="headerlink" title="第三章：进程"></a>第三章：进程</h1><h2 id="1、进程是什么？"><a href="#1、进程是什么？" class="headerlink" title="1、进程是什么？"></a>1、进程是什么？</h2><ul>
<li>一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。进程是操作系统进行资源分配和调度的一个独立单位。</li>
<li>正在执行中的程序 a program in execution</li>
</ul>
<p><img src="../images/image-20210120155904570.png" alt="image-20210120155904570"></p>
<blockquote>
<p>  张尧学，计算机操作系统教程，清华大学出版社</p>
</blockquote>
<p><img src="../images/image-20200626162307991.png" alt="image-20200626162307991"></p>
<h2 id="2、进程组成"><a href="#2、进程组成" class="headerlink" title="2、进程组成"></a>2、进程组成</h2><ul>
<li>代码段</li>
<li>数据段（全局变量）</li>
<li>堆（动态申请空间）</li>
<li>程序计数器（PC）</li>
<li>一组寄存器</li>
<li>栈（临时变量）</li>
</ul>
<p>示意图：</p>
<p><img src="../images/image-20210120160234236.png" alt="image-20210120160234236"></p>
<p>PCB（进程控制块）</p>
<ul>
<li>进程状态</li>
<li>程序计数器</li>
<li>CPU寄存器</li>
<li>CPU调度信息</li>
<li>内存管理信息</li>
<li>记账信息</li>
<li>IO状态信息</li>
</ul>
<h2 id="3、进程状态（5个）"><a href="#3、进程状态（5个）" class="headerlink" title="3、进程状态（5个）"></a>3、进程状态（5个）</h2><p>new、running、ready、waiting、terminated</p>
<p><img src="../images/image-20200626162734708.png" alt="image-20200626162734708"></p>
<p>一个处理器一次只能运行一个进程</p>
<p>三个基本状态之间可能转换和转换原因如下：</p>
<ul>
<li>  就绪→运行：当处理器空闲时，进程调度程序必将处理机分配给一个处于就绪状态的进程 ，该进程便由就绪状态转换为运行状态。</li>
<li>  运行→等待：处于运行状态的进程在运行过程中需要等待某一事件发生后（例如因I／O请求等待I／O完成后），才能继续运行，则该进程放弃处理器，从运行状态转换为等待状态。</li>
<li>  等待→就绪：处于等待状态的进程，若其等待的事件已经发生，于是进程由等待状态转换为就绪状态。</li>
<li>  运行→就绪：处于运行状态的进程在其运行过程中，因分给它的处理器时间片已用完，而不得不让出（被抢占）处理器，于是进程由运行态转换为就绪态。</li>
</ul>
<p>等待→运行，就绪→等待这二种状态转换一般不可能发生。</p>
<p>处于运行状态进程：如系统有一个处理器，则在任何一时刻，最多只有一个进程处于运行状态。</p>
<p>处于就绪状态进程：一般处于就绪状态的进程按照一定的算法（如先来的进程排在前面，或采用优先权高的进程排在前面）排成一个就绪队列。</p>
<p>处于等待状态进程：处于等待状态的进程排在等待队列中。由于等待事件原因不同，等待队列也可以按事件分成几个队列。</p>
<h2 id="4、进程和程序"><a href="#4、进程和程序" class="headerlink" title="4、进程和程序"></a>4、进程和程序</h2><ul>
<li>进程是动态的，程序是静态的</li>
<li>进程是暂时的，程序是永久的</li>
<li>进程与程序的组成不同：进程的组成包括程序、数据和进程控制块（即进程状态信息）</li>
<li>通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序</li>
</ul>
<h2 id="5、进程调度"><a href="#5、进程调度" class="headerlink" title="5、进程调度"></a>5、进程调度</h2><p>调度队列和调度程序</p>
<p>上下文切换：切换 CPU 到另外一个进程需要保存当前进程的状态，同时恢复另一个进程的状态</p>
<p>进程上下文用进程 PCB 表示</p>
<h2 id="6、进程操作"><a href="#6、进程操作" class="headerlink" title="6、进程操作"></a>6、进程操作</h2><h3 id="6-1-创建进程"><a href="#6-1-创建进程" class="headerlink" title="6.1 创建进程"></a>6.1 创建进程</h3><p><img src="../images/image-20210120162500381.png" alt="image-20210120162500381"></p>
<p>进程标识符（pid）唯一标识一个进程</p>
<p>子进程可能共享父进程的所有资源或者部分资源，或者直接不共享</p>
<p>创建新进程，可以使用 fork() 这个系统调用</p>
<ul>
<li>  子进程继承了父进程的地址空间</li>
<li>  子进程 PID 是 0，父进程的 PID 值是子进程的 PID</li>
</ul>
<h3 id="6-2-进程终止"><a href="#6-2-进程终止" class="headerlink" title="6.2 进程终止"></a>6.2 进程终止</h3><p>引起进程终止的事件：</p>
<ul>
<li>  正常结束</li>
<li>  异常结束</li>
<li>  外界干预</li>
</ul>
<p>僵尸进程：进程已经中止，但父进程未调用wait()</p>
<p>孤儿进程：父进程未调用wait()就终止了，处理方式：将init进程（1号进程）作为孤儿进程的父进程</p>
<h3 id="6-3-进程通信-Interprocess-Communication，IPC"><a href="#6-3-进程通信-Interprocess-Communication，IPC" class="headerlink" title="6.3 进程通信(Interprocess Communication，IPC)"></a>6.3 进程通信(Interprocess Communication，IPC)</h3><p>IPC为进程提供了一种无需共享相同地址空间就可以进行通信和同步操作的机制</p>
<p>两种模型：共享内存、消息传递</p>
<p><img src="../images/image-20210123094831885.png" alt="image-20210123094831885"></p>
<p>通信类型：直接通信、间接通信</p>
<p>常用通信机制：</p>
<ul>
<li>信号(signal)</li>
<li>共享存储区(shared memory)</li>
<li>管道(pipe)</li>
<li>消息(message)</li>
<li>套接字(socket)</li>
</ul>
<p>Linux实现进程间通信(IPC Inter Process Communication)：</p>
<ul>
<li><p>System V IPC机制:</p>
<ul>
<li>信号量、 消息队列、 共享内存</li>
</ul>
</li>
<li><p>管道（pipe）、命名管道 </p>
</li>
<li><p>套接字（socket）</p>
</li>
<li><p>信号( signal )</p>
</li>
<li><p>文件锁(file lock)</p>
</li>
<li><p>POSIX线程：</p>
<ul>
<li>互斥锁(互斥体、互斥量)（mutex）、条件变量(condition variables)</li>
</ul>
</li>
<li><p>POSIX：</p>
<ul>
<li>消息队列、信号量、共享内存</li>
</ul>
</li>
</ul>
<h2 id="7、IPC"><a href="#7、IPC" class="headerlink" title="7、IPC"></a>7、IPC</h2><h3 id="7-1-共享内存"><a href="#7-1-共享内存" class="headerlink" title="7.1 共享内存"></a>7.1 共享内存</h3><ul>
<li>  希望通信的进程之间共享的一块内存区域</li>
<li>  通信在用户进程的控制下，而不是操作系统的控制下。</li>
<li>  主要问题是提供一种机制，允许用户进程在访问共享内存时同步它们的操作</li>
<li>  协同进程的并发执行需要允许进程之间进行通信并同步它们的动作的机制</li>
<li>生产者-消费者问题<ul>
<li>  有界缓冲区</li>
<li>  无界缓冲区</li>
</ul>
</li>
</ul>
<h3 id="7-2-消息传递"><a href="#7-2-消息传递" class="headerlink" title="7.2 消息传递"></a>7.2 消息传递</h3><p>进程之间的通信不需要依赖共享变量</p>
<p>如果 P 和 Q 要通信，需要两步：</p>
<p>1、建立连接</p>
<p>2、交换信息</p>
<p><strong>直接通信</strong></p>
<ul>
<li>  明确说明要发给谁或者从谁接收信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">send (P, message) – send a message to process P</span><br><span class="line">receive(Q, message) – receive a message from process Q</span><br></pre></td></tr></table></figure>

<p>通信连接的特性：</p>
<ul>
<li>  连接自动建立</li>
<li>  一个链接只与一对通信进程相关联，换言之，一对通信之间只有一个链接</li>
<li>  链接可能是单向的，但通常是双向的</li>
</ul>
<p><strong>间接通信</strong></p>
<ul>
<li>  从邮箱(mailbox，也称为端口)定向和接收消息</li>
<li>  每个邮箱都有一个唯一的id</li>
<li>  进程只有在共享邮箱时才能通信</li>
</ul>
<p>通信链路的特性</p>
<ul>
<li>  仅当进程共享一个公共邮箱时才建立链接</li>
<li>  一个链接可能与许多进程相关联</li>
<li>  每一对进程可以共享几个通信链路</li>
<li>  链接可以是单向的，也可以是双向的</li>
</ul>
<h2 id="8、同步异步"><a href="#8、同步异步" class="headerlink" title="8、同步异步"></a>8、同步异步</h2><p>消息传递可以是阻塞的，也可以是非阻塞的</p>
<p><strong>阻塞</strong>被认为是<strong>同步</strong>的。</p>
<ul>
<li><p>  阻塞发送——发送方被阻塞，直到接收方接收到消息</p>
</li>
<li><p>  阻塞接收——接收者被阻塞，直到有消息可用</p>
</li>
</ul>
<p><strong>非阻塞</strong>被视为<strong>异步</strong>的</p>
<ul>
<li><p>  非阻塞发送——发送者发送消息并继续</p>
</li>
<li><p>  非阻塞接收——接收方接收到有效的消息，或空消息</p>
</li>
</ul>
<p><strong>RPC</strong></p>
<p>如同调用本地过程一样调用远程主机的过程</p>
<p><strong>管道</strong></p>
<ul>
<li>  普通管道：单向（单工）通信，标准的生产者消费者方式进行通信——生产者向管道一端写入，消费者从管道另一端读出；进程通信时管道才存在</li>
<li>  命名管道：可以双向通信，一个管道可以被多个进程使用</li>
</ul>
<h2 id="9、几个命令"><a href="#9、几个命令" class="headerlink" title="9、几个命令"></a>9、几个命令</h2><p>查看所有活动进程的详细信息：<code>ps -el</code></p>
<p><img src="../images/image-20210120161756889.png" alt="image-20210120161756889"></p>
<p>杀进程：<code>kill -9 进程号</code></p>
<p>查看文件：<code>cat 文件名</code></p>
<h1 id="第四章：线程和并发"><a href="#第四章：线程和并发" class="headerlink" title="第四章：线程和并发"></a>第四章：线程和并发</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>线程定义为进程内一个执行单元或一个可调度实体。</p>
<p>线程只拥有一点在运行中必不可省的资源（程序计数器、一组寄存器和栈），但它可与同属一个进程的其它线程共享进程拥有的全部资源。</p>
<p>通常，使用一个包含读个线程的进程更加有效</p>
<p>延伸：</p>
<ul>
<li>  线程私有的：线程ID、程序计数器、一组寄存器和栈</li>
<li>  线程共享的：代码段、数据段、其他操作系统资源</li>
</ul>
<p>资源拥有单元称为进程，调度的单位称为线程。</p>
<p>线程：</p>
<ul>
<li>  有执行状态（状态转换）</li>
<li>  不运行时保存上下文</li>
<li>  有一个执行栈</li>
<li>  有一些局部变量的静态存储</li>
<li>  可存取所在进程的内存和其他资源</li>
<li>  可以创建、撤消另一个线程</li>
</ul>
<p>线程的特点：</p>
<ul>
<li>  不拥有系统资源（只拥有少量的资源，资源是分配给进程） </li>
<li>  一个进程中的多个线程可并发执行（进程可创建线程执行同一程序的不同部分） </li>
<li>  系统开销小、切换快。（进程的多个线程都在进程的地址空间活动）</li>
</ul>
<p>优点：</p>
<ul>
<li>  <strong>创建一个新线程花费时间少</strong>（结束亦如此）</li>
<li>  <strong>两个线程的切换花费时间少</strong>（如果机器设有“存储[恢复]所有寄存器”指令，则整个切换过程用几条指令即可完成）</li>
<li>  <strong>通信方便</strong>：因为同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核</li>
<li>  <strong>适合多处理机系统</strong></li>
</ul>
<h2 id="2、线程的实现机制"><a href="#2、线程的实现机制" class="headerlink" title="2、线程的实现机制"></a>2、线程的实现机制</h2><blockquote>
<p>  了解即可</p>
</blockquote>
<p><strong>用户级线程</strong>：不依赖于OS核心（内核不了解用户线程的存在），应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程</p>
<p>调度由应用软件内部进行，通常采用非抢占式和更简单的规则，也无需用户态/核心态切换，所以速度特别快。</p>
<p>一个线程发起系统调用而阻塞，则整个进程在等待。 </p>
<p>特点：</p>
<ul>
<li>  用户线程的维护由应用进程完成；</li>
<li>  内核不了解用户线程的存在；</li>
<li>  用户线程切换不需要内核特权；</li>
<li>  用户线程调度算法可针对应用优化；</li>
<li>  一个线程发起系统调用而阻塞，则整个进程在等待。（一对多模型中）</li>
</ul>
<p><strong>内核级线程</strong>：依赖于OS核心，由内核的内部需求进行创建和撤销，用来执行一个指定的函数。一个线程发起系统调用而阻塞，不会影响其他线程。时间片分配给线程，所以多线程的进程获得更多CPU时间。</p>
<p>特点：</p>
<ul>
<li>  内核维护进程和线程的上下文信息；</li>
<li>  线程切换由内核完成；</li>
<li>  时间片分配给线程，所以多线程的进程获得更多CPU时间；</li>
<li>  一个线程发起系统调用而阻塞，不会影响其他线程的运行。</li>
</ul>
<p>并行：同时执行多个任务</p>
<p>并发：支持多个任务，并允许所有任务都有其进展</p>
<p>用户级线程和内核级线程的映射关系：</p>
<p>1、一对一：一个用户级线程对应一个内核级线程。一个线程阻塞，整个进程阻塞；不能用在多核处理器上</p>
<p>2、多对一：多个用户级线程对应一个内核级线程。内核级线程数量需要限制；允许多个线程并行运行在多处理器上；没有增加并发（内核一次只能调度一个线程）</p>
<p>3、多对多：多路复用多个用户级线程到同等数量或者数量更少的内核线程上。</p>
<p>多线程创建的策略：</p>
<p>1、同步线程：父线程创建子线程后，等到所有的子线程执行完毕，自己才继续执行（分叉-连接策略）。这里，由父线程创建的线程并发执行工作，但是父线程在这个工作完成之前无法继续。一旦每个线程完成了它的工作，它就会终止，并与父线程连接。只有在所有子线程都连接之后，父线程才恢复执行。通常，同步线程涉及线程之间的大量数据的共享。例如，父线程可以组合由子线程计算的结果。</p>
<p>2、异步线程：父线程创建子线程后，自己恢复自身的执行，这样父线程与子线程会并发执行。每个线程的运行独立于其他线程，父线程无需知道子线程何时终止。由于线程是独立的，所以线程之间通常很少有数据共享。</p>
<p><img src="../images/image-20210123113518672.png" alt="image-20210123113518672"></p>
<h2 id="3、线程池"><a href="#3、线程池" class="headerlink" title="3、线程池"></a>3、线程池</h2><p>主要思想是:在进程开始时创建一定数量的线程，并加到池中以等待工作。当服务器收到请求时，它会唤醒池内的一个线程(如果有可用线程)，并将需要服务的请求传递给它。一旦线程完成了服务，它会返回到池中再等待工作。如果池内没有可用线程，那么服务器会等待,直到有空线程为止。</p>
<p>线程池具有以下优点:</p>
<ul>
<li>  用现有线程服务请求比等待创建一个线程更快。</li>
<li>  线程池<strong>限制了任何时候可用线程的数量</strong>。这对那些不能支持大量并发线程的系统非常重要。</li>
<li>  <strong>每个线程的运行策略可定制</strong>：将要执行任务从创建任务的机制中分离出来，允许我们采用不同策略运行任务。例如，任务可以被安排在某一个时间延迟后执行,或定期执行。</li>
<li>  <strong>可以提前估算线程池大小</strong>：池内线程的数量可以通过一些因素来加以估算，如系统CPU的数量、物理内存的大小和并发客户请求数量的期望值等。更为高级的线程池架构可以根据使用模式动态调整池内线程数量。这类架构在系统负荷低时，提供了较小的池，从而减低内存消耗。</li>
</ul>
<h1 id="第五章：进程调度"><a href="#第五章：进程调度" class="headerlink" title="第五章：进程调度"></a>第五章：进程调度</h1><h2 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h2><p>CPU 调度 = 处理器调度 = 进程调度</p>
<p>单处理器系统：同一时间只有一个进程可以运行</p>
<p>多处理器系统：多个进程同时处于内存。当一个进程等待时，操作系统就从该进程接管 CPU 控制权，并把 CPU 交给另外一个进程。</p>
<p>三层调度模型：</p>
<p><img src="../images/image-20210201152812097.png" alt="image-20210201152812097"></p>
<h3 id="5-1-1-CPU-调度程序"><a href="#5-1-1-CPU-调度程序" class="headerlink" title="5.1.1 CPU 调度程序"></a>5.1.1 CPU 调度程序</h3><p>每当 CPU 空闲的时候，操作系统就应该从就绪队列中选择一个进程来执行。干这个工作的叫做 <strong>CPU 调度程序</strong>。调度程序从内存里面选择一个可以执行的进程，并为其分配 CPU</p>
<p>队列里面放的是进程控制块（PCB）</p>
<h3 id="5-1-2-什么时候需要进程调度？"><a href="#5-1-2-什么时候需要进程调度？" class="headerlink" title="5.1.2 什么时候需要进程调度？"></a>5.1.2 什么时候需要进程调度？</h3><ol>
<li> 运行状态切换到等待状态（ IO 请求）</li>
<li> 运行状态切换到就绪状态（出现中断）</li>
<li> 等待切换到就绪（IO 请求完成）</li>
<li> 进程终止</li>
</ol>
<p><img src="../images/image-20210201153740780.png" alt="image-20210201153740780"></p>
<p>调度方式：</p>
<p>非抢占式（Nonpreemptive）调度:调度程序一旦把处理器分配给某进程后便让它一直运行下去，直到进程完成或发生某事件而阻塞时，才把处理器分配给另一个进程。如上1、4</p>
<p>抢占式（Preemptive）调度:当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。剥夺原则有：优先权原则、短进程优先原则、时间片原则。如上2、3</p>
<h3 id="5-1-3-Dispatcher（调度程序）"><a href="#5-1-3-Dispatcher（调度程序）" class="headerlink" title="5.1.3 Dispatcher（调度程序）"></a>5.1.3 Dispatcher（调度程序）</h3><p>是个模块，把 CPU 的控制权交给<strong>短期调度程序</strong>选择的进程</p>
<p>功能：</p>
<ul>
<li>  切换上下文</li>
<li>  切换到用户模式</li>
<li>  跳转到用户程序的合适位置，以便重新启动程序</li>
</ul>
<p>特点：尽可能快。因为每次进程切换都需要使用。</p>
<p>Dispatch latency（调度延迟） ：调度程序停止一个进程到启动一个进程所需要的时间</p>
<p>Linux命令：vmstat</p>
<h2 id="5-2-调度准则"><a href="#5-2-调度准则" class="headerlink" title="5.2 调度准则"></a>5.2 调度准则</h2><p><strong>最大化 CPU 利用率和吞吐量，最小化周转时间、等待时间和响应时间，公平！！</strong></p>
<p>周转时间Turnaround time ：进程从提交到完成所经历的时间。包括：在CPU上执行，就绪队列和阻塞队列中等待。</p>
<p>响应时间Response time ：从进程提出请求到首次被响应（而不是输出结果）的时间段（在分时系统环境下）</p>
<p>等待时间Waiting time  – 进程在就绪队列中等待的时间总和</p>
<p>公平性：不因作业或进程本身的特性而使上述指标过分恶化。如长进程等待很长时间。</p>
<p>优先级：可以使关键任务达到更好的指标</p>
<p>调度算法本身的调度性能准则</p>
<ul>
<li>  易于实现</li>
<li>  执行开销比较小</li>
</ul>
<h2 id="5-3-调度算法"><a href="#5-3-调度算法" class="headerlink" title="5.3 调度算法"></a>5.3 调度算法</h2><ul>
<li>  First-Come, First-Served (FCFS) Scheduling     <strong>先来先服务</strong>调度</li>
<li>  Shortest-Job-First (SJF) Scheduling                     <strong>短作业优先</strong>调度</li>
<li>  Priority Scheduling                                               <strong>优先权</strong>调度</li>
<li>  Round Robin (RR)                                                 <strong>时间片轮转</strong>调度</li>
<li>  Multilevel Queue Scheduling                             <strong>多级队列</strong>调度</li>
<li>  Multilevel Feedback Queue Scheduling           多级反馈队列调度</li>
<li>高响应比优先调度算法 Highest Response Ratio Next(HRRN)<ul>
<li>  响应比R = (等待时间 + 要求执行时间) / 要求执行时间</li>
</ul>
</li>
</ul>
<h3 id="5-3-1-FCFS算法"><a href="#5-3-1-FCFS算法" class="headerlink" title="5.3.1 FCFS算法"></a>5.3.1 FCFS算法</h3><ul>
<li>  按照进程或作业提交顺序形成就绪状态的先后次序，分派CPU</li>
<li>  当前进程或作业占用CPU，直到执行完或阻塞，才出让CPU（非抢占方式）</li>
<li>  在进程或作业唤醒后（如I/O完成），并不立即恢复执行，通常等到当前作业或进程出让CPU</li>
<li>  最简单的算法</li>
<li>  用一个队列就可以实现</li>
</ul>
<p>FCFS的特点</p>
<ul>
<li>比较有利于长进程，而不利于短进程。</li>
<li>有利于CPU Bound的进程，而不利于I/O Bound的进程。</li>
</ul>
<h3 id="5-3-2-SJF算法"><a href="#5-3-2-SJF算法" class="headerlink" title="5.3.2 SJF算法"></a>5.3.2 SJF算法</h3><ul>
<li>  对预计执行时间短的作业（进程）优先分派处理器</li>
<li>  最优的算法</li>
<li>  平均等待时间最小</li>
<li>  常用于长期调度</li>
</ul>
<p>SJF的变型：</p>
<ul>
<li>最短剩余时间优先<strong>SRTF</strong>(Shortest Remaining Time First)-基于抢占的SJF算法<ul>
<li>  允许比当前进程剩余时间更短的进程来抢占</li>
</ul>
</li>
<li>最高响应比优先HRRN(Highest Response Ratio Next)<ul>
<li>响应比R = (等待时间 + 要求执行时间) / 要求执行时间<br>  是FCFS和SJF的折衷</li>
</ul>
</li>
</ul>
<h3 id="5-3-3-优先权调度"><a href="#5-3-3-优先权调度" class="headerlink" title="5.3.3 优先权调度"></a>5.3.3 优先权调度</h3><p>该算法总是把处理机分配给就绪队列中具有最高优先权的进程。</p>
<p>常用以下两种方法来确定进程的优先权： </p>
<p>静态优先权: 静态优先权是在创建进程时确定的，在整个运行期间不再改变。依据有：进程类型、进程对资源的要求、用户要求的优先权。</p>
<p>动态优先权: 动态优先权是基于某种原则，使进程的优先权随时间改变而改变。</p>
<p>假定：最小的整数 = 最高的优先级.</p>
<p>SJF是以下一次CPU脉冲长度作为优先数的优先级调度</p>
<p>可以是抢占也可以非抢占</p>
<p>会产生饥饿：优先权低的进程可能永远不会被执行</p>
<ul>
<li>  解决方法：老化：随着时间推移，等待时间长的进程优先级会被提高</li>
</ul>
<h3 id="5-3-4-时间片轮转"><a href="#5-3-4-时间片轮转" class="headerlink" title="5.3.4 时间片轮转"></a>5.3.4 时间片轮转</h3><p>特点：允许抢占，平均等待时间一般较长</p>
<p>基本思路：通过时间片轮转，提高进程并发性和响应时间特性，从而提高资源利用率。</p>
<p>RR算法：</p>
<ul>
<li>  将系统中所有的就绪进程按照FCFS原则，排成一个队列。</li>
<li>  每次调度时将CPU分派给队首进程，让其执行一个时间片 (time slice) 。时间片的长度从几个ms到几百ms。</li>
<li>  在一个时间片结束时，发生时钟中断。</li>
<li>  调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程。</li>
<li>  进程可以未使用完一个时间片，就出让CPU（如阻塞）。</li>
</ul>
<p>时间片长度的影响因素：</p>
<ul>
<li>  就绪进程的数目：数目越多，时间片越小（当响应时间一定时）</li>
<li>  系统的处理能力：应当使用户输入通常在一个时间片内能处理完，否则使响应时间，平均周转时间和平均带权周转时间延长。</li>
</ul>
<p>【其他】</p>
<p>在RR调度算法中，没有进程被连续分配超过一个时间片的CPU（除非它是唯一可运行的进程）。</p>
<p>如果进程的CPU执行超过一个时间片，那么该进程会被抢占，并被放回到就绪队列。</p>
<h3 id="5-3-5-多级队列调度"><a href="#5-3-5-多级队列调度" class="headerlink" title="5.3.5 多级队列调度"></a>5.3.5 多级队列调度</h3><p>特点：引入多个就绪队列，通过各队列的区别对待，达到一个综合的调度目标</p>
<p>根据进程的性质或类型的不同，将就绪队列再分为若干个子队列。</p>
<p>每个作业固定归入一个队列。</p>
<p>各队列的不同处理：不同队列可有不同的优先级、时间片长度、调度策略等。如：系统进程、用户交互进程、批处理进程等。</p>
<p>级队列算法调度须在队列间进行</p>
<ul>
<li><p>  固定优先级调度，即前台运行完后再运行后台。有可能产生饥饿</p>
</li>
<li><p>  给定时间片调度，即每个队列得到一定的CPU时间，进程在给定时间内执行；如，80%的时间执行前台的RR调度，20%的时间执行后台的FCFS调度</p>
</li>
</ul>
<img src="../images/image-20210201160951705.png" alt="image-20210201160951705" style="zoom: 67%;" />

<h3 id="5-3-6-多级反馈队列"><a href="#5-3-6-多级反馈队列" class="headerlink" title="5.3.6 多级反馈队列"></a>5.3.6 多级反馈队列</h3><p>多级反馈队列算法是时间片轮转算法和优先级算法的综合和发展。</p>
<p>优点：</p>
<ul>
<li>  为提高系统吞吐量和缩短平均周转时间而照顾短进程</li>
<li>  为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程</li>
<li>  不必估计进程的执行时间，动态调节</li>
</ul>
<p>设置多个就绪队列，分别赋予不同的优先级，如逐级降低，队列1的优先级最高。每个队列执行时间片的长度也不同，规定优先级越低则时间片越长，如逐级加倍</p>
<p>新进程进入内存后，先投入队列1的末尾，按FCFS算法调度；若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，同样按FCFS算法调度；如此下去，降低到最后的队列，则按”时间片轮转”算法调度直到完成。</p>
<p>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢占执行新进程，并把被抢占的进程投入原队列的末尾。</p>
<img src="../images/image-20210201161158163.png" alt="image-20210201161158163" style="zoom:50%;" />

<h2 id="5-4-线程调度"><a href="#5-4-线程调度" class="headerlink" title="5.4 线程调度"></a>5.4 线程调度</h2><p>在支待线程的操作系统上，内核级线程（而不是进程）才是操作系统所调度的。用户级线程是由线程库来管理的，而内核并不知道它们。用户级线程为了运行在CPU上，最终应映射到相关的内核级线程，但是这种映射可能不是直接的，可能采用轻量级进程(LWP)。</p>
<h1 id="第六章：进程同步"><a href="#第六章：进程同步" class="headerlink" title="第六章：进程同步"></a>第六章：进程同步</h1><p>进程之间竞争资源面临三个控制问题：</p>
<ul>
<li><p>  <strong>互斥</strong>（mutual exclusion )指多个进程不能同时使用同一个资源</p>
</li>
<li><p>  <strong>死锁</strong>（deadlock )指多个进程互不相让，都得不到足够的资源。永远得不到资源</p>
</li>
<li><p>  <strong>饥饿</strong>（starvation )指一个进程长时间得不到资源（其他进程可能轮流占用资源）。资源分配不公平</p>
</li>
</ul>
<h2 id="6-1-临界区问题"><a href="#6-1-临界区问题" class="headerlink" title="6.1 临界区问题"></a>6.1 临界区问题</h2><p>每个进程有一段代码，称为临界区(critical section) ，进程在执行该区时可能修改公共变量、更新一个表、写一个文件等。</p>
<p>当一个进程在临界区内执行时，其他进程不允许在它们的临界区内执行。也就是说，没有两个进程可以在它们的临界区内同时执行。</p>
<p>临界区问题(critical-section problem)是，设计一个协议以便协作进程。在进入临界区前，每个进程应请求许可。实现这一请求的代码区段称为进入区(entry section) 。临界区之后可以有退出区(exit section) ，其他代码为剩余区(remainder section) 。</p>
<p>临界资源：一次只允许一个进程使用(访问)的资源。如：硬件打印机、磁带机等，软件的消息缓冲队列、变量、数组、缓冲区等。</p>
<p>临界区：访问临界资源的那段代码</p>
<p>必须满足的要求：</p>
<ul>
<li>  互斥</li>
<li>  空闲让进</li>
<li>  有限等待</li>
</ul>
<h2 id="6-2-锁"><a href="#6-2-锁" class="headerlink" title="6.2 锁"></a>6.2 锁</h2><h3 id="6-2-1-互斥锁"><a href="#6-2-1-互斥锁" class="headerlink" title="6.2.1 互斥锁"></a>6.2.1 互斥锁</h3><p>一个进程在进入临界区时应得到锁；它在退出临界区时释放锁</p>
<p>当一个进程试图获取不可用的锁时，它会阻塞，直到锁被释放</p>
<h3 id="6-2-2-自旋锁-spinlock"><a href="#6-2-2-自旋锁-spinlock" class="headerlink" title="6.2.2 自旋锁 spinlock"></a>6.2.2 自旋锁 spinlock</h3><p>是一个与共用数据结构有关的锁定机制。特殊形式的互斥锁</p>
<p>储存在共用内存中。为了速度和使用任何在处理器体系下提供的锁定机构，获取和释放自旋锁的代码是用汇编语言写的。</p>
<p>当线程试图获得自旋锁时，在处理器上所有其它工作将终止。因此<strong>拥有自旋锁的线程永远不会被抢占</strong>，但允许它继续执行以便使它尽快把锁释放。内核对于使用自旋锁十分小心，当它拥有自旋锁时，它执行的指令数将减至最少。</p>
<p>【优点】：当进程在等待锁时，没有上下文切换（上下文切换可能需要相当长的时间） 。</p>
<p>因此，当使用锁的时间较短时，自旋锁还是有用的。自旋锁通常用于多处理器系统，一个线程可以在一个处理器上“旋转＂，而其他线程在其他处理器上执行临界区。</p>
<h2 id="6-3-信号量"><a href="#6-3-信号量" class="headerlink" title="6.3 信号量"></a>6.3 信号量</h2><p>整形变量，只能 wait( ）和signal( ），原子性操作，当 S &lt;= 0 的时候，进程必须等待</p>
<p>通常用信号量表示资源或临界区</p>
<p>信号量的物理含义  </p>
<ul>
<li><p>  <code>S.value &gt;0</code> 表示有 <code>S.value</code> 个资源可用； </p>
</li>
<li><p>  <code>S.value=0</code>  表示无资源可用或表示不允许进程再进入临界区； </p>
</li>
<li><p>  <code>S.value&lt;0</code>  则 <code>|S.value|</code> 表示在等待队列中进程的个数或表示等待进入临界区的进程个数。 </p>
</li>
</ul>
<p>wait(S) ≡ P(S) ≡ down(S)  ： 表示申请一个资源</p>
<p>signal(S) ≡ V(S) ≡ up(S)   ： 表示释放一个资源</p>
<p>分类：</p>
<ul>
<li>  整型信号量</li>
<li>  记录型信号量</li>
<li>  AND型信号量</li>
<li>  二值信号量</li>
</ul>
<p>二值信号量类似互斥锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex;    <span class="comment">//  initialized to 1</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	wait (mutex);</span><br><span class="line">         <span class="comment">// Critical Section</span></span><br><span class="line">     signal (mutex);</span><br><span class="line">		<span class="comment">// remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (TRUE);</span><br></pre></td></tr></table></figure>



<p>计数信号量可以用于控制访问具有多个实例的某种资源。</p>
<p>1、信号量的初值为可用资源数量。</p>
<p>2、当进程需要使用资源时，需要对该信号扯执行wait( ）操作。</p>
<p>3、当进程释放资源时，需要对该信号最执行signal( ）操作。</p>
<p>4、当信号量的计数为0 时，所有资源都在使用中。之后，需要使用资源的进程将会阻塞，直到计数大于0 。</p>
<p>【信号量的实现】</p>
<p>当一个进程执行 P 操作并且发现信号量不为正时，它必须等待。然而，该进程不是忙等待而是阻塞自己 block()。阻塞操作将一个进程放到与信号量相关的等待队列中，并且将该进程状态切换成等待状态。然后，控制转到CPU 调度程序，以便选择执行另一个进程。</p>
<p>等待信号量 S 而阻塞的进程，在其他进程执行操作signal( ）后，应被重新执行。进程的重新执行是通过操作 wakeup( ）来进行的，它将进程从等待状态改为就绪状态。然后，进程被添加到就绪队列</p>
<p>wait、signal操作必须成对出现，有一个wait操作就一定有一个signal操作。一般情况下：当为互斥操作时，它们同处于同一进程；当为同步操作时，则不在同一进程中出现。 </p>
<p>如果两个wait操作相邻，那么它们的顺序至关重要，而两个相邻的signal操作的顺序无关紧要。一个同步wait操作与一个互斥wait操作在一起时，同步wait操作在互斥wait操作前。 </p>
<p>wait、signal操作的优缺点 </p>
<p>优点：简单，而且表达能力强 </p>
<p>缺点：不够安全；wait、signal操作使用不当会出现死锁；实现复杂。 </p>
<h2 id="6-4-经典同步问题"><a href="#6-4-经典同步问题" class="headerlink" title="6.4 经典同步问题"></a>6.4 经典同步问题</h2><ul>
<li>  生产者消费者问题（有界缓冲区问题）</li>
<li>  读者写者问题</li>
<li>  哲学家就餐问题</li>
</ul>
<p>生产者-消费者问题是最著名的同步问题，它描述一组生产者（P1  ……Pm）向一组消费者（C1……Cq）提供消息。它们共享一个有限缓冲池（bounded buffer pool）,生产者向其中投放消息，消费者从中取得消息。</p>
<p>生产者-消费者问题是许多相互合作进程的一种抽象。</p>
<p>读者写者</p>
<p>一个数据集（如文件）如果被几个并行进程所共享：</p>
<ul>
<li><p>  有些进程只要求读数据集内容，它称读者</p>
</li>
<li><p>  一些进程则要求修改数据集内容，它称写者</p>
</li>
<li><p>  几个读者可以同时读些数据集，而不需要互斥</p>
</li>
<li><p>  一个写者不能和其它进程（不管是写者或读者）同时访问些数据集，它们之间必须互斥。</p>
</li>
</ul>
<p>当写者写入数据时，独占数据库</p>
<p>【问题变种】</p>
<ul>
<li>第一读者写者问题<ul>
<li>  读者进程不应等待，除非数据库被另一个进程使用</li>
</ul>
</li>
<li>第二读者写者问题<ul>
<li>  一旦写者进程就绪，那么写者进程就必须尽可能快被执行</li>
</ul>
</li>
</ul>
<p>哲学家就餐问题</p>
<p>多个进程之间分配多个资源，并且不会产生饥饿和死锁。</p>
<p>为了避免死锁，把哲学家分为三种状态：思考、饥饿、吃饭，并且一次拿到两只筷子，否则不拿。（Dijkstra）</p>
<h2 id="6-5-管程"><a href="#6-5-管程" class="headerlink" title="6.5 管程"></a>6.5 管程</h2><p>管程的定义：管程是关于共享资源的数据结构及一组针对该资源的操作过程所构成的软件模块。</p>
<p>管程是管理进程间同步的机制，它保证进程互斥地访问共享变量，并方便地阻塞和唤醒进程。</p>
<p>管程可以函数库的形式实现。相比之下，管程比信号量好控制</p>
<p>主要特性：</p>
<ul>
<li><p>  模块化：一个管程是一个基本程序单位，可以单独编译；</p>
</li>
<li><p>  抽象数据类型：管程是一种特殊的数据类型，其中不仅有数据，而且有对数据进行操作的代码</p>
</li>
<li><p>  信息封装：管程是半透明的，管程中的外部过程（函数）实现了某些功能，至于这些功能是怎样实现的，在其外部则是不可见的；</p>
</li>
</ul>
<p>实现要素：</p>
<ul>
<li><p>  管程中的共享变量在管程外部是不可见的，外部只能通过调用管程中所说明的外部过程（函数）来间接地访问管程中的共享变量；</p>
</li>
<li><p>  为了保证管程共享变量的数据完整性，规定管程互斥进入；</p>
</li>
<li><p>  管程通常是用来管理资源的，因而在管程中应当设有进程等待队列以及相应的等待及唤醒操作；</p>
</li>
</ul>
<p>组成：</p>
<ul>
<li><p>  名称：为每个共享资源设立一个管程</p>
</li>
<li><p>  数据结构说明：一组局部于管程的控制变量</p>
</li>
<li><p>  操作原语：对控制变量和临界资源进行操作的一组原语过程（程序代码），是访问该管程的唯一途径。这些原语本身是互斥的，任一时刻只允许一个进程去调用，其余需要访问的进程就等待。</p>
</li>
<li><p>  初始化代码：对控制变量进行初始化的代码</p>
</li>
</ul>
<p>由于管程通常是用于管理资源的，因而在管程内部，应当存在某种等待机制。当进入管程的进程因资源被占用等原因不能继续运行时使其等待。为此在管程内部可以说明和使用一种特殊类型的变量—-<strong>条件变量</strong>。</p>
<p>每个条件变量表示一种等待原因，并不取具体数值－－相当于每个原因对应一个队列。</p>
<h1 id="第七章：死锁"><a href="#第七章：死锁" class="headerlink" title="第七章：死锁"></a>第七章：死锁</h1><h2 id="7-1-概念"><a href="#7-1-概念" class="headerlink" title="7.1 概念"></a>7.1 概念</h2><p>死锁：指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进</p>
<p>四个必要条件：</p>
<p>1、互斥：一个资源同一时间只能被一个进程使用</p>
<p>2、Hold and wait（占有并等待、请求和保持）：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对已经获得的其它资源保持不放</p>
<p>3、不可抢占、不剥夺：已有的资源不能被抢占</p>
<p>4、循环等待</p>
<h2 id="7-2-处理策略"><a href="#7-2-处理策略" class="headerlink" title="7.2 处理策略"></a>7.2 处理策略</h2><p>简单讲：预防、避免、检测、解除、装死看不到</p>
<p>大体分三种：</p>
<p>1、通过协议来预防或避免死锁，确保系统不会进入死锁状态。打破死锁的必要条件，一般是限制申请资源来解决，或者运行抢占资源，再比如就是进程有序申请资源</p>
<p>2、可以允许系统进入死锁状态，然后检测它，并加以恢复。</p>
<p>3、可以忽视这个问题，认为死锁不可能在系统内发生（如果发生了，程序员自己解决）</p>
<h2 id="7-3-死锁避免算法"><a href="#7-3-死锁避免算法" class="headerlink" title="7.3 死锁避免算法"></a>7.3 死锁避免算法</h2><h3 id="7-3-1-资源分配图算法"><a href="#7-3-1-资源分配图算法" class="headerlink" title="7.3.1 资源分配图算法"></a>7.3.1 资源分配图算法</h3><p>算法：假设进程Pi申请资源Rj。只有在需求边Pi –&gt; Rj 变成分配边 Rj –&gt; Pi 而不会导致资源分配图形成环时，才允许申请。</p>
<p>用算法循环检测，如果没有环存在，那么资源分配会使系统处于安全状态。如果存在环，资源分配会使系统不安全。进程Pi必须等待。</p>
<h3 id="7-3-2-银行家算法"><a href="#7-3-2-银行家算法" class="headerlink" title="7.3.2 银行家算法"></a>7.3.2 银行家算法</h3><p>Dijkstra 提出的</p>
<h2 id="7-4-死锁检测"><a href="#7-4-死锁检测" class="headerlink" title="7.4 死锁检测"></a>7.4 死锁检测</h2><p>死锁检测</p>
<p>死锁恢复</p>
<ul>
<li>终止进程<ul>
<li>  终止所有死锁的进程</li>
<li>  一次终止一个进程，直到消除死锁循环为止</li>
</ul>
</li>
<li>允许资源抢占<ul>
<li>  选择牺牲进程</li>
<li>  回滚牺牲的进程</li>
<li>  饥饿避免（不能总牺牲同一个）</li>
</ul>
</li>
</ul>
<h1 id="第八章：内存管理"><a href="#第八章：内存管理" class="headerlink" title="第八章：内存管理"></a>第八章：内存管理</h1><h2 id="8-1-背景"><a href="#8-1-背景" class="headerlink" title="8.1 背景"></a>8.1 背景</h2><p>操作系统的主要目的是执行程序，在执行时，这些程序及其访问的数据应该至少部分在内存中。</p>
<p>内存是现代计算机运行的核心 。 内存由一个很大的字节数组来组成， 每个字节都有各自的地址。 CPU 根据程序计数器的值从内存中提取指令，这些指令可能引 起对特定内存地址的额外加载与存储。 </p>
<p>CPU 可以直接访问的通用存储只有<strong>内存</strong>和处理器<strong>内置的寄存器</strong>。 机器指令可以用内存地址作为参数，而不能用磁盘地址作为参数。 因此，执行指令以及指令使用的数据，应处在这些可直接访问的存储设备上。 如果数据不在内存中，那么在 CPU 使用它们之前应先把数据移到内存。 </p>
<p>CPU 内置寄存器通常可以在一个 CPU 时钟周期内完成访问。对千寄存器的内容，大多数 CPU 可以在一个时钟周期内解释并执行一条或多条指令。而对于内存（它可通过内存总线的事务来访问），就不行了。完成内存的访问可能需要多个 CPU 时钟周期。在这种情况下，由于没有数据以便完成正在执行的指令，CPU 通常需要暂停(stall)。由于内存访问的频繁，这种情况是无法容忍的。补救措施是在 CPU 与内存之间，通常是在 CPU 芯片上，增加更快的内存；这称为高速缓存(cache)</p>
<p><img src="../images/image-20210210141158021.png" alt="image-20210210141158021"></p>
<p>确保每个进程都有一个单独的内存空间。 单独的进程内存空间可以保护 进程而不互相影响</p>
<p>基地址寄存器(base register) 含有最小的合法的物理内存地址，而界限地址寄存器 (limit register) 指定了范围的大小。 </p>
<p><img src="../images/image-20210210140936759.png" alt="image-20210210140936759"></p>
<p>内存空间保护的实现是通过 CPU 硬件对在用户模式下产生的地址与寄存器的地址进行比较来完成的</p>
<p>只有操作系统可以通过特殊的特权指令，才能加载基地址寄存器和界限地址寄存器。</p>
<h3 id="8-1-1-绝对地址和相对地址"><a href="#8-1-1-绝对地址和相对地址" class="headerlink" title="8.1.1 绝对地址和相对地址"></a>8.1.1 绝对地址和相对地址</h3><p>Logical address（逻辑地址，相对地址，虚地址）</p>
<ul>
<li><p>用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式。</p>
</li>
<li><p>首地址为0，其余指令中的地址都相对于首地址来编址。</p>
</li>
<li><p>不能用逻辑地址在内存中读取信息。</p>
</li>
</ul>
<p>Physical address （物理地址，绝对地址，实地址）</p>
<ul>
<li>内存中存储单元的地址。</li>
<li>物理地址可直接寻址</li>
</ul>
<p>从虚拟地址到物理地址的运行时映射是由内存管理单元 (Memory-Management Unit, MMU ) 的硬件设备来完成。</p>
<h2 id="8-1-2-动态加载和动态链接"><a href="#8-1-2-动态加载和动态链接" class="headerlink" title="8.1.2 动态加载和动态链接"></a>8.1.2 动态加载和动态链接</h2><p> 采用动态加载时，一个程序只有在调用时才会加载。所有程序都以 可重定位加载格式保存在磁盘上。</p>
<p>程序执行步骤：</p>
<p>1、主程序被加载到内存，并执行。 </p>
<p>2、当一个程序需要调用另一 个程序时，调用程序首先检查另一个程序是否已加载。 如果没有，可重定位链接程序会加 载所需的程序到内存，并更新程序的地址表以反映这一变化。 </p>
<p>3、控制传递给新加载的 程序。</p>
<p>优点：只有一个程序被需要时，它才会被加载；</p>
<p>在内核模式下执行的操作系统可以无限制地访问操作系统及用户的内存。 </p>
<p>1、加载用户程序到用户内存</p>
<p>2、转储出现错误的程序</p>
<p>3、访问和修改系统调用的参数</p>
<p>4、执行用户内存的 IO</p>
<p>5、提供许多其他服务等</p>
<h2 id="8-2-Swapping（交换技术）"><a href="#8-2-Swapping（交换技术）" class="headerlink" title="8.2 Swapping（交换技术）"></a>8.2 Swapping（交换技术）</h2><p>进程必须在内存中以便执行。不过，进程可以暂时从内存交换(swap)到备份存储(backing store)，当再次执行时再调回到内存中。</p>
<p>交换有可能让所有进程的总的物理地址空间超过真实系统的物理地址空间，</p>
<p>如果我们想要换出一个进程，那么应确保该进程是完全处于空闲的。</p>
<p>一个常用的变种是(UNIX, Linux, and Windows)：</p>
<p>正常情况下，禁止交换；</p>
<p>当空闲内存（未被操作系统或进程使用的内存）低千某个阙值时，启用交换。</p>
<p>当空闲内存的数量增加了，就停止交换。</p>
<p>另一变种是交换进程的部分（而不是整个进程），以降低交换时间。</p>
<p>移动系统不支持交换，Flash memory based：</p>
<ul>
<li><p>小空间</p>
</li>
<li><p>闪存写次数限制</p>
</li>
<li><p>在移动平台上闪存和 CPU 之间的吞吐量很低</p>
</li>
</ul>
<p>iOS要求应用程序自愿放弃分配的内存</p>
<ul>
<li><p>只读数据从系统中直接删除，已修改数据不会被删除</p>
</li>
<li><p>OS可以终止任何未能释放足够空间的应用</p>
</li>
</ul>
<p>Android如果空闲内存不足，会终止应用程序，但首先会将应用程序状态写入闪存，以便快速重启</p>
<h2 id="8-3-连续内存分配"><a href="#8-3-连续内存分配" class="headerlink" title="8.3 连续内存分配"></a>8.3 连续内存分配</h2><p>内存通常分为两个区域：一个用于驻留操作系统，另一个用于用户进程。</p>
<p>操作系统可以放在低内存，也可放在高内存。影响这一决定的主要因素是中断向量的位置。由于中断向量通常位于低内存，因此程序员通常将操作系统也放在低内存</p>
<p>在采用连续内存分配 (contiguous memory allocation) 时， 每个进程位于一个连续的内存区域，与包含下一个进程的内存相连</p>
<h3 id="8-3-1-内存保护"><a href="#8-3-1-内存保护" class="headerlink" title="8.3.1 内存保护"></a>8.3.1 内存保护</h3><p>重定位寄存器、界限寄存器</p>
<p> MMU 通过动态地将逻辑地址加上重定位寄存器的值，来进行映射。 映射后的地址再发送到内存</p>
<p><img src="../images/image-20210210145915125.png" alt="image-20210210145915125"></p>
<h3 id="8-3-2-内存分配"><a href="#8-3-2-内存分配" class="headerlink" title="8.3.2 内存分配"></a>8.3.2 内存分配</h3><p>多分区分配</p>
<p>分区式管理的基本思想是将内存划分成若干个连续区域，称为分区。每个分区只能存放一个进程。 </p>
<ul>
<li><p>fixed partitioning（固定分区）：分区大小固定</p>
</li>
<li><p>Dynamic Partitions（动态分区）：在程序装入内存时把可用内存“切出”一个连续的区域分配给该进程，且分区大小正好适合进程的需要。操作系统维护已分配分区和空闲分区的信息</p>
</li>
</ul>
<p>动态存储分区问题（Dynamic Storage-Allocation Problem）</p>
<p>1、首次适应（First-fit）：分配首个足够大的孔。查找可以从头开始，也可以从上次首次适应结束时开始。一旦找到足够大的空闲孔，就可以停止。 </p>
<p>2、最优适应（Best-fit）：分配最小的足够大的孔。 应查找整个列表</p>
<p>3、最差适应（Worst-fit）：分配最大的孔。 应查找整个列表</p>
<p>4、Next-fit：类似首次适应，每次分区时，查找都从上次结束的地方开始</p>
<p>首次适应和最优适应在执行时间和利用空间方面都好于最差适应。 </p>
<p>首次适应和最优适应在利用空间方面难分伯仲，但是首次适应要更快些。</p>
<h3 id="8-3-3-碎片（Fragmentation）"><a href="#8-3-3-碎片（Fragmentation）" class="headerlink" title="8.3.3 碎片（Fragmentation）"></a>8.3.3 碎片（Fragmentation）</h3><p>首次适应和最优适应算法都有外部碎片 </p>
<p>外部碎片问题的一种解决方法是紧缩 ( compaction) 。 它的目的是移动内存内容，以便将所有空闲空间合并成一整块。 </p>
<p>外部碎片化问题的另一个可能的解决方案是：允许进程的逻辑地址空间是不连续的；这样，只要有物理内存可用，就允许为进程分配内存。 有两种互补的技术可以实现这个解决方 案：分段和分页</p>
<p>内部碎片 (internal fragmentation)，这部分内存在分区内部，但又不能用</p>
<h2 id="8-4-分段"><a href="#8-4-分段" class="headerlink" title="8.4 分段"></a>8.4 分段</h2><p>逻辑地址空间是由一组段构成。每个段都有名称和长度。</p>
<p>地址指定了段名称和段内偏移。因此用户通过两个量来指定地址：段名称和段偏移。</p>
<p>为了实现简单起见，段是编号的，是通过段号而不是段名称来引用。因此，逻辑地址由有序对组成：</p>
<p><code>＜段号s，段偏移d＞</code></p>
<p>通常，在编译用户程序时，编译器会根据输入程序来自动构造段。</p>
<p> 段表的每个条目都有段基地址 (segment base) 和段界限 (segment limit) 。 段基地址包含该段在内存中的开始物理地址，而 段界限指定该段的长度。</p>
<h2 id="8-5-分页"><a href="#8-5-分页" class="headerlink" title="8.5 分页"></a>8.5 分页</h2><p>物理内存分为固定大小的块，称为帧(size is power of 2, between 512 bytes and 8,192 bytes)</p>
<ul>
<li>Linux 、Windows for x86: 4K</li>
<li>查看命令 <code>getconf PAGESIZE</code></li>
</ul>
<p>逻辑内存也分为同样大小的块，称为页</p>
<p>跟踪所有的空闲帧</p>
<p>设置一个页表来将逻辑地址转换为物理地址</p>
<p>页码作为页表的索引 。 页表包含每页所在物理内存的基地址。 这个基地址与页偏移的组合就形成了物理内存地址，可发送到物理单元</p>
<p>有内碎片（可能用不完）</p>
<p>如果进程大小与页大小无关，那么每个进程的内部碎片的均值为半页 。 </p>
<p>分页允许我们使用的物理内存大于 CPU 地址指针可访问的空间 。</p>
<p>TLB 与页表一起使用的方法如下： </p>
<p>TLB 只包含少数的页表条目 。 当 CPU 产生一个逻辑 地址后，它的页码就发送到 TLB。 如果找到这个页码，它的帧码也就立即可用，可用于访 问内存。 </p>
<p>如果页码不在 TLB 中（称为 TLB 未命中 (TLB miss ) ），那么就需访问页表。 取决于 CPU,，这可能由硬件自动处理或通过操作系统的中断来处理。</p>
<p>当得到帧码后，就可以用它们来访间内存。 另外，将页码和帧码添加到 TLB,，这样下次再用时就可很快查找到；如果 TLB 内的条目已满，那么会选择一个来替换</p>
<h1 id="第九章：虚拟内存管理"><a href="#第九章：虚拟内存管理" class="headerlink" title="第九章：虚拟内存管理"></a>第九章：虚拟内存管理</h1><h2 id="9-1-Demand-paging-（请求调页，按需调页，请求页式管理）"><a href="#9-1-Demand-paging-（请求调页，按需调页，请求页式管理）" class="headerlink" title="9.1 Demand paging （请求调页，按需调页，请求页式管理）"></a>9.1 Demand paging （请求调页，按需调页，请求页式管理）</h2><p>仅在需要时才加载页面</p>
<p>有效-无效位方案：当该位被设置为“有效”时，相关联的 页面是合法的，并且在内存中 。 当该位被设置为“无效”时，页面无效（ 即不在进程的逻辑 地址空间中），或有效但只在磁盘上。 对千已调入内存的页面，它的页表条目是照常设置的； 但是对于不在内存的页面，它的页表条目可简单标记为无效，或者包含磁盘上的页面地址。 </p>
<p><img src="../images/image-20210210154135243.png" alt="image-20210210154135243"></p>
<p>对标记为无效的页面访问会产生缺页错误(page fault)。</p>
<p>分页硬件在通过页表转换地址时会注意到无效位被设置，从而陷入操作系统。这种陷阱是由于操作系统未能将所需的页面调入内存引起的。处理这种缺页错误的程序很简单：</p>
<p>1．检查这个进程的内部表，以确定该引用是有效的还是无效的内存访问。</p>
<p>2．如果引用无效，那么终止进程。如果引用有效但是尚未调入页面，那么现在就应调入。</p>
<p>3．找到一个空闲帧（例如，从空闲帧链表上得到一个）。</p>
<p>4．调度一个磁盘操作，以将所需页面读到刚分配的帧。</p>
<p>5．当磁盘读取完成时，修改进程的内部表和页表，以指示该页现在处于内存中。</p>
<p>6．重新启动被陷阱中断的指令。</p>
<p>该进程现在能访问所需的页面，就好像它总是在内存中。</p>
<p>在任何情况下，缺页错误的处理时间有三个主要组成部分：</p>
<p>1、处理缺页错误中断。</p>
<p>2、读入页面。</p>
<p>3、重新启动进程</p>
<h2 id="9-2-写时复制-copy-on-write"><a href="#9-2-写时复制-copy-on-write" class="headerlink" title="9.2 写时复制 (copy-on-write)"></a>9.2 写时复制 (copy-on-write)</h2><p>允许父进程和子进程最初共享相同的页面来工作。</p>
<p> 这些共享页面标记为写时复制，这意味着如果任何一个进程<strong>写入共享页面</strong>，那么就创建共享页面的副本</p>
<p>当使用写时复制技术时，仅复制任何一进程修改的页面，所有未修改的页面可以由父进程和子进程共享。</p>
<p>还要注意，只有可以修改的页面才需要标记为写时复制。不能修改的页面（包含可执行代码的页面）可以由父进程和子进程共享。</p>
<p><img src="../images/image-20210210154730349.png" alt="image-20210210154730349"></p>
<p>可以使用池化技术</p>
<h2 id="9-3-页面置换"><a href="#9-3-页面置换" class="headerlink" title="9.3 页面置换"></a>9.3 页面置换</h2><p>步骤：</p>
<p>1、找到所需页面的磁盘位置。</p>
<p>2、找到一个空闲帧：</p>
<p>​    a．如果有空闲帧，那么就使用它。</p>
<p>​    b．如果没有空闲帧，那么就使用页面置换算法来选择一个牺牲帧(victim frame)。</p>
<p>​    c.     将牺牲帧的内容写到磁盘上，修改对应的页表和帧表。</p>
<p>3、将所需页面读入（新的）空闲帧，修改页表和帧表。</p>
<p>4、从发生缺页错误位置，继续用户进程。</p>
<p><strong>有关算法：</strong></p>
<ul>
<li><p>First-In-First-Out Algorithm (FIFO，先进先出算法) </p>
</li>
<li><p>Optimal Algorithm （OPT，最佳页面置换算法）：置换最长时间不会使用的页面</p>
</li>
<li><p>Least Recently Used (LRU) Algorithm (最近最久使用算法) </p>
</li>
<li><p>LRU Approximation Algorithms （近似LRU算法） ：</p>
<ul>
<li><p>Additional-Reference-Bits Algorithm</p>
</li>
<li><p>Second-Chance（clock） Algorithm</p>
</li>
<li><p>Enhanced Second-Chance  Algorithm</p>
</li>
</ul>
</li>
<li><p>Counting-Base Page Replacement：</p>
<ul>
<li><p>Least Frequently Used Algorithm (LFU，最不经常使用算法）</p>
</li>
<li><p>Most Frequently Used Algorithm (MFU，最经常使用算法)</p>
</li>
</ul>
</li>
</ul>
<p>Page Buffering Algorithm（页面缓冲算法）</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
</search>
